From 0379772eb510ae16fa15a0995277e0f04cec07a5 Mon Sep 17 00:00:00 2001
From: Oleksii Kurochko <oleksii.kurochko@globallogic.com>
Date: Tue, 7 Jun 2016 16:14:37 +0300
Subject: [PATCH] Add virtualization support for dra7xx-evm

* add patches for u-boot for virtualizaion
* add patches for kernel for virtualizaion
* change mksdboot.sh ( copy xen and not prebuilt u-boot)
* xen is built separately
---
 bin/mksdboot.sh                                    |    8 +-
 ...hange-build-config-and-add-dom0-dtb-files.patch |   34 +
 .../0004-meta-glsdk-add-patches-for-u-boot.patch   |  948 ++
 .../0005-meta-glsdk-add-patches-for-kernel.patch   | 9889 ++++++++++++++++++++
 .../meta-ti/0002-meta-ti-change-uboot-config.patch |   25 +
 .../0003-meta-ti-change-console-to-hvc0.patch      |   25 +
 ...003-oe-core-fix-getting-of-id-for-inittab.patch |   25 +
 7 files changed, 10952 insertions(+), 2 deletions(-)
 create mode 100644 patch/meta-glsdk/0003-ti_glsdk-change-build-config-and-add-dom0-dtb-files.patch
 create mode 100644 patch/meta-glsdk/0004-meta-glsdk-add-patches-for-u-boot.patch
 create mode 100644 patch/meta-glsdk/0005-meta-glsdk-add-patches-for-kernel.patch
 create mode 100644 patch/meta-ti/0002-meta-ti-change-uboot-config.patch
 create mode 100644 patch/meta-ti/0003-meta-ti-change-console-to-hvc0.patch
 create mode 100644 patch/oe-core/0003-oe-core-fix-getting-of-id-for-inittab.patch

diff --git a/bin/mksdboot.sh b/bin/mksdboot.sh
index e7e4289..69e15cf 100755
--- a/bin/mksdboot.sh
+++ b/bin/mksdboot.sh
@@ -164,9 +164,13 @@ execute "mkdir -p /tmp/sdk/$$/rootfs"
 execute "mount ${device}1 /tmp/sdk/$$/boot"
 execute "mount ${device}2 /tmp/sdk/$$/rootfs"
 
-execute "cp $sdkdir/board-support/prebuilt-images/MLO /tmp/sdk/$$/boot/"
-execute "cp $sdkdir/board-support/prebuilt-images/u-boot.img /tmp/sdk/$$/boot/"
+execute "cp $sdkdir/yocto-layers/build/arago-tmp-external-linaro-toolchain/deploy/images/dra7xx-evm/MLO /tmp/sdk/$$/boot/"
+execute "cp $sdkdir/yocto-layers/build/arago-tmp-external-linaro-toolchain/deploy/images/dra7xx-evm/u-boot.img /tmp/sdk/$$/boot/"
 execute "cp $sdkdir/board-support/prebuilt-images/uenv*.txt /tmp/sdk/$$/boot/"
+execute "cp $sdkdir/board-support/prebuilt-images/xen-uImage /tmp/sdk/$$/boot/"
+execute "cp $sdkdir/board-support/prebuilt-images/xenpolicy-uImage /tmp/sdk/$$/boot/"
+
+execute "cp -L $sdkdir/yocto-layers/build/arago-tmp-external-linaro-toolchain/deploy/images/dra7xx-evm/arago-glsdk-multimedia-image-dra7xx-evm.tar.gz $sdkdir/filesystem"
 
 if [ ! -f $sdkdir/filesystem/arago*sdk*multimedia*dra7*.tar.gz ]
 then
diff --git a/patch/meta-glsdk/0003-ti_glsdk-change-build-config-and-add-dom0-dtb-files.patch b/patch/meta-glsdk/0003-ti_glsdk-change-build-config-and-add-dom0-dtb-files.patch
new file mode 100644
index 0000000..b824ee3
--- /dev/null
+++ b/patch/meta-glsdk/0003-ti_glsdk-change-build-config-and-add-dom0-dtb-files.patch
@@ -0,0 +1,34 @@
+From 9ee2ce3da0dcf5264f7bccce93498a0d9e7f0577 Mon Sep 17 00:00:00 2001
+From: Oleksii Kurochko <oleksii.kurochko@globallogic.com>
+Date: Mon, 6 Jun 2016 15:49:50 +0300
+Subject: [PATCH] ti_glsdk: change build config and add dom0 dtb files
+
+---
+ recipes-kernel/linux/linux-ti-glsdk/defconfig |    2 +-
+ recipes-kernel/linux/linux-ti-glsdk_3.14.bb   |    3 ++-
+ 2 files changed, 3 insertions(+), 2 deletions(-)
+
+diff --git a/recipes-kernel/linux/linux-ti-glsdk/defconfig b/recipes-kernel/linux/linux-ti-glsdk/defconfig
+index 926b35a..539558b 100644
+--- a/recipes-kernel/linux/linux-ti-glsdk/defconfig
++++ b/recipes-kernel/linux/linux-ti-glsdk/defconfig
+@@ -1 +1 @@
+-use-kernel-config=omap2plus_defconfig
++use-kernel-config=omap2plus_dom0_defconfig
+diff --git a/recipes-kernel/linux/linux-ti-glsdk_3.14.bb b/recipes-kernel/linux/linux-ti-glsdk_3.14.bb
+index e3ed315..24089cc 100644
+--- a/recipes-kernel/linux/linux-ti-glsdk_3.14.bb
++++ b/recipes-kernel/linux/linux-ti-glsdk_3.14.bb
+@@ -30,7 +30,8 @@ KERNEL_DEVICETREE_ti43x = "am43x-epos-evm.dtb am437x-gp-evm.dtb am437x-sk-evm.dt
+ KERNEL_DEVICETREE_beaglebone = "am335x-bone.dtb am335x-boneblack.dtb"
+ KERNEL_DEVICETREE_omap5-evm = "omap5-uevm.dtb"
+ KERNEL_DEVICETREE_dra7xx = "dra7-evm.dtb  dra7-evm-lcd10.dtb  dra7-evm-lcd7.dtb  dra7-evm-lcd-osd.dtb  dra7-evm-vision.dtb \
+-                           dra72-evm.dtb dra72-evm-lcd10.dtb dra72-evm-lcd7.dtb dra72-evm-lcd-osd.dtb dra72-evm-vision.dtb"
++                           dra72-evm.dtb dra72-evm-lcd10.dtb dra72-evm-lcd7.dtb dra72-evm-lcd-osd.dtb dra72-evm-vision.dtb \
++			   dra7-evm-dom0-lcd7.dtb dra7-evm-dom0-lcd10.dtb"
+ KERNEL_DEVICETREE_am57xx-evm = "am57xx-beagle-x15.dtb"
+ KERNEL_DEVICETREE_omap3 = "omap3-beagle.dtb omap3-beagle-xm.dtb omap3-evm.dtb omap3-evm-37xx.dtb am3517-evm.dtb"
+ KERNEL_DEVICETREE_am3517-evm = "am3517-evm.dtb"
+-- 
+1.7.9.5
+
diff --git a/patch/meta-glsdk/0004-meta-glsdk-add-patches-for-u-boot.patch b/patch/meta-glsdk/0004-meta-glsdk-add-patches-for-u-boot.patch
new file mode 100644
index 0000000..4333363
--- /dev/null
+++ b/patch/meta-glsdk/0004-meta-glsdk-add-patches-for-u-boot.patch
@@ -0,0 +1,948 @@
+From d255ebdba90514f078e9224b02b3ee015a8b9cca Mon Sep 17 00:00:00 2001
+From: Oleksii Kurochko <oleksii.kurochko@globallogic.com>
+Date: Tue, 7 Jun 2016 16:03:06 +0300
+Subject: [PATCH 1/2] meta-glsdk: add patches for u-boot
+
+---
+ recipes-bsp/u-boot/u-boot-glsdk-staging_2014.07.bb |   14 +-
+ ...irt-dra7xx-Add-dra7xx_evm_nautilus-target.patch |  342 ++++++++++++++++++++
+ ...-virt-dra7xx-Enable-XEN-support-in-u-boot.patch |   30 ++
+ ...a7xx-Enable-MMC-boot-support-in-SPL-image.patch |   51 +++
+ ...04-omap5-dra7xx-Add-switching-to-HYP-mode.patch |  165 ++++++++++
+ ...0005-u-boot-fix-compile-issue-for-GCC-4.6.patch |   32 ++
+ ...-Enable-define-in-config-file-to-switch-i.patch |   27 ++
+ ..._nautilus-Do-not-enable-data-cache-in-U-B.patch |   31 ++
+ .../0008-crossbar-Port-crossbar-setup.patch        |  126 ++++++++
+ ...omap5_common-Don-t-relocate-FDT-in-U-Boot.patch |   29 ++
+ 10 files changed, 846 insertions(+), 1 deletion(-)
+ create mode 100644 recipes-bsp/u-boot/u-boot-patches/0001-virt-dra7xx-Add-dra7xx_evm_nautilus-target.patch
+ create mode 100644 recipes-bsp/u-boot/u-boot-patches/0002-virt-dra7xx-Enable-XEN-support-in-u-boot.patch
+ create mode 100644 recipes-bsp/u-boot/u-boot-patches/0003-virt-dra7xx-Enable-MMC-boot-support-in-SPL-image.patch
+ create mode 100644 recipes-bsp/u-boot/u-boot-patches/0004-omap5-dra7xx-Add-switching-to-HYP-mode.patch
+ create mode 100644 recipes-bsp/u-boot/u-boot-patches/0005-u-boot-fix-compile-issue-for-GCC-4.6.patch
+ create mode 100644 recipes-bsp/u-boot/u-boot-patches/0006-virt-dra7xx-Enable-define-in-config-file-to-switch-i.patch
+ create mode 100644 recipes-bsp/u-boot/u-boot-patches/0007-hack-dra7xx_nautilus-Do-not-enable-data-cache-in-U-B.patch
+ create mode 100644 recipes-bsp/u-boot/u-boot-patches/0008-crossbar-Port-crossbar-setup.patch
+ create mode 100644 recipes-bsp/u-boot/u-boot-patches/0009-ti_omap5_common-Don-t-relocate-FDT-in-U-Boot.patch
+
+diff --git a/recipes-bsp/u-boot/u-boot-glsdk-staging_2014.07.bb b/recipes-bsp/u-boot/u-boot-glsdk-staging_2014.07.bb
+index 3d130b3..15acf1c 100644
+--- a/recipes-bsp/u-boot/u-boot-glsdk-staging_2014.07.bb
++++ b/recipes-bsp/u-boot/u-boot-glsdk-staging_2014.07.bb
+@@ -1,5 +1,7 @@
+ require u-boot-ti.inc
+ 
++FILESEXTRAPATHS_prepend := "${THISDIR}/u-boot-patches:"
++
+ # u-boot needs devtree compiler to parse dts files
+ DEPENDS += "dtc-native"
+ 
+@@ -12,7 +14,17 @@ PR = "r8+gitr${SRCPV}"
+ BRANCH = "p-ti-u-boot-2014.07"
+ 
+ SRC_URI = "git://git.omapzoom.org/repo/u-boot.git;protocol=git;branch=${BRANCH}"
+-
++SRC_URI += " \
++	file://0001-virt-dra7xx-Add-dra7xx_evm_nautilus-target.patch \
++	file://0002-virt-dra7xx-Enable-XEN-support-in-u-boot.patch \
++	file://0003-virt-dra7xx-Enable-MMC-boot-support-in-SPL-image.patch \
++	file://0004-omap5-dra7xx-Add-switching-to-HYP-mode.patch \
++	file://0005-u-boot-fix-compile-issue-for-GCC-4.6.patch \
++	file://0006-virt-dra7xx-Enable-define-in-config-file-to-switch-i.patch \
++	file://0007-hack-dra7xx_nautilus-Do-not-enable-data-cache-in-U-B.patch \
++	file://0008-crossbar-Port-crossbar-setup.patch \
++	file://0009-ti_omap5_common-Don-t-relocate-FDT-in-U-Boot.patch \
++	"
+ SRCREV = "91dfce13d0b6fd7520db72ab774a13057dcc3244"
+ 
+ SPL_BINARY = "MLO"
+diff --git a/recipes-bsp/u-boot/u-boot-patches/0001-virt-dra7xx-Add-dra7xx_evm_nautilus-target.patch b/recipes-bsp/u-boot/u-boot-patches/0001-virt-dra7xx-Add-dra7xx_evm_nautilus-target.patch
+new file mode 100644
+index 0000000..bc83e18
+--- /dev/null
++++ b/recipes-bsp/u-boot/u-boot-patches/0001-virt-dra7xx-Add-dra7xx_evm_nautilus-target.patch
+@@ -0,0 +1,342 @@
++From a01ea864b4dc684328f388f6f923bda1c7a009d4 Mon Sep 17 00:00:00 2001
++From: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++Date: Wed, 10 Jun 2015 18:39:01 +0300
++Subject: [PATCH 1/9] virt-dra7xx: Add dra7xx_evm_nautilus target
++
++Add new u-boot target as copy of dra7xx_evm_android config,
++it will tuned & used with XEN solution on mentioned board
++
++Change-Id: I8c4de4aef5118681fd578c7979fc8933e069b879
++Signed-off-by: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++Signed-off-by: Oleksandr Tyshchenko <oleksandr.tyshchenko@globallogic.com>
++Signed-off-by: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++---
++ boards.cfg                            |    1 +
++ include/configs/dra7xx_evm_nautilus.h |  303 +++++++++++++++++++++++++++++++++
++ 2 files changed, 304 insertions(+)
++ create mode 100644 include/configs/dra7xx_evm_nautilus.h
++
++diff --git a/boards.cfg b/boards.cfg
++index b4c93df..fc1d80c 100644
++--- a/boards.cfg
+++++ b/boards.cfg
++@@ -377,6 +377,7 @@ Active  arm         armv7          omap5       ti              dra7xx
++ Active  arm         armv7          omap5       ti              dra7xx              dra7xx_evm_uart3                      dra7xx_evm:CONS_INDEX=3,SPL_YMODEM_SUPPORT,ENV_IS_IN_MMC                                                                          Lokesh Vutla <lokeshvutla@ti.com>
++ Active  arm         armv7          omap5       ti              dra7xx              dra7xx_evm_usbboot			  dra7xx_evm:CONS_INDEX=1,ENV_IS_IN_MMC,SPL_DFU                                                                                    Ravi Babu <ravibabu@ti.com>
++ Active  arm         armv7          omap5       ti              dra7xx              dra7xx_evm_android                    dra7xx_evm_android:CONS_INDEX=1,ENV_IS_IN_MMC                                                                                     -
+++Active  arm         armv7          omap5       ti              dra7xx              dra7xx_evm_nautilus                   dra7xx_evm_nautilus:CONS_INDEX=1,QSPI_BOOT                                                                                     -
++ Active  arm         armv7          omap5       ti              dra7xx              dra7xx_evm_android_perboot            dra7xx_evm_android:CONS_INDEX=1,ENV_IS_IN_MMC,PERIPHERAL_BOOT                                                -
++ Active  arm         armv7          omap5       ti              dra7xx              dra7xx_evm_vision                     dra7xx_evm_vision:CONS_INDEX=1,ENV_IS_IN_MMC                                                                                             Nikhil Devshatwar <nikhil.nd@ti.com>
++ Active  arm         armv7          omap5       ti              dra7xx              dra7xx_hs_evm_android                 dra7xx_evm_android:CONS_INDEX=1,ENV_IS_IN_MMC,OMAP_SECURE                                                                         -
++diff --git a/include/configs/dra7xx_evm_nautilus.h b/include/configs/dra7xx_evm_nautilus.h
++new file mode 100644
++index 0000000..da261a6
++--- /dev/null
+++++ b/include/configs/dra7xx_evm_nautilus.h
++@@ -0,0 +1,303 @@
+++/*
+++ * (C) Copyright 2013
+++ * Texas Instruments Incorporated.
+++ * Lokesh Vutla	  <lokeshvutla@ti.com>
+++ *
+++ * Configuration settings for the TI DRA7XX board.
+++ * See ti_omap5_common.h for omap5 common settings.
+++ *
+++ * SPDX-License-Identifier:	GPL-2.0+
+++ */
+++
+++#ifndef __CONFIG_DRA7XX_EVM_NAUTILUS_H
+++#define __CONFIG_DRA7XX_EVM_NAUTILUS_H
+++
+++#define CONFIG_DRA7XX
+++#define CONFIG_BOARD_EARLY_INIT_F
+++
+++#ifdef CONFIG_SPL_BUILD
+++#define CONFIG_IODELAY_RECALIBRATION
+++#endif
+++
+++#define CONFIG_VERY_BIG_RAM
+++#define CONFIG_PHYS_64BIT
+++#define CONFIG_NR_DRAM_BANKS		2
+++#define CONFIG_MAX_MEM_MAPPED		0x80000000
+++
+++/* MMC ENV related defines */
+++#ifdef CONFIG_ENV_IS_IN_MMC
+++#define CONFIG_SYS_MMC_ENV_DEV		1	/* SLOT2: eMMC(1) */
+++#define CONFIG_ENV_SIZE			(128 << 10)
+++#define CONFIG_ENV_OFFSET		0xE0000
+++#define CONFIG_ENV_OFFSET_REDUND	(CONFIG_ENV_OFFSET + CONFIG_ENV_SIZE)
+++#define CONFIG_SYS_REDUNDAND_ENVIRONMENT
+++#endif
+++#define CONFIG_CMD_SAVEENV
+++
+++#if (CONFIG_CONS_INDEX == 1)
+++#define CONSOLEDEV			"ttyO0"
+++#elif (CONFIG_CONS_INDEX == 3)
+++#define CONSOLEDEV			"ttyO2"
+++#endif
+++#define CONFIG_SYS_NS16550_COM1		UART1_BASE	/* Base EVM has UART0 */
+++#define CONFIG_SYS_NS16550_COM2		UART2_BASE	/* UART2 */
+++#define CONFIG_SYS_NS16550_COM3		UART3_BASE	/* UART3 */
+++#define CONFIG_BAUDRATE			115200
+++
+++#define CONFIG_SYS_OMAP_ABE_SYSCK
+++
+++/* Define the default GPT table for eMMC */
+++#define PARTS_DEFAULT \
+++	"uuid_disk=${uuid_gpt_disk};" \
+++	"name=rootfs,start=2MiB,size=-,uuid=${uuid_gpt_rootfs}"
+++
+++/* Fastboot */
+++#define CONFIG_CMD_FASTBOOT
+++#define CONFIG_ANDROID_BOOT_IMAGE
+++#define CONFIG_USB_FASTBOOT_BUF_ADDR    CONFIG_SYS_LOAD_ADDR
+++#define CONFIG_USB_FASTBOOT_BUF_SIZE    0x2F000000
+++#define CONFIG_FASTBOOT_FLASH
+++#ifndef CONFIG_SPL_BUILD
+++#define CONFIG_FASTBOOT_FLASH_MMC_DEV   1
+++#endif
+++
+++#include <configs/ti_omap5_common.h>
+++
+++/* Enhance our eMMC support / experience. */
+++#define CONFIG_CMD_GPT
+++#define CONFIG_EFI_PARTITION
+++#define CONFIG_PARTITION_UUIDS
+++#define CONFIG_CMD_PART
+++#define CONFIG_HSMMC2_8BIT
+++#define CONFIG_HSMMC3_8BIT
+++#define CONFIG_OMAP_MMC1_HS_52
+++#define CONFIG_OMAP_MMC2_DDR_52
+++
+++/* CPSW Ethernet */
+++#define CONFIG_CMD_NET			/* 'bootp' and 'tftp' */
+++#define CONFIG_CMD_DHCP
+++#define CONFIG_BOOTP_DNS		/* Configurable parts of CMD_DHCP */
+++#define CONFIG_BOOTP_DNS2
+++#define CONFIG_BOOTP_SEND_HOSTNAME
+++#define CONFIG_BOOTP_GATEWAY
+++#define CONFIG_BOOTP_SUBNETMASK
+++#define CONFIG_NET_RETRY_COUNT		10
+++#define CONFIG_CMD_PING
+++#define CONFIG_CMD_MII
+++#define CONFIG_DRIVER_TI_CPSW		/* Driver for IP block */
+++#define CONFIG_MII			/* Required in net/eth.c */
+++#define CONFIG_PHY_GIGE			/* per-board part of CPSW */
+++#define CONFIG_PHYLIB
+++
+++/* SPI */
+++#undef	CONFIG_OMAP3_SPI
+++#define CONFIG_TI_QSPI
+++#define CONFIG_SPI_FLASH
+++#define CONFIG_SPI_FLASH_SPANSION
+++#define CONFIG_CMD_SF
+++#define CONFIG_CMD_SPI
+++#define CONFIG_SPI_FLASH_BAR
+++#define CONFIG_TI_SPI_MMAP
+++#define CONFIG_SF_DEFAULT_SPEED                64000000
+++#define CONFIG_DEFAULT_SPI_MODE                SPI_MODE_0
+++
+++/*
+++ * Default to using SPI for environment, etc.
+++ * 0x000000 - 0x010000 : QSPI.SPL (64KiB)
+++ * 0x010000 - 0x020000 : QSPI.SPL.backup1 (64KiB)
+++ * 0x020000 - 0x030000 : QSPI.SPL.backup2 (64KiB)
+++ * 0x030000 - 0x040000 : QSPI.SPL.backup3 (64KiB)
+++ * 0x040000 - 0x140000 : QSPI.u-boot (1MiB)
+++ * 0x140000 - 0x1C0000 : QSPI.u-boot-spl-os (512KiB)
+++ * 0x1C0000 - 0x1D0000 : QSPI.u-boot-env (64KiB)
+++ * 0x1D0000 - 0x1E0000 : QSPI.u-boot-env.backup1 (64KiB)
+++ * 0x1E0000 - 0x9E0000 : QSPI.kernel (8MiB)
+++ * 0x9E0000 - 0x2000000 : USERLAND
+++ */
+++#define CONFIG_SYS_SPI_KERNEL_OFFS	0x1E0000
+++#define CONFIG_SYS_SPI_ARGS_OFFS	0x140000
+++#define CONFIG_SYS_SPI_ARGS_SIZE	0x80000
+++#if defined(CONFIG_QSPI_BOOT)
+++/* In SPL, use the environment and discard MMC support for space. */
+++#ifdef CONFIG_SPL_BUILD
+++#undef CONFIG_SPL_MMC_SUPPORT
+++#undef CONFIG_SPL_MAX_SIZE
+++#define CONFIG_SPL_MAX_SIZE             (64 << 10) /* 64 KiB */
+++#endif
+++#define CONFIG_SPL_ENV_SUPPORT
+++#define CONFIG_ENV_IS_IN_SPI_FLASH
+++#define CONFIG_SYS_REDUNDAND_ENVIRONMENT
+++#define CONFIG_ENV_SPI_MAX_HZ           CONFIG_SF_DEFAULT_SPEED
+++#define CONFIG_ENV_SIZE			(64 << 10)
+++#define CONFIG_ENV_SECT_SIZE		(64 << 10) /* 64 KB sectors */
+++#define CONFIG_ENV_OFFSET		0x1C0000
+++#define CONFIG_ENV_OFFSET_REDUND	0x1D0000
+++#endif
+++
+++/* SPI SPL */
+++#define CONFIG_SPL_SPI_SUPPORT
+++#define CONFIG_SPL_DMA_SUPPORT
+++#define CONFIG_TI_EDMA
+++#define CONFIG_SPL_SPI_LOAD
+++#define CONFIG_SPL_SPI_FLASH_SUPPORT
+++#define CONFIG_SPL_SPI_BUS             0
+++#define CONFIG_SPL_SPI_CS              0
+++#define CONFIG_SYS_SPI_U_BOOT_OFFS     0x80000
+++
+++#define CONFIG_SUPPORT_EMMC_BOOT
+++
+++/* USB xHCI HOST */
+++#define CONFIG_CMD_USB
+++#define CONFIG_USB_HOST
+++#define CONFIG_USB_XHCI
+++#define CONFIG_USB_XHCI_OMAP
+++#define CONFIG_USB_STORAGE
+++#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS 2
+++
+++#define CONFIG_OMAP_USB_PHY
+++#define CONFIG_OMAP_USB2PHY2_HOST
+++
+++/* USB GADGET */
+++#ifdef CONFIG_G_DNL_VENDOR_NUM
+++#undef CONFIG_G_DNL_VENDOR_NUM
+++#define CONFIG_G_DNL_VENDOR_NUM 0x0451
+++#endif
+++
+++#ifdef CONFIG_G_DNL_PRODUCT_NUM
+++#undef CONFIG_G_DNL_PRODUCT_NUM
+++#define CONFIG_G_DNL_PRODUCT_NUM 0xd022
+++#endif
+++
+++#ifndef CONFIG_SPL_BUILD
+++/* SATA */
+++#define CONFIG_BOARD_LATE_INIT
+++#define CONFIG_CMD_SCSI
+++#define CONFIG_LIBATA
+++#define CONFIG_SCSI_AHCI
+++#define CONFIG_SCSI_AHCI_PLAT
+++#define CONFIG_SYS_SCSI_MAX_SCSI_ID	1
+++#define CONFIG_SYS_SCSI_MAX_LUN		1
+++#define CONFIG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
+++						CONFIG_SYS_SCSI_MAX_LUN)
+++#else
+++/* For Android SPL builds, we don't use DFU */
+++#undef CONFIG_DFU_FUNCTION
+++#undef CONFIG_DFU_RAM
+++#undef CONFIG_CMD_DFU
+++#undef CONFIG_DFU_MMC
+++#undef CONFIG_DFU_RAM
+++/* We also don't use fastboot unless doing SPL peripheral boot */
+++#ifndef CONFIG_PERIPHERAL_BOOT
+++#undef CONFIG_CMD_FASTBOOT
+++#endif
+++#endif
+++
+++/* Parallel NOR Support */
+++#if defined(CONFIG_NOR)
+++/* NOR: device related configs */
+++#define CONFIG_SYS_MAX_FLASH_SECT	512
+++#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+++#define CONFIG_SYS_FLASH_SIZE		(64 * 1024 * 1024) /* 64 MB */
+++/* #define CONFIG_INIT_IGNORE_ERROR */
+++#undef CONFIG_SYS_NO_FLASH
+++#define CONFIG_CMD_FLASH
+++#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+++#define CONFIG_SYS_FLASH_PROTECTION
+++#define CONFIG_SYS_FLASH_CFI
+++#define CONFIG_FLASH_CFI_DRIVER
+++#define CONFIG_FLASH_CFI_MTD
+++#define CONFIG_SYS_MAX_FLASH_BANKS	1
+++#define CONFIG_SYS_FLASH_BASE		(0x08000000)
+++#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+++/* Reduce SPL size by removing unlikey targets */
+++#ifdef CONFIG_NOR_BOOT
+++#define CONFIG_ENV_IS_IN_FLASH
+++#define CONFIG_ENV_SECT_SIZE		(128 * 1024)	/* 128 KiB */
+++#define MTDIDS_DEFAULT			"nor0=physmap-flash.0"
+++#define MTDPARTS_DEFAULT		"mtdparts=physmap-flash.0:" \
+++					"1m(NOR.u-boot)," \
+++					"128k(NOR.u-boot-env)," \
+++					"128k(NOR.u-boot-env.backup1)," \
+++					"256k(NOR.u-boot-spl-os)," \
+++					"8m(NOR.kernel)," \
+++					"-(NOR.rootfs)"
+++#define CONFIG_ENV_OFFSET		0x00100000
+++#define CONFIG_ENV_OFFSET_REDUND	0x00120000
+++#endif
+++#endif  /* NOR support */
+++
+++#define DRA7XX_PUBLIC_SAR_RAM_1_FREE           (0x4AE26000 + 0xFE0)
+++#define DRA7XX_PRM_RSTCTRL_RESET_WARM_BIT      (1<<0)
+++#define DRA7XX_PRM_RSTST_RESET_WARM_BIT        (1<<1)
+++#define DRA7XX_PRM_RSTST                       0x4AE07D04
+++#define DRA7XX_PRM_RSTCTRL                     0x4AE07D00
+++#define DRA7XX_PRM_RSTST_CLR                   0xfff
+++#define DRA7XX_REBOOT_REASON_SIZE              0xf
+++
+++#define CONFIG_BOARD_MACH_TYPE                  4070
+++#define MEMORY_BASE                             0x80000000
+++#define CONFIG_ADDR_ATAGS                       (MEMORY_BASE + 0x100)
+++#define CONFIG_ADDR_DOWNLOAD                    (MEMORY_BASE + 0x02100000)
+++#define DEVICE_TREE                             0x82f80000
+++#undef CONFIG_SYS_SPL_ARGS_ADDR
+++#define CONFIG_SYS_SPL_ARGS_ADDR                0x82f80000
+++
+++#undef CONFIG_BOOTDELAY
+++#define CONFIG_BOOTDELAY			3
+++
+++/* Enforce secure boot for high secure devices */
+++#ifdef CONFIG_OMAP_SECURE
+++#define CONFIG_SECURE_BOOT
+++#define CONFIG_SECURE_FW_MEMORY_SIZE            0x00680000
+++#define CONFIG_SECURE_NOFW_MEMORY_SIZE          0x00180000
+++/* Set aside protected RAM region - size in KB */
+++#define CONFIG_PRAM                            (CONFIG_SECURE_FW_MEMORY_SIZE + \
+++                                                CONFIG_SECURE_NOFW_MEMORY_SIZE) >> 10
+++#endif
+++
+++/* pcf support */
+++#define CONFIG_PCF8575
+++#define CONFIG_SYS_I2C_PCF8575_CHIP { {0x21, 0xeaf7} }
+++
+++#ifdef CONFIG_SPL_BUILD
+++#define CONFIG_SPL_ENV_SUPPORT
+++#endif
+++
+++/* JAMR3 board pin mux */
+++#define CONFIG_DRA7XX_JAMR3
+++
+++/*
+++ * Enable this flag if you want to boot remotecores
+++ * from SPL. The specific cores loaded is controlled
+++ * by the array cores_to_boot[] in spl.c:board_init_r()
+++ */
+++#undef CONFIG_LATE_ATTACH
+++
+++#ifdef CONFIG_LATE_ATTACH
+++
+++/* Enable this flag to use a DMA pool with late attach instead of a CMA pool */
+++#undef CONFIG_LATE_ATTACH_DMA_POOL
+++
+++/* Include ELF loader for parsing remotecore binaries */
+++#define CONFIG_CMD_ELF
+++#endif
+++
+++#define CONFIG_MMC_IPU1_PART_NAME		"ipu1"
+++#define CONFIG_MMC_IPU2_PART_NAME		"ipu2"
+++
+++/* Define the address to which the IPU binary is
+++ * loaded from persistent storage
+++ */
+++#define IPU_LOAD_ADDR		0xa0fff000
+++/* Using the same load address for the DSP binary as well as the IPU binary.
+++ * This is not an issue as we are performing the loads in serial.
+++ */
+++#define DSP_LOAD_ADDR		(IPU_LOAD_ADDR)
+++
+++/* enable board detect */
+++#define CONFIG_CREATE_BOARD_SYMLINK
+++/* EEPROM */
+++#define CONFIG_EEPROM_CHIP_ADDRESS 0x50
+++#define CONFIG_EEPROM_BUS_ADDRESS 0
+++
+++#endif /* __CONFIG_DRA7XX_EVM_NAUTILUS_H */
++-- 
++1.7.9.5
++
+diff --git a/recipes-bsp/u-boot/u-boot-patches/0002-virt-dra7xx-Enable-XEN-support-in-u-boot.patch b/recipes-bsp/u-boot/u-boot-patches/0002-virt-dra7xx-Enable-XEN-support-in-u-boot.patch
+new file mode 100644
+index 0000000..48553f2
+--- /dev/null
++++ b/recipes-bsp/u-boot/u-boot-patches/0002-virt-dra7xx-Enable-XEN-support-in-u-boot.patch
+@@ -0,0 +1,30 @@
++From c9947d3a28cb2cea02b0b4b2669cefaf94f9693a Mon Sep 17 00:00:00 2001
++From: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++Date: Wed, 10 Jun 2015 17:16:37 +0300
++Subject: [PATCH 2/9] virt-dra7xx: Enable XEN support in u-boot
++
++This define enables support required to boot into
++XEN virtualized environment.
++
++Change-Id: I6369f8764ef5c1101568a69bc47fa7ac3f8d4626
++Signed-off-by: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++---
++ include/configs/dra7xx_evm_nautilus.h |    2 ++
++ 1 file changed, 2 insertions(+)
++
++diff --git a/include/configs/dra7xx_evm_nautilus.h b/include/configs/dra7xx_evm_nautilus.h
++index da261a6..46af0c1 100644
++--- a/include/configs/dra7xx_evm_nautilus.h
+++++ b/include/configs/dra7xx_evm_nautilus.h
++@@ -15,6 +15,8 @@
++ #define CONFIG_DRA7XX
++ #define CONFIG_BOARD_EARLY_INIT_F
++ 
+++#define CONFIG_XEN
+++
++ #ifdef CONFIG_SPL_BUILD
++ #define CONFIG_IODELAY_RECALIBRATION
++ #endif
++-- 
++1.7.9.5
++
+diff --git a/recipes-bsp/u-boot/u-boot-patches/0003-virt-dra7xx-Enable-MMC-boot-support-in-SPL-image.patch b/recipes-bsp/u-boot/u-boot-patches/0003-virt-dra7xx-Enable-MMC-boot-support-in-SPL-image.patch
+new file mode 100644
+index 0000000..99c7404
+--- /dev/null
++++ b/recipes-bsp/u-boot/u-boot-patches/0003-virt-dra7xx-Enable-MMC-boot-support-in-SPL-image.patch
+@@ -0,0 +1,51 @@
++From 3c21aa41f7775ee5d510537f72d1d8fbe17f57ee Mon Sep 17 00:00:00 2001
++From: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++Date: Tue, 7 Jul 2015 15:28:28 +0300
++Subject: [PATCH 3/9] virt-dra7xx: Enable MMC boot support in SPL image
++
++This support required for correct first time loading or
++recovery boot from MMC card. This change requires additional space, so
++max spl size define increased to max allowed in L3 OCM RAM for
++DRA74x board. For more details, please see section 32.3.2.2 of
++TRM.
++
++Change-Id: If59968caa91302635a214b97cad0e8ef00444839
++Signed-off-by: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++---
++ common/cmd_bootm.c                    |    4 ++++
++ include/configs/dra7xx_evm_nautilus.h |    3 +--
++ 2 files changed, 5 insertions(+), 2 deletions(-)
++
++diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
++index 8d9dc84..b93980c 100644
++--- a/common/cmd_bootm.c
+++++ b/common/cmd_bootm.c
++@@ -27,6 +27,10 @@
++ #include <device_tree.h>
++ #endif
++ 
+++#if defined(CONFIG_DRA7XX) && defined(CONFIG_XEN)
+++#include <mmc.h>
+++#endif
+++
++ DECLARE_GLOBAL_DATA_PTR;
++ 
++ #if defined(CONFIG_CMD_FASTBOOT)
++diff --git a/include/configs/dra7xx_evm_nautilus.h b/include/configs/dra7xx_evm_nautilus.h
++index 46af0c1..ee520e6 100644
++--- a/include/configs/dra7xx_evm_nautilus.h
+++++ b/include/configs/dra7xx_evm_nautilus.h
++@@ -122,9 +122,8 @@
++ #if defined(CONFIG_QSPI_BOOT)
++ /* In SPL, use the environment and discard MMC support for space. */
++ #ifdef CONFIG_SPL_BUILD
++-#undef CONFIG_SPL_MMC_SUPPORT
++ #undef CONFIG_SPL_MAX_SIZE
++-#define CONFIG_SPL_MAX_SIZE             (64 << 10) /* 64 KiB */
+++#define CONFIG_SPL_MAX_SIZE             (504 << 10) /* 504 KiB */
++ #endif
++ #define CONFIG_SPL_ENV_SUPPORT
++ #define CONFIG_ENV_IS_IN_SPI_FLASH
++-- 
++1.7.9.5
++
+diff --git a/recipes-bsp/u-boot/u-boot-patches/0004-omap5-dra7xx-Add-switching-to-HYP-mode.patch b/recipes-bsp/u-boot/u-boot-patches/0004-omap5-dra7xx-Add-switching-to-HYP-mode.patch
+new file mode 100644
+index 0000000..dc8ed8c
+--- /dev/null
++++ b/recipes-bsp/u-boot/u-boot-patches/0004-omap5-dra7xx-Add-switching-to-HYP-mode.patch
+@@ -0,0 +1,165 @@
++From 2b876671ad0fd7ea6d9811340fbc9af0d9b15a09 Mon Sep 17 00:00:00 2001
++From: Andrii Anisov <andrii.anisov@globallogic.com>
++Date: Thu, 27 Feb 2014 13:31:51 +0200
++Subject: [PATCH 4/9] omap5:dra7xx: Add switching to HYP mode.
++
++XEN community mention that the switching to HYP mode should be done
++by bootloader before jumping to XEN. The  main reason is to get rid of
++platform dependent code from XEN.
++In this patch a code to switch to HYP mode OMAP5-like processors is
++added.
++
++Change-Id: Ia9a32c9724d993cf4e9466298513490c886fec6e
++Signed-off-by: Andrii Anisov <andrii.anisov@globallogic.com>
++---
++ arch/arm/cpu/armv7/omap5/Makefile |    1 +
++ arch/arm/cpu/armv7/omap5/hyp.c    |   75 +++++++++++++++++++++++++++++++++++++
++ arch/arm/lib/bootm.c              |    8 ++++
++ common/spl/spl.c                  |    7 ++++
++ 4 files changed, 91 insertions(+)
++ create mode 100644 arch/arm/cpu/armv7/omap5/hyp.c
++
++diff --git a/arch/arm/cpu/armv7/omap5/Makefile b/arch/arm/cpu/armv7/omap5/Makefile
++index ad08993..c3c8584 100644
++--- a/arch/arm/cpu/armv7/omap5/Makefile
+++++ b/arch/arm/cpu/armv7/omap5/Makefile
++@@ -13,3 +13,4 @@ obj-y	+= hw_data.o
++ obj-y	+= abb.o
++ obj-y	+= lowlevel_init.o
++ obj-$(CONFIG_IODELAY_RECALIBRATION) += dra7xx_iodelay.o
+++obj-$(CONFIG_XEN)	+= hyp.o
++diff --git a/arch/arm/cpu/armv7/omap5/hyp.c b/arch/arm/cpu/armv7/omap5/hyp.c
++new file mode 100644
++index 0000000..4049d36
++--- /dev/null
+++++ b/arch/arm/cpu/armv7/omap5/hyp.c
++@@ -0,0 +1,75 @@
+++
+++/* A small stack to allow us to safely call the OMAP5 monitor API, in order to
+++ * enable HYP mode. This must be accessible in HYP mode.
+++ */
+++unsigned int hyp_primary_stack[11];
+++
+++/*
+++ * function called by cpu 1 after wakeup
+++ */
+++void __hyp_init_sec(void);
+++
+++asm (
+++	".pushsection .text\n"
+++	".global __hyp_init_sec\n"
+++	"__hyp_init_sec:\n"
+++		"ldr r12, =0x102\n"
+++		"mov r0, pc\n"
+++		"smc 0x1\n"
+++		"ldr r1, =0x48281800\n" /* AUX_CORE_BOOT_0 */
+++		"mov r2, #0\n"
+++		"str r2, [r1]\n"	/* AUX_CORE_BOOT_0 */
+++		"str r2, [r1, #4]\n"	/* AUX_CORE_BOOT_1 */
+++		"isb\n"
+++		"dsb\n"
+++		"mov r3, #0xf0\n"
+++		"1: wfe\n"
+++		"ldr  r2, [r1]\n"	/* AUX_CORE_BOOT_0 */
+++		"ands r2, r2, r3\n"
+++		"beq  1b\n"
+++		"ldr  r2, [r1, #4]\n"	/* AUX_CORE_BOOT_1 */
+++		"cmp  r2, #0\n"
+++		"beq  1b\n"
+++		"bx   r2\n"
+++	".popsection\n"
+++);
+++
+++/*
+++ * Enable HYP mode on the OMAP5 CPU
+++ *
+++ * FIXME: this needs to test to make sure its running on an OMAP5
+++ *
+++ * We wake up CPU1 at __hyp_init_sec which allows us to put it into HYP
+++ * mode.
+++ *
+++ * CPU1 then clears AUX_CORE_BOOT_0 and enters WFE, until the kernel wakes it.
+++ *
+++ * In order to avoid CPU1 continuing execution on just about any event, we
+++ * wait for AUX_CORE_BOOT_0 to contain a non-zero address, at which point
+++ * we continue execution at that address.
+++ *
+++ */
+++
+++void omap5_switch_hyp(void) {
+++	 /*Wake up CPU1 and enable HYP on CPU0. */
+++	asm(
+++		"ldr r1, =0x48281800\n"     // AUX_CORE_BOOT_1
+++		"ldr r2, =__hyp_init_sec\n"
+++		"str r2, [r1, #4]\n"
+++		"mov r2, #0x20\n"
+++		"str r2, [r1]\n"            // AUX_CORE_BOOT_0
+++		"isb\n"
+++		"dmb\n"
+++		"dsb\n"
+++		"sev\n"                     // Wake CPU1
+++		"ldr r1,=hyp_primary_stack\n"
+++		"ldr r12, =0x102\n"
+++		"mov r0, pc\n"
+++		"stm   r1, {r4-r14}\n"
+++		"smc 0x1\n"                 // CPU0 -> HYP mode
+++		"ldr r1,=hyp_primary_stack\n"
+++		"ldm   r1, {r4-r14}\n"
+++		:::"r0", "r1", "r2", "r3", "cc", "memory"
+++	);
+++};
+++
++diff --git a/arch/arm/lib/bootm.c b/arch/arm/lib/bootm.c
++index 47ee070..d1921c9 100644
++--- a/arch/arm/lib/bootm.c
+++++ b/arch/arm/lib/bootm.c
++@@ -28,6 +28,10 @@
++ 
++ DECLARE_GLOBAL_DATA_PTR;
++ 
+++#ifdef CONFIG_OMAP5_HYP
+++extern void omap5_switch_hyp(void);
+++#endif
+++
++ static struct tag *params;
++ 
++ static ulong get_sp(void)
++@@ -194,6 +198,10 @@ static void do_nonsec_virt_switch(void)
++ #else
++ 		debug("entered non-secure state\n");
++ #endif
+++#else
+++#if defined(CONFIG_OMAP5_HYP)
+++	omap5_switch_hyp();
+++#endif
++ #endif
++ 
++ #ifdef CONFIG_ARM64
++diff --git a/common/spl/spl.c b/common/spl/spl.c
++index 9af3287..ae2c58f 100644
++--- a/common/spl/spl.c
+++++ b/common/spl/spl.c
++@@ -33,6 +33,10 @@
++ 
++ DECLARE_GLOBAL_DATA_PTR;
++ 
+++#ifdef CONFIG_OMAP5_HYP
+++extern void omap5_switch_hyp(void);
+++#endif
+++
++ #ifndef CONFIG_SYS_UBOOT_START
++ #define CONFIG_SYS_UBOOT_START	CONFIG_SYS_TEXT_BASE
++ #endif
++@@ -395,6 +399,9 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
++ 	case IH_OS_LINUX:
++ 		debug("Jumping to Linux\n");
++ 		spl_board_prepare_for_linux();
+++#ifdef CONFIG_OMAP5_HYP
+++		omap5_switch_hyp();
+++#endif
++ 		jump_to_image_linux((void *)CONFIG_SYS_SPL_ARGS_ADDR);
++ #endif
++ 	default:
++-- 
++1.7.9.5
++
+diff --git a/recipes-bsp/u-boot/u-boot-patches/0005-u-boot-fix-compile-issue-for-GCC-4.6.patch b/recipes-bsp/u-boot/u-boot-patches/0005-u-boot-fix-compile-issue-for-GCC-4.6.patch
+new file mode 100644
+index 0000000..e72d865
+--- /dev/null
++++ b/recipes-bsp/u-boot/u-boot-patches/0005-u-boot-fix-compile-issue-for-GCC-4.6.patch
+@@ -0,0 +1,32 @@
++From ce2911509b30c5534ccb78bf0804d870be0dc673 Mon Sep 17 00:00:00 2001
++From: Oleksandr Baglei <oleksandr.baglei@globallogic.com>
++Date: Wed, 11 Feb 2015 19:53:02 +0200
++Subject: [PATCH 5/9] u-boot: fix compile issue for GCC >= 4.6
++
++Enable security extension for arch=ARMv7-A to understand 'smc'
++instruction. Let to compile u-boot with regular linaro gcc
++toolchain.
++
++Change-Id: I5bef76a61634c977a23f962e09508b3646f104fa
++Signed-off-by: Oleksandr Baglei <oleksandr.baglei@globallogic.com>
++---
++ arch/arm/cpu/armv7/omap5/hyp.c |    3 +++
++ 1 file changed, 3 insertions(+)
++
++diff --git a/arch/arm/cpu/armv7/omap5/hyp.c b/arch/arm/cpu/armv7/omap5/hyp.c
++index 4049d36..25c1d71 100644
++--- a/arch/arm/cpu/armv7/omap5/hyp.c
+++++ b/arch/arm/cpu/armv7/omap5/hyp.c
++@@ -12,6 +12,9 @@ void __hyp_init_sec(void);
++ asm (
++ 	".pushsection .text\n"
++ 	".global __hyp_init_sec\n"
+++#if __GNUC__ >= 4 && __GNUC_MINOR__ >= 6
+++	".arch_extension sec\n"
+++#endif
++ 	"__hyp_init_sec:\n"
++ 		"ldr r12, =0x102\n"
++ 		"mov r0, pc\n"
++-- 
++1.7.9.5
++
+diff --git a/recipes-bsp/u-boot/u-boot-patches/0006-virt-dra7xx-Enable-define-in-config-file-to-switch-i.patch b/recipes-bsp/u-boot/u-boot-patches/0006-virt-dra7xx-Enable-define-in-config-file-to-switch-i.patch
+new file mode 100644
+index 0000000..637313a
+--- /dev/null
++++ b/recipes-bsp/u-boot/u-boot-patches/0006-virt-dra7xx-Enable-define-in-config-file-to-switch-i.patch
+@@ -0,0 +1,27 @@
++From cc2566b3ca0081f8b37c49d18946a4e631197cb4 Mon Sep 17 00:00:00 2001
++From: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++Date: Fri, 12 Jun 2015 12:04:13 +0300
++Subject: [PATCH 6/9] virt-dra7xx: Enable define in config file to switch into
++ HYP mode
++
++Change-Id: I76a89011d282629f17d20a9da14e68b7c5086998
++Signed-off-by: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++---
++ include/configs/dra7xx_evm_nautilus.h |    1 +
++ 1 file changed, 1 insertion(+)
++
++diff --git a/include/configs/dra7xx_evm_nautilus.h b/include/configs/dra7xx_evm_nautilus.h
++index ee520e6..a3b4a67 100644
++--- a/include/configs/dra7xx_evm_nautilus.h
+++++ b/include/configs/dra7xx_evm_nautilus.h
++@@ -16,6 +16,7 @@
++ #define CONFIG_BOARD_EARLY_INIT_F
++ 
++ #define CONFIG_XEN
+++#define CONFIG_OMAP5_HYP
++ 
++ #ifdef CONFIG_SPL_BUILD
++ #define CONFIG_IODELAY_RECALIBRATION
++-- 
++1.7.9.5
++
+diff --git a/recipes-bsp/u-boot/u-boot-patches/0007-hack-dra7xx_nautilus-Do-not-enable-data-cache-in-U-B.patch b/recipes-bsp/u-boot/u-boot-patches/0007-hack-dra7xx_nautilus-Do-not-enable-data-cache-in-U-B.patch
+new file mode 100644
+index 0000000..5e051a7
+--- /dev/null
++++ b/recipes-bsp/u-boot/u-boot-patches/0007-hack-dra7xx_nautilus-Do-not-enable-data-cache-in-U-B.patch
+@@ -0,0 +1,31 @@
++From 832aaca8bfd3eece8632c72c31dad31b79cf5f41 Mon Sep 17 00:00:00 2001
++From: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++Date: Wed, 15 Jul 2015 19:46:25 +0300
++Subject: [PATCH 7/9] hack: dra7xx_nautilus: Do not enable data cache in
++ U-Boot
++
++This patch is required due to inefficient interworking during
++flashing sparsed fastboot images on SCSI device
++
++Change-Id: If1f674c3f3205fdc669109c3cf1e85a138a45889
++Signed-off-by: Iurii Mykhalskyi <iurii.mykhalskyi@globallogic.com>
++---
++ include/configs/dra7xx_evm_nautilus.h |    2 ++
++ 1 file changed, 2 insertions(+)
++
++diff --git a/include/configs/dra7xx_evm_nautilus.h b/include/configs/dra7xx_evm_nautilus.h
++index a3b4a67..74eae30 100644
++--- a/include/configs/dra7xx_evm_nautilus.h
+++++ b/include/configs/dra7xx_evm_nautilus.h
++@@ -27,6 +27,8 @@
++ #define CONFIG_NR_DRAM_BANKS		2
++ #define CONFIG_MAX_MEM_MAPPED		0x80000000
++ 
+++#define CONFIG_SYS_DCACHE_OFF
+++
++ /* MMC ENV related defines */
++ #ifdef CONFIG_ENV_IS_IN_MMC
++ #define CONFIG_SYS_MMC_ENV_DEV		1	/* SLOT2: eMMC(1) */
++-- 
++1.7.9.5
++
+diff --git a/recipes-bsp/u-boot/u-boot-patches/0008-crossbar-Port-crossbar-setup.patch b/recipes-bsp/u-boot/u-boot-patches/0008-crossbar-Port-crossbar-setup.patch
+new file mode 100644
+index 0000000..a4c8f08
+--- /dev/null
++++ b/recipes-bsp/u-boot/u-boot-patches/0008-crossbar-Port-crossbar-setup.patch
+@@ -0,0 +1,126 @@
++From 7db13f9a6fe2240d585a6756a7a4c27475dad585 Mon Sep 17 00:00:00 2001
++From: Andrii Anisov <andrii.anisov@globallogic.com>
++Date: Sat, 1 Aug 2015 18:16:09 +0300
++Subject: [PATCH 8/9] crossbar: Port crossbar setup.
++
++Since crossbar can not be setup in domD and XEN knows nothing
++about crossbar we have to take previous solution from the old
++u-boot.
++
++Change-Id: I7d3535bb9e87551557570093bd8b9b4a6f277e1d
++Signed-off-by: Andrii Anisov <andrii.anisov@globallogic.com>
++Signed-off-by: Oleksandr Baglei <oleksandr.baglei@globallogic.com>
++---
++ board/ti/dra7xx/evm.c |   82 +++++++++++++++++++++++++++++++++++++++++++++++++
++ 1 file changed, 82 insertions(+)
++
++diff --git a/board/ti/dra7xx/evm.c b/board/ti/dra7xx/evm.c
++index 407e2f7..34a26c6 100644
++--- a/board/ti/dra7xx/evm.c
+++++ b/board/ti/dra7xx/evm.c
++@@ -46,6 +46,40 @@
++ #include <cpsw.h>
++ #endif
++ 
+++#define CTRL_CORE_MPU_IRQ_159_REG			0x4a002b76
+++#define CTRL_CORE_MPU_IRQ_152_REG			0x4A002b68
+++#define CTRL_CORE_MPU_IRQ_153_REG			0x4A002b6A
+++#define CTRL_CORE_MPU_IRQ_158_REG			0x4a002b74
+++#define CTRL_CORE_MPU_IRQ_155_REG			0x4a002b6e
+++#define CTRL_CORE_MPU_IRQ_154_REG			0x4a002b6c
+++#define CTRL_CORE_MPU_IRQ_156_REG			0x4a002b70
+++#define CTRL_CORE_MPU_IRQ_157_REG			0x4a002b72
+++#define CTRL_CORE_MPU_IRQ_135_REG			0x4a002b46
+++#define CTRL_CORE_MPU_IRQ_136_REG			0x4a002b48
+++#define CTRL_CORE_MPU_IRQ_137_REG			0x4a002b4a
+++#define CTRL_CORE_MPU_IRQ_138_REG			0x4a002b4c
+++#define CTRL_CORE_MPU_IRQ_141_REG			0x4a002b52
+++#define CTRL_CORE_MPU_IRQ_142_REG			0x4a002b54
+++#define CTRL_CORE_MPU_IRQ_143_REG			0x4a002b56
+++#define CTRL_CORE_MPU_IRQ_144_REG			0x4a002b58
+++#define CTRL_CORE_MPU_IRQ_145_REG			0x4a002b5a
+++#define CTRL_CORE_MPU_IRQ_146_REG			0x4a002b5c
+++#define CTRL_CORE_MPU_IRQ_147_REG			0x4a002b5e
+++#define CTRL_CORE_MPU_IRQ_124_REG			0x4a002b34
+++#define CTRL_CORE_MPU_IRQ_50_REG			0x4a002aa0
+++#define CTRL_CORE_MPU_IRQ_51_REG			0x4a002aa2
+++#define CTRL_CORE_MPU_IRQ_52_REG			0x4a002aa4
+++#define CTRL_CORE_MPU_IRQ_53_REG			0x4a002aa6
+++#define CTRL_CORE_MPU_IRQ_81_REG			0X4a002ade
+++#define CTRL_CORE_MPU_IRQ_82_REG			0X4a002ae0
+++
+++#define CTRL_CORE_DMA_SYSTEM_DREQ_79_REG		0x4a002c16
+++#define CTRL_CORE_DMA_SYSTEM_DREQ_78_REG		0x4a002c14
+++#define CTRL_CORE_DMA_SYSTEM_DREQ_63_REG		0x4a002bf6
+++#define CTRL_CORE_DMA_SYSTEM_DREQ_62_REG		0x4a002bf4
+++#define CTRL_CORE_DMA_SYSTEM_DREQ_69_REG		0x4a002c02
+++#define CTRL_CORE_DMA_SYSTEM_DREQ_70_REG		0x4a002c04
+++
++ DECLARE_GLOBAL_DATA_PTR;
++ 
++ /* GPIO 7_11 */
++@@ -517,6 +551,53 @@ void set_muxconf_regs_essential(void)
++ 	do_set_mux32((*ctrl)->control_padconf_core_base,
++ 		     early_padconf, ARRAY_SIZE(early_padconf));
++ }
+++static void set_crossbar_mpu_irq(void)
+++{
+++	/* MPU_IRQ mapping to CROSSBAR_IRQ */
+++	writew(217, CTRL_CORE_MPU_IRQ_159_REG); /* RTC_IRQ */
+++	writew(392, CTRL_CORE_MPU_IRQ_153_REG); /* VIP_IRQ_2 */
+++	writew(351, CTRL_CORE_MPU_IRQ_152_REG); /* VIP_IRQ */
+++	writew(354, CTRL_CORE_MPU_IRQ_158_REG); /* VPE_IRQ */
+++	writew(150, CTRL_CORE_MPU_IRQ_155_REG); /* MCASP3_IRQ_AREVT */
+++	writew(151, CTRL_CORE_MPU_IRQ_154_REG); /* MCASP3_IRQ_AXEVT */
+++	writew(156, CTRL_CORE_MPU_IRQ_156_REG); /* MCASP6_IRQ_AREVT */
+++	writew(157, CTRL_CORE_MPU_IRQ_157_REG); /* MCASP6_IRQ_AXEVT */
+++	writew(158, CTRL_CORE_MPU_IRQ_146_REG); /* MCASP7_IRQ_AREVT */
+++	writew(159, CTRL_CORE_MPU_IRQ_147_REG); /* MCASP7_IRQ_AXEVT */
+++	writew(251, CTRL_CORE_MPU_IRQ_136_REG); /* MAILBOX5 */
+++	writew(253, CTRL_CORE_MPU_IRQ_135_REG); /* MAILBOX6 */
+++	writew(254, CTRL_CORE_MPU_IRQ_137_REG); /* MAILBOX6 */
+++	writew(255, CTRL_CORE_MPU_IRQ_141_REG); /* MAILBOX6 */
+++	writew(256, CTRL_CORE_MPU_IRQ_138_REG); /* MAILBOX6 */
+++	writew(396, CTRL_CORE_MPU_IRQ_142_REG); /* IPU2 MMU */
+++	writew(145, CTRL_CORE_MPU_IRQ_143_REG); /* DSP1 MMU1 */
+++	writew(146, CTRL_CORE_MPU_IRQ_144_REG); /* DSP2 MMU0 */
+++	writew(147, CTRL_CORE_MPU_IRQ_145_REG); /* DSP2 MMU1 */
+++	writew(343, CTRL_CORE_MPU_IRQ_124_REG); /* QSPI */
+++	writew(334, CTRL_CORE_MPU_IRQ_50_REG);  /* CPSW_RX_THRESH */
+++	writew(335, CTRL_CORE_MPU_IRQ_51_REG);  /* CPSW_RX */
+++	writew(336, CTRL_CORE_MPU_IRQ_52_REG);  /* CPSW_TX */
+++	writew(337, CTRL_CORE_MPU_IRQ_53_REG);  /* CPSW_MISC */
+++	writew(222, CTRL_CORE_MPU_IRQ_81_REG);  /* DCAN1_INT0 */
+++	writew(225, CTRL_CORE_MPU_IRQ_82_REG);  /* DCAN2_INT0 */
+++}
+++
+++static void set_crossbar_sdma_dreq(void)
+++{
+++	/* SDMA_DREQ mapping to CROSSBAR_IRQ */
+++	writew(132, CTRL_CORE_DMA_SYSTEM_DREQ_79_REG);  /* MCASP3_DREQ_RX */
+++	writew(133, CTRL_CORE_DMA_SYSTEM_DREQ_78_REG);  /* MCASP3_DREQ_TX */
+++	writew(138, CTRL_CORE_DMA_SYSTEM_DREQ_63_REG);  /* MCASP6_DREQ_RX */
+++	writew(139, CTRL_CORE_DMA_SYSTEM_DREQ_62_REG);  /* MCASP6_DREQ_TX */
+++	writew(140, CTRL_CORE_DMA_SYSTEM_DREQ_70_REG);  /* MCASP7_DREQ_RX */
+++	writew(141, CTRL_CORE_DMA_SYSTEM_DREQ_69_REG);  /* MCASP7_DREQ_TX */
+++}
+++
+++static void set_crossbar_regs(void)
+++{
+++	set_crossbar_mpu_irq();
+++	set_crossbar_sdma_dreq();
+++}
++ 
++ #ifdef CONFIG_IODELAY_RECALIBRATION
++ void recalibrate_iodelay(void)
++@@ -859,6 +940,7 @@ static inline void vtt_regulator_enable(void)
++ int board_early_init_f(void)
++ {
++ 	vtt_regulator_enable();
+++	set_crossbar_regs();
++ 	return 0;
++ }
++ #endif
++-- 
++1.7.9.5
++
+diff --git a/recipes-bsp/u-boot/u-boot-patches/0009-ti_omap5_common-Don-t-relocate-FDT-in-U-Boot.patch b/recipes-bsp/u-boot/u-boot-patches/0009-ti_omap5_common-Don-t-relocate-FDT-in-U-Boot.patch
+new file mode 100644
+index 0000000..419152c
+--- /dev/null
++++ b/recipes-bsp/u-boot/u-boot-patches/0009-ti_omap5_common-Don-t-relocate-FDT-in-U-Boot.patch
+@@ -0,0 +1,29 @@
++From 1f688fdf28294620df13cd85aad3097cb7722c6a Mon Sep 17 00:00:00 2001
++From: Oleksandr Tyshchenko <oleksandr.tyshchenko@globallogic.com>
++Date: Wed, 4 Nov 2015 20:53:56 +0200
++Subject: [PATCH 9/9] ti_omap5_common: Don't relocate FDT in U-Boot
++
++Add fdt_high variable and set it to value 0xFFFFFFFF
++in order to prevent copying FDT at all.
++
++Change-Id: Ie77899b929e48c93a91cb0dea230c950174f6629
++Signed-off-by: Oleksandr Tyshchenko <oleksandr.tyshchenko@globallogic.com>
++---
++ include/configs/ti_omap5_common.h |    1 +
++ 1 file changed, 1 insertion(+)
++
++diff --git a/include/configs/ti_omap5_common.h b/include/configs/ti_omap5_common.h
++index 69e7b80..b3bf1f5 100644
++--- a/include/configs/ti_omap5_common.h
+++++ b/include/configs/ti_omap5_common.h
++@@ -159,6 +159,7 @@
++ #define CONFIG_EXTRA_ENV_SETTINGS \
++ 	DEFAULT_LINUX_BOOT_ENV \
++ 	"console=" CONSOLEDEV ",115200n8\0" \
+++	"fdt_high=0xffffffff\0" \
++ 	"fdtfile=undefined\0" \
++ 	"bootpart=0:2\0" \
++ 	"bootdir=/boot\0" \
++-- 
++1.7.9.5
++
+-- 
+1.7.9.5
+
diff --git a/patch/meta-glsdk/0005-meta-glsdk-add-patches-for-kernel.patch b/patch/meta-glsdk/0005-meta-glsdk-add-patches-for-kernel.patch
new file mode 100644
index 0000000..185d52e
--- /dev/null
+++ b/patch/meta-glsdk/0005-meta-glsdk-add-patches-for-kernel.patch
@@ -0,0 +1,9889 @@
+From 07eeed436eb28a737f89f1a3f232c648d035aad0 Mon Sep 17 00:00:00 2001
+From: Oleksii Kurochko <oleksii.kurochko@globallogic.com>
+Date: Wed, 8 Jun 2016 10:30:53 +0300
+Subject: [PATCH 2/2] meta-glsdk: add patches for kernel
+
+---
+ ...om0_defconfig-introduce-defconfig-for-dom.patch |  454 ++
+ ...om0_defconfig-switch-to-the-dom0-defconfi.patch |  126 +
+ ...DRA7xx-introduce-device-tree-for-domain-0.patch | 1536 +++++
+ ...x-dom0-dts-switch-to-the-dom0-device-tree.patch |  756 +++
+ ...akeupgen-doesn-t-enable-ES2-PM-mode-under.patch |   42 +
+ ...n-disabling-CNTFRQ-register-configuration.patch |   32 +
+ .../0007-dra7-dom0-introduce-hardware-data.patch   | 6586 ++++++++++++++++++++
+ .../0008-dra7-dom0-remove-unused-hw-data.patch     |   77 +
+ ...-dts-configure-rambase_pfn-and-align-ram-.patch |   48 +
+ ...0010-dra7-evm-dom0.dts-enable-gpu-in-dom0.patch |   78 +
+ ...-dra7-evm-dom0.dts-change-rootfs-location.patch |   25 +
+ recipes-kernel/linux/linux-ti-glsdk_3.14.bb        |   14 +
+ 12 files changed, 9774 insertions(+)
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0001-omap2plus_dom0_defconfig-introduce-defconfig-for-dom.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0002-omap2plus_dom0_defconfig-switch-to-the-dom0-defconfi.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0003-ARM-dts-DRA7xx-introduce-device-tree-for-domain-0.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0004-dra7xx-dom0-dts-switch-to-the-dom0-device-tree.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0005-ARM-OMAP2-Wakeupgen-doesn-t-enable-ES2-PM-mode-under.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0006-xen-disabling-CNTFRQ-register-configuration.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0007-dra7-dom0-introduce-hardware-data.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0008-dra7-dom0-remove-unused-hw-data.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0009-dra7xx-dom0-dts-configure-rambase_pfn-and-align-ram-.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0010-dra7-evm-dom0.dts-enable-gpu-in-dom0.patch
+ create mode 100644 recipes-kernel/linux/linux-kernel-patches/0011-dra7-evm-dom0.dts-change-rootfs-location.patch
+
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0001-omap2plus_dom0_defconfig-introduce-defconfig-for-dom.patch b/recipes-kernel/linux/linux-kernel-patches/0001-omap2plus_dom0_defconfig-introduce-defconfig-for-dom.patch
+new file mode 100644
+index 0000000..a57b3ca
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0001-omap2plus_dom0_defconfig-introduce-defconfig-for-dom.patch
+@@ -0,0 +1,454 @@
++From 4f94ba8098f9f7d3f73829c8e06847f4da0a0545 Mon Sep 17 00:00:00 2001
++From: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Date: Fri, 30 Oct 2015 11:31:06 +0200
++Subject: [PATCH] omap2plus_dom0_defconfig: introduce defconfig for dom0
++
++Introduced file is a copy of the original file.
++
++Change-Id: Ia2375ff1406c594544a4abad1efd52f913f278be
++Signed-off-by: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Signed-off-by: Oleksandr Baglei <oleksandr.baglei@globallogic.com>
++---
++ arch/arm/configs/omap2plus_dom0_defconfig | 430 ++++++++++++++++++++++++++++++
++ 1 file changed, 430 insertions(+)
++ create mode 100644 arch/arm/configs/omap2plus_dom0_defconfig
++
++diff --git a/arch/arm/configs/omap2plus_dom0_defconfig b/arch/arm/configs/omap2plus_dom0_defconfig
++new file mode 100644
++index 0000000..d41833e
++--- /dev/null
+++++ b/arch/arm/configs/omap2plus_dom0_defconfig
++@@ -0,0 +1,430 @@
+++CONFIG_SYSVIPC=y
+++CONFIG_POSIX_MQUEUE=y
+++CONFIG_FHANDLE=y
+++CONFIG_NO_HZ=y
+++CONFIG_HIGH_RES_TIMERS=y
+++CONFIG_BSD_PROCESS_ACCT=y
+++CONFIG_IKCONFIG=y
+++CONFIG_IKCONFIG_PROC=y
+++CONFIG_LOG_BUF_SHIFT=16
+++CONFIG_CGROUPS=y
+++CONFIG_BLK_DEV_INITRD=y
+++CONFIG_EXPERT=y
+++CONFIG_SLAB=y
+++CONFIG_PROFILING=y
+++CONFIG_OPROFILE=y
+++CONFIG_KPROBES=y
+++CONFIG_JUMP_LABEL=y
+++CONFIG_MODULES=y
+++CONFIG_MODULE_FORCE_LOAD=y
+++CONFIG_MODULE_UNLOAD=y
+++CONFIG_MODULE_FORCE_UNLOAD=y
+++CONFIG_MODVERSIONS=y
+++CONFIG_MODULE_SRCVERSION_ALL=y
+++# CONFIG_BLK_DEV_BSG is not set
+++CONFIG_PARTITION_ADVANCED=y
+++CONFIG_GPIO_PCA953X=y
+++CONFIG_OMAP_RESET_CLOCKS=y
+++CONFIG_OMAP_MUX_DEBUG=y
+++CONFIG_SOC_DRA7XX=y
+++CONFIG_ARM_THUMBEE=y
+++CONFIG_PCI=y
+++CONFIG_PCI_DRA7XX=y
+++CONFIG_SMP=y
+++CONFIG_NR_CPUS=2
+++CONFIG_PREEMPT=y
+++CONFIG_CMA=y
+++CONFIG_ZBOOT_ROM_TEXT=0x0
+++CONFIG_ZBOOT_ROM_BSS=0x0
+++CONFIG_ARM_APPENDED_DTB=y
+++CONFIG_ARM_ATAG_DTB_COMPAT=y
+++CONFIG_CMDLINE="elevator=noop console=ttyO0,115200n8 root=/dev/mmcblk1p2 rw rootwait fixrtc omapdrm.num_crtc=2 consoleblank=0 cma=64M rootfstype=ext4 uio_pdrv_genirq.of_id=generic-uio"
+++CONFIG_KEXEC=y
+++CONFIG_CPU_FREQ=y
+++CONFIG_CPU_FREQ_STAT_DETAILS=y
+++CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+++CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+++CONFIG_CPU_FREQ_GOV_USERSPACE=m
+++CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+++CONFIG_GENERIC_CPUFREQ_CPU0=y
+++# CONFIG_ARM_OMAP2PLUS_CPUFREQ is not set
+++CONFIG_CPU_IDLE=y
+++CONFIG_BINFMT_MISC=y
+++CONFIG_PM_DEBUG=y
+++CONFIG_NET=y
+++CONFIG_PACKET=y
+++CONFIG_UNIX=y
+++CONFIG_XFRM_USER=y
+++CONFIG_NET_KEY=y
+++CONFIG_NET_KEY_MIGRATE=y
+++CONFIG_INET=y
+++CONFIG_IP_MULTICAST=y
+++CONFIG_IP_PNP=y
+++CONFIG_IP_PNP_DHCP=y
+++CONFIG_IP_PNP_BOOTP=y
+++CONFIG_IP_PNP_RARP=y
+++# CONFIG_INET_LRO is not set
+++# CONFIG_IPV6 is not set
+++CONFIG_NETFILTER=y
+++CONFIG_NF_CONNTRACK=y
+++CONFIG_NF_CONNTRACK_IPV4=y
+++CONFIG_IP_NF_IPTABLES=y
+++CONFIG_IP_NF_FILTER=y
+++CONFIG_NF_NAT_IPV4=y
+++CONFIG_IP_NF_TARGET_MASQUERADE=y
+++CONFIG_BRIDGE=y
+++CONFIG_VLAN_8021Q=y
+++CONFIG_VLAN_8021Q_GVRP=y
+++CONFIG_CAN=y
+++CONFIG_CAN_C_CAN=y
+++CONFIG_CAN_C_CAN_PLATFORM=y
+++CONFIG_BT=m
+++CONFIG_BT_HCIUART=m
+++CONFIG_BT_HCIUART_H4=y
+++CONFIG_BT_HCIUART_BCSP=y
+++CONFIG_BT_HCIUART_LL=y
+++CONFIG_BT_HCIBCM203X=m
+++CONFIG_BT_HCIBPA10X=m
+++CONFIG_BT_WILINK=m
+++CONFIG_RFKILL=y
+++CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+++CONFIG_DEVTMPFS=y
+++CONFIG_DEVTMPFS_MOUNT=y
+++CONFIG_DMA_CMA=y
+++CONFIG_CMA_SIZE_MBYTES=24
+++CONFIG_OMAP_OCP2SCP=y
+++CONFIG_CONNECTOR=y
+++CONFIG_MTD=y
+++CONFIG_MTD_TESTS=m
+++CONFIG_MTD_CMDLINE_PARTS=y
+++CONFIG_MTD_BLOCK=y
+++CONFIG_MTD_OOPS=y
+++CONFIG_MTD_CFI=y
+++CONFIG_MTD_CFI_INTELEXT=y
+++CONFIG_MTD_M25P80=m
+++CONFIG_MTD_NAND=y
+++CONFIG_MTD_NAND_OMAP2=y
+++CONFIG_MTD_NAND_OMAP_BCH=y
+++CONFIG_MTD_ONENAND=y
+++CONFIG_MTD_ONENAND_VERIFY_WRITE=y
+++CONFIG_MTD_UBI=y
+++CONFIG_BLK_DEV_LOOP=y
+++CONFIG_BLK_DEV_RAM=y
+++CONFIG_BLK_DEV_RAM_SIZE=16384
+++CONFIG_SENSORS_TSL2550=m
+++CONFIG_BMP085_I2C=m
+++CONFIG_TI_ST=y
+++CONFIG_ST_HCI=y
+++CONFIG_SENSORS_LIS3_I2C=m
+++CONFIG_BLK_DEV_SD=y
+++CONFIG_CHR_DEV_ST=m
+++CONFIG_CHR_DEV_OSST=m
+++CONFIG_BLK_DEV_SR=y
+++CONFIG_CHR_DEV_SG=y
+++CONFIG_CHR_DEV_SCH=m
+++CONFIG_SCSI_MULTI_LUN=y
+++CONFIG_SCSI_CONSTANTS=y
+++CONFIG_SCSI_LOGGING=y
+++CONFIG_SCSI_SCAN_ASYNC=y
+++CONFIG_ATA=y
+++CONFIG_SATA_AHCI=m
+++CONFIG_SATA_AHCI_PLATFORM=y
+++CONFIG_MD=y
+++CONFIG_NETDEVICES=y
+++CONFIG_TIGON3=m
+++CONFIG_E1000=m
+++CONFIG_E1000E=m
+++CONFIG_SKGE=m
+++CONFIG_KS8851=y
+++CONFIG_KS8851_MLL=y
+++CONFIG_SMC91X=y
+++CONFIG_SMSC911X=y
+++CONFIG_TI_CPSW=y
+++CONFIG_TI_CPTS=y
+++CONFIG_AT803X_PHY=y
+++CONFIG_SMSC_PHY=y
+++CONFIG_USB_USBNET=y
+++CONFIG_USB_NET_SMSC95XX=y
+++CONFIG_USB_ALI_M5632=y
+++CONFIG_USB_AN2720=y
+++CONFIG_USB_EPSON2888=y
+++CONFIG_USB_KC2190=y
+++CONFIG_INPUT_JOYDEV=y
+++CONFIG_INPUT_EVDEV=y
+++CONFIG_KEYBOARD_GPIO=y
+++CONFIG_KEYBOARD_MATRIX=m
+++CONFIG_INPUT_TOUCHSCREEN=y
+++CONFIG_TOUCHSCREEN_ADS7846=y
+++CONFIG_TOUCHSCREEN_ATMEL_MXT=y
+++CONFIG_TOUCHSCREEN_EDT_FT5X06=y
+++CONFIG_TOUCHSCREEN_TI_AM335X_TSC=y
+++CONFIG_TOUCHSCREEN_PIXCIR=m
+++CONFIG_TOUCHSCREEN_LDC3001=y
+++CONFIG_INPUT_MISC=y
+++CONFIG_INPUT_PALMAS_PWRBUTTON=y
+++# CONFIG_LEGACY_PTYS is not set
+++CONFIG_SERIAL_8250=y
+++CONFIG_SERIAL_8250_CONSOLE=y
+++# CONFIG_SERIAL_8250_DMA is not set
+++CONFIG_SERIAL_8250_NR_UARTS=32
+++CONFIG_SERIAL_8250_RUNTIME_UARTS=10
+++CONFIG_SERIAL_8250_EXTENDED=y
+++CONFIG_SERIAL_8250_MANY_PORTS=y
+++CONFIG_SERIAL_8250_SHARE_IRQ=y
+++CONFIG_SERIAL_8250_DETECT_IRQ=y
+++CONFIG_SERIAL_8250_RSA=y
+++CONFIG_SERIAL_8250_OMAP=y
+++CONFIG_SERIAL_OF_PLATFORM=y
+++CONFIG_HW_RANDOM=y
+++CONFIG_I2C_CHARDEV=y
+++CONFIG_SPI=y
+++CONFIG_SPI_OMAP24XX=y
+++CONFIG_SPI_TI_QSPI=y
+++CONFIG_SPI_SPIDEV=y
+++CONFIG_PINCTRL_TI_IODELAY=y
+++CONFIG_PINCTRL_SINGLE=y
+++CONFIG_DEBUG_GPIO=y
+++CONFIG_GPIO_SYSFS=y
+++CONFIG_GPIO_PCF857X=y
+++CONFIG_GPIO_MCP23S08=y
+++CONFIG_GPIO_PALMAS=y
+++CONFIG_W1=y
+++CONFIG_POWER_SUPPLY=y
+++CONFIG_VOLTAGE_DOMAIN_OMAP=y
+++CONFIG_TI_COPROC=y
+++CONFIG_SENSORS_GPIO_FAN=y
+++CONFIG_SENSORS_LM75=m
+++CONFIG_SENSORS_TMP102=y
+++CONFIG_THERMAL=y
+++CONFIG_THERMAL_GOV_FAIR_SHARE=y
+++CONFIG_THERMAL_GOV_USER_SPACE=y
+++CONFIG_CPU_THERMAL=y
+++CONFIG_THERMAL_EMULATION=y
+++CONFIG_TI_SOC_THERMAL=y
+++CONFIG_TI_THERMAL=y
+++CONFIG_DRA752_THERMAL=y
+++CONFIG_WATCHDOG=y
+++CONFIG_OMAP_WATCHDOG=y
+++CONFIG_MFD_SYSCON=y
+++CONFIG_MFD_TI_AM335X_TSCADC=y
+++CONFIG_MFD_PALMAS=y
+++CONFIG_MFD_TPS65217=y
+++CONFIG_MFD_TPS65218=y
+++CONFIG_MFD_TPS65910=y
+++CONFIG_TWL6040_CORE=y
+++CONFIG_REGULATOR_FIXED_VOLTAGE=y
+++CONFIG_REGULATOR_GPIO=y
+++CONFIG_REGULATOR_PALMAS=y
+++CONFIG_REGULATOR_PBIAS=y
+++CONFIG_REGULATOR_TI_ABB=y
+++CONFIG_REGULATOR_TPS65023=y
+++CONFIG_REGULATOR_TPS6507X=y
+++CONFIG_REGULATOR_TPS65217=y
+++CONFIG_REGULATOR_TPS65218=y
+++CONFIG_REGULATOR_TPS65910=y
+++CONFIG_MEDIA_SUPPORT=y
+++CONFIG_MEDIA_CAMERA_SUPPORT=y
+++CONFIG_MEDIA_RADIO_SUPPORT=y
+++CONFIG_MEDIA_USB_SUPPORT=y
+++CONFIG_USB_VIDEO_CLASS=m
+++CONFIG_V4L_PLATFORM_DRIVERS=y
+++CONFIG_VIDEO_TI_VIP=y
+++CONFIG_VIDEO_TI_CAL=y
+++CONFIG_V4L_MEM2MEM_DRIVERS=y
+++CONFIG_VIDEO_TI_VPE=y
+++CONFIG_VIDEO_TI_VPDMA_LOAD_FW=y
+++# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+++CONFIG_VIDEO_TVP5158=y
+++CONFIG_VIDEO_OV2659=m
+++CONFIG_VIDEO_OV1063X=y
+++CONFIG_VIDEO_OV490=y
+++CONFIG_VIDEO_MT9T11X=m
+++CONFIG_DRM=y
+++CONFIG_DRM_I2C_NXP_TDA998X=y
+++CONFIG_DRM_OMAP=y
+++CONFIG_DRM_OMAP_NUM_CRTCS=2
+++CONFIG_DRM_TILCDC=y
+++CONFIG_FIRMWARE_EDID=y
+++CONFIG_FB_MODE_HELPERS=y
+++CONFIG_FB_TILEBLITTING=y
+++CONFIG_OMAP2_DSS=y
+++CONFIG_OMAP5_DSS_HDMI=y
+++CONFIG_OMAP2_DSS_SDI=y
+++CONFIG_OMAP2_DSS_DSI=y
+++CONFIG_DISPLAY_ENCODER_TFP410=m
+++CONFIG_DISPLAY_ENCODER_TPD12S015=y
+++CONFIG_DISPLAY_DRA7EVM_ENCODER_TPD12S015=y
+++CONFIG_DISPLAY_ENCODER_SII9022=y
+++CONFIG_DISPLAY_CONNECTOR_DVI=m
+++CONFIG_DISPLAY_CONNECTOR_HDMI=y
+++CONFIG_DISPLAY_PANEL_DPI=y
+++CONFIG_DISPLAY_PANEL_TLC59108=y
+++CONFIG_DISPLAY_PANEL_TC3587XXBG=y
+++CONFIG_BACKLIGHT_TLC59108=y
+++CONFIG_LCD_CLASS_DEVICE=y
+++CONFIG_LCD_PLATFORM=y
+++CONFIG_BACKLIGHT_PWM=y
+++CONFIG_BACKLIGHT_GPIO=y
+++CONFIG_VIDEO_TI_FPD3_SERDES=y
+++CONFIG_FRAMEBUFFER_CONSOLE=y
+++CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+++CONFIG_LOGO=y
+++CONFIG_SOUND=y
+++CONFIG_SND=y
+++CONFIG_SND_MIXER_OSS=m
+++CONFIG_SND_PCM_OSS=m
+++CONFIG_SND_VERBOSE_PRINTK=y
+++CONFIG_SND_DEBUG=y
+++CONFIG_SND_USB_AUDIO=m
+++CONFIG_SND_SOC=y
+++CONFIG_SND_EDMA_SOC=y
+++CONFIG_SND_OMAP_SOC_JAMR3=y
+++CONFIG_SND_OMAP_SOC_DRA7EVM=y
+++CONFIG_USB=y
+++CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+++CONFIG_USB_OTG=y
+++# CONFIG_USB_OTG_WHITELIST is not set
+++CONFIG_USB_MON=y
+++CONFIG_USB_XHCI_HCD=m
+++CONFIG_USB_EHCI_HCD=y
+++CONFIG_USB_ACM=m
+++CONFIG_USB_PRINTER=m
+++CONFIG_USB_WDM=y
+++CONFIG_USB_STORAGE=y
+++CONFIG_USB_MUSB_HDRC=m
+++CONFIG_USB_MUSB_OMAP2PLUS=m
+++CONFIG_USB_MUSB_DSPS=m
+++CONFIG_USB_TI_CPPI41_DMA=y
+++CONFIG_USB_DWC3=m
+++CONFIG_USB_SERIAL=m
+++CONFIG_USB_SERIAL_PL2303=m
+++CONFIG_USB_TEST=m
+++CONFIG_AM335X_PHY_USB=y
+++CONFIG_USB_GADGET=y
+++CONFIG_USB_GADGET_DEBUG=y
+++CONFIG_USB_GADGET_DEBUG_FILES=y
+++CONFIG_USB_GADGET_DEBUG_FS=y
+++CONFIG_USB_ZERO=m
+++CONFIG_USB_AUDIO=m
+++CONFIG_USB_ETH=m
+++CONFIG_USB_G_NCM=m
+++CONFIG_USB_GADGETFS=m
+++CONFIG_USB_FUNCTIONFS=m
+++CONFIG_USB_FUNCTIONFS_ETH=y
+++CONFIG_USB_FUNCTIONFS_RNDIS=y
+++CONFIG_USB_FUNCTIONFS_GENERIC=y
+++CONFIG_USB_MASS_STORAGE=m
+++CONFIG_USB_G_SERIAL=m
+++CONFIG_USB_MIDI_GADGET=m
+++CONFIG_USB_G_PRINTER=m
+++CONFIG_USB_CDC_COMPOSITE=m
+++CONFIG_USB_G_ACM_MS=m
+++CONFIG_USB_G_MULTI=m
+++CONFIG_USB_G_MULTI_CDC=y
+++CONFIG_USB_G_HID=m
+++CONFIG_USB_G_DBGP=m
+++CONFIG_USB_G_WEBCAM=m
+++CONFIG_MMC=y
+++CONFIG_MMC_UNSAFE_RESUME=y
+++CONFIG_SDIO_UART=y
+++CONFIG_MMC_OMAP=y
+++CONFIG_MMC_OMAP_HS=y
+++CONFIG_NEW_LEDS=y
+++CONFIG_LEDS_CLASS=y
+++CONFIG_LEDS_GPIO=y
+++CONFIG_LEDS_TRIGGERS=y
+++CONFIG_LEDS_TRIGGER_TIMER=y
+++CONFIG_LEDS_TRIGGER_ONESHOT=y
+++CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+++CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+++CONFIG_LEDS_TRIGGER_CPU=y
+++CONFIG_LEDS_TRIGGER_GPIO=y
+++CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+++CONFIG_LEDS_TRIGGER_TRANSIENT=y
+++CONFIG_LEDS_TRIGGER_CAMERA=y
+++CONFIG_RTC_CLASS=y
+++CONFIG_RTC_DEBUG=y
+++CONFIG_RTC_DRV_DS1307=y
+++CONFIG_RTC_DRV_PALMAS=y
+++CONFIG_RTC_DRV_OMAP=y
+++CONFIG_DMADEVICES=y
+++CONFIG_TI_EDMA=y
+++CONFIG_DMA_OMAP=y
+++CONFIG_UIO=y
+++CONFIG_UIO_PDRV_GENIRQ=y
+++CONFIG_HWSPINLOCK_USER=y
+++CONFIG_HWSPINLOCK_OMAP=y
+++CONFIG_OMAP_IOMMU=y
+++CONFIG_OMAP_IOVMM=y
+++CONFIG_OMAP_IOMMU_DEBUG=y
+++CONFIG_OMAP_REMOTEPROC=y
+++CONFIG_OMAP_REMOTEPROC_WATCHDOG=y
+++CONFIG_RPMSG_RPC=y
+++CONFIG_PM_DEVFREQ=y
+++CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+++CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+++CONFIG_DEVFREQ_GOV_POWERSAVE=y
+++CONFIG_DEVFREQ_GOV_USERSPACE=y
+++CONFIG_EXTCON=y
+++CONFIG_EXTCON_PALMAS=y
+++CONFIG_EXTCON_USB_GPIO=y
+++CONFIG_IIO=m
+++CONFIG_IIO_BUFFER_CB=y
+++CONFIG_TI_AM335X_ADC=m
+++CONFIG_PWM=y
+++CONFIG_PWM_TIECAP=y
+++CONFIG_PWM_TIEHRPWM=y
+++CONFIG_OMAP_USB2=y
+++CONFIG_TI_PIPE3=y
+++CONFIG_EXT2_FS=y
+++CONFIG_EXT3_FS=y
+++# CONFIG_EXT3_FS_XATTR is not set
+++CONFIG_EXT4_FS=y
+++CONFIG_QUOTA=y
+++CONFIG_QFMT_V2=y
+++CONFIG_MSDOS_FS=y
+++CONFIG_VFAT_FS=y
+++CONFIG_TMPFS=y
+++CONFIG_JFFS2_FS=y
+++CONFIG_JFFS2_SUMMARY=y
+++CONFIG_JFFS2_FS_XATTR=y
+++CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+++CONFIG_JFFS2_LZO=y
+++CONFIG_JFFS2_RUBIN=y
+++CONFIG_UBIFS_FS=y
+++CONFIG_CRAMFS=y
+++CONFIG_NFS_FS=y
+++CONFIG_NFS_V3_ACL=y
+++CONFIG_NFS_V4=y
+++CONFIG_ROOT_NFS=y
+++CONFIG_NLS_CODEPAGE_437=y
+++CONFIG_NLS_ISO8859_1=y
+++CONFIG_PRINTK_TIME=y
+++CONFIG_DEBUG_INFO=y
+++CONFIG_DEBUG_FS=y
+++CONFIG_MAGIC_SYSRQ=y
+++# CONFIG_SCHED_DEBUG is not set
+++# CONFIG_DEBUG_BUGVERBOSE is not set
+++# CONFIG_FTRACE is not set
+++# CONFIG_ARM_UNWIND is not set
+++CONFIG_SECURITY=y
+++# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+++CONFIG_CRYPTO_TEST=m
+++CONFIG_CRYPTO_CCM=y
+++CONFIG_CRYPTO_GCM=y
+++CONFIG_CRYPTO_ECB=y
+++CONFIG_CRYPTO_MICHAEL_MIC=y
+++CONFIG_CRYPTO_ARC4=y
+++# CONFIG_CRYPTO_ANSI_CPRNG is not set
+++CONFIG_CRYPTO_USER_API_HASH=y
+++CONFIG_CRYPTO_USER_API_SKCIPHER=y
+++CONFIG_CRYPTO_DEV_OMAP_SHAM=y
+++CONFIG_CRYPTO_DEV_OMAP_AES=y
+++CONFIG_CRYPTO_DEV_OMAP_DES=y
+++CONFIG_CRC_CCITT=y
+++CONFIG_CRC_T10DIF=y
+++CONFIG_CRC_ITU_T=y
+++CONFIG_CRC7=y
+++CONFIG_LIBCRC32C=y
+++CONFIG_FONTS=y
+++CONFIG_FONT_8x8=y
++-- 
++1.9.1
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0002-omap2plus_dom0_defconfig-switch-to-the-dom0-defconfi.patch b/recipes-kernel/linux/linux-kernel-patches/0002-omap2plus_dom0_defconfig-switch-to-the-dom0-defconfi.patch
+new file mode 100644
+index 0000000..10c1470
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0002-omap2plus_dom0_defconfig-switch-to-the-dom0-defconfi.patch
+@@ -0,0 +1,126 @@
++From 655ca6fd6ae89f9d031b7cf7d8342822b5659512 Mon Sep 17 00:00:00 2001
++From: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Date: Fri, 15 Apr 2016 11:50:15 +0300
++Subject: [PATCH] omap2plus_dom0_defconfig: switch to the dom0 defconfig
++
++Done:
++ * Unused configs are disabled
++ * dom0-related configs are enabled
++
++Change-Id: I47fe23bd093ba36f5a15009946beb887665dbeb9
++Signed-off-by: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Signed-off-by: Oleksandr Baglei <oleksandr.baglei@globallogic.com>
++---
++ arch/arm/configs/omap2plus_dom0_defconfig | 38 +++++++++++++------------------
++ 1 file changed, 16 insertions(+), 22 deletions(-)
++
++diff --git a/arch/arm/configs/omap2plus_dom0_defconfig b/arch/arm/configs/omap2plus_dom0_defconfig
++index d41833e..f99c212 100644
++--- a/arch/arm/configs/omap2plus_dom0_defconfig
+++++ b/arch/arm/configs/omap2plus_dom0_defconfig
++@@ -34,23 +34,16 @@ CONFIG_SMP=y
++ CONFIG_NR_CPUS=2
++ CONFIG_PREEMPT=y
++ CONFIG_CMA=y
+++CONFIG_XEN=y
+++# CONFIG_ATAGS is not set
++ CONFIG_ZBOOT_ROM_TEXT=0x0
++ CONFIG_ZBOOT_ROM_BSS=0x0
++ CONFIG_ARM_APPENDED_DTB=y
++-CONFIG_ARM_ATAG_DTB_COMPAT=y
++-CONFIG_CMDLINE="elevator=noop console=ttyO0,115200n8 root=/dev/mmcblk1p2 rw rootwait fixrtc omapdrm.num_crtc=2 consoleblank=0 cma=64M rootfstype=ext4 uio_pdrv_genirq.of_id=generic-uio"
++-CONFIG_KEXEC=y
++-CONFIG_CPU_FREQ=y
++-CONFIG_CPU_FREQ_STAT_DETAILS=y
++-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
++-CONFIG_CPU_FREQ_GOV_POWERSAVE=m
++-CONFIG_CPU_FREQ_GOV_USERSPACE=m
++-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
++-CONFIG_GENERIC_CPUFREQ_CPU0=y
++-# CONFIG_ARM_OMAP2PLUS_CPUFREQ is not set
++-CONFIG_CPU_IDLE=y
++ CONFIG_BINFMT_MISC=y
+++# CONFIG_SUSPEND is not set
+++CONFIG_PM_RUNTIME=y
++ CONFIG_PM_DEBUG=y
+++CONFIG_PM_OPP=y
++ CONFIG_NET=y
++ CONFIG_PACKET=y
++ CONFIG_UNIX=y
++@@ -91,7 +84,7 @@ CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
++ CONFIG_DEVTMPFS=y
++ CONFIG_DEVTMPFS_MOUNT=y
++ CONFIG_DMA_CMA=y
++-CONFIG_CMA_SIZE_MBYTES=24
+++CONFIG_CMA_SIZE_MBYTES=64
++ CONFIG_OMAP_OCP2SCP=y
++ CONFIG_CONNECTOR=y
++ CONFIG_MTD=y
++@@ -111,6 +104,8 @@ CONFIG_MTD_UBI=y
++ CONFIG_BLK_DEV_LOOP=y
++ CONFIG_BLK_DEV_RAM=y
++ CONFIG_BLK_DEV_RAM_SIZE=16384
+++# CONFIG_XEN_BLKDEV_FRONTEND is not set
+++CONFIG_XEN_BLKDEV_BACKEND=y
++ CONFIG_SENSORS_TSL2550=m
++ CONFIG_BMP085_I2C=m
++ CONFIG_TI_ST=y
++@@ -127,8 +122,9 @@ CONFIG_SCSI_CONSTANTS=y
++ CONFIG_SCSI_LOGGING=y
++ CONFIG_SCSI_SCAN_ASYNC=y
++ CONFIG_ATA=y
++-CONFIG_SATA_AHCI=m
+++CONFIG_SATA_AHCI=y
++ CONFIG_SATA_AHCI_PLATFORM=y
+++CONFIG_XEN_FAST_SATA_RESET=y
++ CONFIG_MD=y
++ CONFIG_NETDEVICES=y
++ CONFIG_TIGON3=m
++@@ -149,6 +145,8 @@ CONFIG_USB_ALI_M5632=y
++ CONFIG_USB_AN2720=y
++ CONFIG_USB_EPSON2888=y
++ CONFIG_USB_KC2190=y
+++# CONFIG_XEN_NETDEV_FRONTEND is not set
+++CONFIG_XEN_NETDEV_BACKEND=y
++ CONFIG_INPUT_JOYDEV=y
++ CONFIG_INPUT_EVDEV=y
++ CONFIG_KEYBOARD_GPIO=y
++@@ -195,14 +193,6 @@ CONFIG_TI_COPROC=y
++ CONFIG_SENSORS_GPIO_FAN=y
++ CONFIG_SENSORS_LM75=m
++ CONFIG_SENSORS_TMP102=y
++-CONFIG_THERMAL=y
++-CONFIG_THERMAL_GOV_FAIR_SHARE=y
++-CONFIG_THERMAL_GOV_USER_SPACE=y
++-CONFIG_CPU_THERMAL=y
++-CONFIG_THERMAL_EMULATION=y
++-CONFIG_TI_SOC_THERMAL=y
++-CONFIG_TI_THERMAL=y
++-CONFIG_DRA752_THERMAL=y
++ CONFIG_WATCHDOG=y
++ CONFIG_OMAP_WATCHDOG=y
++ CONFIG_MFD_SYSCON=y
++@@ -244,9 +234,11 @@ CONFIG_DRM_I2C_NXP_TDA998X=y
++ CONFIG_DRM_OMAP=y
++ CONFIG_DRM_OMAP_NUM_CRTCS=2
++ CONFIG_DRM_TILCDC=y
+++CONFIG_DRM_XEN_BACKEND=y
++ CONFIG_FIRMWARE_EDID=y
++ CONFIG_FB_MODE_HELPERS=y
++ CONFIG_FB_TILEBLITTING=y
+++# CONFIG_XEN_FBDEV_FRONTEND is not set
++ CONFIG_OMAP2_DSS=y
++ CONFIG_OMAP5_DSS_HDMI=y
++ CONFIG_OMAP2_DSS_SDI=y
++@@ -352,6 +344,8 @@ CONFIG_TI_EDMA=y
++ CONFIG_DMA_OMAP=y
++ CONFIG_UIO=y
++ CONFIG_UIO_PDRV_GENIRQ=y
+++CONFIG_XEN_GNTDEV=y
+++CONFIG_XEN_GRANT_DEV_ALLOC=y
++ CONFIG_HWSPINLOCK_USER=y
++ CONFIG_HWSPINLOCK_OMAP=y
++ CONFIG_OMAP_IOMMU=y
++-- 
++1.9.1
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0003-ARM-dts-DRA7xx-introduce-device-tree-for-domain-0.patch b/recipes-kernel/linux/linux-kernel-patches/0003-ARM-dts-DRA7xx-introduce-device-tree-for-domain-0.patch
+new file mode 100644
+index 0000000..e3db8cd
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0003-ARM-dts-DRA7xx-introduce-device-tree-for-domain-0.patch
+@@ -0,0 +1,1536 @@
++From 70b263d8e621fd1ffecbc7667bdb904e9dbe9079 Mon Sep 17 00:00:00 2001
++From: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Date: Thu, 28 May 2015 14:19:01 +0300
++Subject: [PATCH] ARM: dts: DRA7xx: introduce device tree for domain 0
++
++Introduced files are copies of the original files.
++
++Change-Id: I0ae7b40af1c12fc58511f3a983010ec072e8d0af
++Signed-off-by: Oleksandr Baglei <oleksandr.baglei@globallogic.com>
++---
++ arch/arm/boot/dts/Makefile                |    2 +
++ arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts |   15 +
++ arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts  |   10 +
++ arch/arm/boot/dts/dra7-evm-dom0.dts       | 1457 +++++++++++++++++++++++++++++
++ 4 files changed, 1484 insertions(+)
++ create mode 100644 arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts
++ create mode 100644 arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts
++ create mode 100644 arch/arm/boot/dts/dra7-evm-dom0.dts
++
++diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
++index ab9e787..b597a29 100644
++--- a/arch/arm/boot/dts/Makefile
+++++ b/arch/arm/boot/dts/Makefile
++@@ -241,7 +241,9 @@ dtb-$(CONFIG_ARCH_OMAP2PLUS) += omap2420-h4.dtb \
++ 	am437x-sk-evm.dtb \
++ 	dra7-evm.dtb \
++ 	dra7-evm-lcd7.dtb \
+++	dra7-evm-dom0-lcd7.dtb \
++ 	dra7-evm-lcd10.dtb \
+++	dra7-evm-dom0-lcd10.dtb \
++ 	dra7-evm-lcd-osd.dtb \
++ 	dra7-evm-lcd7-late-attach.dtb \
++ 	dra7-evm-lcd7-late-attach-no-map.dtb \
++diff --git a/arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts b/arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts
++new file mode 100644
++index 0000000..5cfc07e
++--- /dev/null
+++++ b/arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts
++@@ -0,0 +1,15 @@
+++/*
+++ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+++ *
+++ * This program is free software; you can redistribute it and/or modify
+++ * it under the terms of the GNU General Public License version 2 as
+++ * published by the Free Software Foundation.
+++ */
+++
+++#include "dra7-evm.dts"
+++#include "dra7xx-evm-lcd10.dtsi"
+++
+++&ldc3001 {
+++	interrupt-parent = <&gpio1>;
+++	interrupts = <2 IRQ_TYPE_LEVEL_HIGH>;
+++};
++diff --git a/arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts b/arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts
++new file mode 100644
++index 0000000..4ed8ebe
++--- /dev/null
+++++ b/arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts
++@@ -0,0 +1,10 @@
+++/*
+++ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+++ *
+++ * This program is free software; you can redistribute it and/or modify
+++ * it under the terms of the GNU General Public License version 2 as
+++ * published by the Free Software Foundation.
+++ */
+++
+++#include "dra7-evm.dts"
+++#include "dra7xx-evm-lcd7.dtsi"
++diff --git a/arch/arm/boot/dts/dra7-evm-dom0.dts b/arch/arm/boot/dts/dra7-evm-dom0.dts
++new file mode 100644
++index 0000000..181d6e5
++--- /dev/null
+++++ b/arch/arm/boot/dts/dra7-evm-dom0.dts
++@@ -0,0 +1,1457 @@
+++/*
+++ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+++ *
+++ * This program is free software; you can redistribute it and/or modify
+++ * it under the terms of the GNU General Public License version 2 as
+++ * published by the Free Software Foundation.
+++ */
+++/dts-v1/;
+++
+++#include "dra74x.dtsi"
+++#include <dt-bindings/interrupt-controller/irq.h>
+++#include <dt-bindings/gpio/gpio.h>
+++#include <dt-bindings/clk/ti-dra7-atl.h>
+++
+++/ {
+++	model = "TI DRA742";
+++	compatible = "ti,dra7-evm", "ti,dra742", "ti,dra74", "ti,dra7";
+++
+++	memory {
+++		device_type = "memory";
+++		reg = <0x80000000 0x60000000>; /* 1536 MB */
+++	};
+++
+++	reserved_mem: reserved-memory {
+++		#address-cells = <1>;
+++		#size-cells = <1>;
+++		ranges;
+++
+++		ipu2_cma_pool: ipu2_cma@95800000 {
+++			compatible = "shared-dma-pool";
+++			reg = <0x95800000 0x3800000>;
+++			reusable;
+++			status = "okay";
+++		};
+++
+++		dsp1_cma_pool: dsp1_cma@99000000 {
+++			compatible = "shared-dma-pool";
+++			reg = <0x99000000 0x4000000>;
+++			reusable;
+++			status = "okay";
+++		};
+++
+++		ipu1_cma_pool: ipu1_cma@9d000000 {
+++			compatible = "shared-dma-pool";
+++			reg = <0x9d000000 0x2000000>;
+++			reusable;
+++			status = "okay";
+++		};
+++
+++		dsp2_cma_pool: dsp2_cma@9f000000 {
+++			compatible = "shared-dma-pool";
+++			reg = <0x9f000000 0x800000>;
+++			reusable;
+++			status = "okay";
+++		};
+++	};
+++
+++	extcon_usb1: extcon_usb1 {
+++		compatible = "linux,extcon-usb-gpio";
+++		id-gpios = <&pcf_gpio_21 1 GPIO_ACTIVE_HIGH>;
+++	};
+++
+++	extcon_usb2: extcon_usb2 {
+++		compatible = "linux,extcon-usb-gpio";
+++		id-gpios = <&pcf_gpio_21 2 GPIO_ACTIVE_HIGH>;
+++	};
+++
+++	evm_3v3_sd: fixedregulator-sd {
+++		compatible = "regulator-fixed";
+++		regulator-name = "evm_3v3_sd";
+++		regulator-min-microvolt = <3300000>;
+++		regulator-max-microvolt = <3300000>;
+++		enable-active-high;
+++		gpio = <&pcf_gpio_21 5 0>;
+++	};
+++
+++	evm_3v3_sw: fixedregulator-evm_3v3_sw {
+++		compatible = "regulator-fixed";
+++		regulator-name = "evm_3v3_sw";
+++		vin-supply = <&sysen1>;
+++		regulator-min-microvolt = <3300000>;
+++		regulator-max-microvolt = <3300000>;
+++	};
+++
+++	aic_dvdd: fixedregulator-aic_dvdd {
+++		/* TPS77018DBVT */
+++		compatible = "regulator-fixed";
+++		regulator-name = "aic_dvdd";
+++		vin-supply = <&evm_3v3_sw>;
+++		regulator-min-microvolt = <1800000>;
+++		regulator-max-microvolt = <1800000>;
+++	};
+++
+++	vmmcwl_fixed: fixedregulator-mmcwl {
+++		compatible = "regulator-fixed";
+++		regulator-name = "vmmcwl_fixed";
+++		regulator-min-microvolt = <1800000>;
+++		regulator-max-microvolt = <1800000>;
+++		gpio = <&gpio5 8 0>;	/* gpio5_8 */
+++		startup-delay-us = <70000>;
+++		enable-active-high;
+++	};
+++
+++	kim {
+++		compatible = "kim";
+++		nshutdown_gpio = <132>;
+++		dev_name = "/dev/ttyS2";
+++		flow_cntrl = <1>;
+++		baud_rate = <3686400>;
+++	};
+++
+++	btwilink {
+++		compatible = "btwilink";
+++	};
+++
+++	vtt_fixed: fixedregulator-vtt {
+++		compatible = "regulator-fixed";
+++		regulator-name = "vtt_fixed";
+++		regulator-min-microvolt = <1350000>;
+++		regulator-max-microvolt = <1350000>;
+++		regulator-always-on;
+++		regulator-boot-on;
+++		enable-active-high;
+++		vin-supply = <&sysen2>;
+++		gpio = <&gpio7 11 GPIO_ACTIVE_HIGH>;
+++	};
+++
+++	aliases {
+++		display0 = &hdmi0;
+++		sound0 = &primary_sound;
+++		sound1 = &hdmi;
+++		i2c7 = &disp_ser;
+++		mmc1 = &mmc1;
+++		mmc2 = &mmc2;
+++		mmc3 = &mmc3;
+++		mmc4 = &mmc4;
+++	};
+++
+++	chosen {
+++		mmc1_pinctl4_iodelay = <&mmc1_iodelay_ddr50_conf_sr11 &mmc1_iodelay_ddr50_conf_sr20>;
+++		mmc1_pinctl5_iodelay = <&mmc1_iodelay_dummy_conf_sr11 &mmc1_iodelay_sdr104_conf_sr20>;
+++		mmc2_pinctl2_iodelay = <&mmc2_iodelay_ddr_3_3v_conf_sr11 &mmc2_iodelay_ddr_3_3v_conf_sr20>;
+++		mmc2_pinctl3_iodelay = <&mmc2_iodelay_dummy_conf_sr11 &mmc2_iodelay_hs200_conf_sr20>;
+++		mmc4_pinctl0_iodelay = <&mmc4_iodelay_ds_manual1_conf_sr11 &mmc4_iodelay_ds_manual1_conf_sr20>;
+++		mmc4_pinctl1_iodelay = <&mmc4_iodelay_manual1_conf_sr11 &mmc4_iodelay_manual1_conf_sr20>;
+++	};
+++
+++	hdmi0: connector@1 {
+++		compatible = "hdmi-connector";
+++		label = "hdmi";
+++
+++		type = "a";
+++
+++		port {
+++			hdmi_connector_in: endpoint {
+++				remote-endpoint = <&tpd12s015_out>;
+++			};
+++		};
+++	};
+++
+++	tpd12s015: encoder@1 {
+++		compatible = "ti,dra7evm-tpd12s015";
+++
+++		pinctrl-names = "i2c", "ddc";
+++		pinctrl-0 = <&hdmi_i2c_sel_pin &hdmi_i2c_pins_i2c>;
+++		pinctrl-1 = <&hdmi_i2c_sel_pin &hdmi_i2c_pins_ddc>;
+++
+++		ddc-i2c-bus = <&i2c2>;
+++		mcasp-gpio = <&mcasp8>;
+++
+++		gpios = <&pcf_hdmi 4 0>,	/* P4, CT CP HPD */
+++			<&pcf_hdmi 5 0>,	/* P5, LS OE */
+++			<&gpio7 12 0>;	/* gpio7_12/sp1_cs2, HPD */
+++
+++		ports {
+++			#address-cells = <1>;
+++			#size-cells = <0>;
+++
+++			port@0 {
+++				reg = <0>;
+++
+++				tpd12s015_in: endpoint@0 {
+++					remote-endpoint = <&hdmi_out>;
+++				};
+++			};
+++
+++			port@1 {
+++				reg = <1>;
+++
+++				tpd12s015_out: endpoint@0 {
+++					remote-endpoint = <&hdmi_connector_in>;
+++				};
+++			};
+++		};
+++	};
+++
+++    ocp {
+++        gpu: gpu@0x56000000 {
+++            gpu0-voltdm = <&voltdm_gpu>;
+++        };
+++    };
+++
+++	primary_sound: primary_sound {
+++		compatible = "ti,dra7xx-evm-audio";
+++		ti,model = "DRA7xx-EVM";
+++		ti,always-on;
+++		ti,audio-codec = <&tlv320aic3106>;
+++		ti,mcasp-controller = <&mcasp3>;
+++		ti,codec-clock-rate = <11289600>;
+++		clocks = <&atl_clkin2_ck>;
+++		clock-names = "mclk";
+++		ti,audio-routing =
+++			"Headphone Jack",       "HPLOUT",
+++			"Headphone Jack",       "HPROUT",
+++			"Line Out",		"LLOUT",
+++			"Line Out",		"RLOUT",
+++			"MIC3L",		"Mic Jack",
+++			"MIC3R",		"Mic Jack",
+++			"Mic Jack",		"Mic Bias",
+++			"LINE1L",               "Line In",
+++			"LINE1R",               "Line In";
+++	};
+++
+++	btwilink_sound: btwilink_sound {
+++		#sound-dai-cells = <0>;
+++		compatible = "linux,bt-sco-audio";
+++		status = "okay";
+++	};
+++
+++	simple_bt_sco_card: bt_sco_card {
+++		compatible = "simple-audio-card";
+++		simple-audio-card,name = "DRA7xx-WiLink";
+++		simple-audio-card,format = "dsp_a";
+++		simple-audio-card,frame-master = <&btwilink_codec>;
+++		simple-audio-card,bitclock-master = <&btwilink_codec>;
+++		simple-audio-card,frame-inversion;
+++
+++		simple-audio-card,cpu {
+++			sound-dai = <&mcasp7>;
+++		};
+++
+++		btwilink_codec: simple-audio-card,codec {
+++			sound-dai = <&btwilink_sound>;
+++		};
+++	};
+++};
+++
+++&dra7_pmx_core {
+++	hdmi_i2c_sel_pin: pinmux_hdmi_i2c_sel_pin {
+++		pinctrl-single,pins = <
+++			/* this pin is used as a GPIO via mcasp */
+++			0x2fc	(PIN_OUTPUT | MUX_MODE1) /* mcasp8_axr2 */
+++		>;
+++	};
+++
+++	hdmi_i2c_pins_i2c: pinmux_hdmi_i2c_pins_default {
+++		pinctrl-single,pins = <
+++			0x408	(PIN_INPUT | MUX_MODE0) /* i2c2_sda.i2c2_sda */
+++			0x40c	(PIN_INPUT | MUX_MODE0) /* i2c2_scl.i2c2_scl */
+++		>;
+++	};
+++
+++	hdmi_i2c_pins_ddc: pinmux_hdmi_i2c_pins_ddc {
+++		pinctrl-single,pins = <
+++			0x408	(PIN_INPUT | MUX_MODE1) /* i2c2_sda.hdmi1_ddc_scl */
+++			0x40c	(PIN_INPUT | MUX_MODE1) /* i2c2_scl.hdmi1_ddc_sda */
+++		>;
+++	};
+++
+++	dcan1_pins_default: dcan1_pins_default {
+++		pinctrl-single,pins = <
+++			0x3d0   (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* dcan1_tx */
+++			0x418   (PULL_UP | MUX_MODE1)		/* wakeup0.dcan1_rx */
+++		>;
+++	};
+++
+++	dcan1_pins_sleep: dcan1_pins_sleep {
+++		pinctrl-single,pins = <
+++			0x3d0   (MUX_MODE15 | PULL_UP)	/* dcan1_tx.off */
+++			0x418   (MUX_MODE15 | PULL_UP)	/* wakeup0.off */
+++		>;
+++	};
+++
+++	mmc1_pins_default: pinmux_mmc1_default_pins {
+++		pinctrl-single,pins = <
+++			0x354 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_clk.clk */
+++			0x358 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_cmd.cmd */
+++			0x35c (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat0.dat0 */
+++			0x360 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat1.dat1 */
+++			0x364 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat2.dat2 */
+++			0x368 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat3.dat3 */
+++			0x36c (PIN_INPUT | MUX_MODE14)		/* mmc1sdcd.gpio187 */
+++		>;
+++	};
+++
+++	mmc1_pins_sdr12: pinmux_mmc1_sdr12_pins {
+++		pinctrl-single,pins = <
+++			0x354 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_clk.clk */
+++			0x358 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_cmd.cmd */
+++			0x35c (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat0.dat0 */
+++			0x360 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat1.dat1 */
+++			0x364 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat2.dat2 */
+++			0x368 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc1_dat3.dat3 */
+++		>;
+++	};
+++
+++	mmc1_pins_hs: pinmux_mmc1_hs_pins {
+++		pinctrl-single,pins = <
+++			0x354 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_clk.clk */
+++			0x358 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_cmd.cmd */
+++			0x35c (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+++			0x360 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+++			0x364 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+++			0x368 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+++		>;
+++	};
+++
+++	mmc1_pins_sdr25: pinmux_mmc1_sdr25_pins {
+++		pinctrl-single,pins = <
+++			0x354 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_clk.clk */
+++			0x358 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_cmd.cmd */
+++			0x35c (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat0.dat0 */
+++			0x360 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat1.dat1 */
+++			0x364 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat2.dat2 */
+++			0x368 (PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0)	/* mmc1_dat3.dat3 */
+++		>;
+++	};
+++
+++	mmc1_pins_ddr50: pinmux_mmc1_ddr50_pins {
+++		pinctrl-single,pins = <
+++			0x354 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_clk.clk */
+++			0x358 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_cmd.cmd */
+++			0x35c (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_dat0.dat0 */
+++			0x360 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_dat1.dat1 */
+++			0x364 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_dat2.dat2 */
+++			0x368 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_dat3.dat3 */
+++		>;
+++	};
+++
+++	mmc1_pins_sdr104: pinmux_mmc1_sdr104_pins {
+++		pinctrl-single,pins = <
+++			0x354 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_clk.clk */
+++			0x358 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_cmd.cmd */
+++			0x35c (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_dat0.dat0 */
+++			0x360 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_dat1.dat1 */
+++			0x364 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_dat2.dat2 */
+++			0x368 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE0)	/* mmc1_dat3.dat3 */
+++		>;
+++	};
+++
+++	mmc2_pins_default: mmc2_pins_default {
+++		pinctrl-single,pins = <
+++			0x9c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+++			0xb0 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+++			0xa0 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+++			0xa4 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+++			0xa8 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+++			0xac (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+++			0x8c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+++			0x90 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+++			0x94 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+++			0x98 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+++		>;
+++	};
+++
+++	mmc2_pins_hs: pinmux_mmc2_hs_pins {
+++		pinctrl-single,pins = <
+++			0x9c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+++			0xb0 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+++			0xa0 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+++			0xa4 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+++			0xa8 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+++			0xac (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+++			0x8c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+++			0x90 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+++			0x94 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+++			0x98 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+++		>;
+++	};
+++
+++	mmc2_pins_ddr_3_3v: pinmux_mmc2_ddr_3_3v_pins {
+++		pinctrl-single,pins = <
+++			0x9c (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+++			0xb0 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+++			0xa0 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+++			0xa4 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+++			0xa8 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+++			0xac (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+++			0x8c (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+++			0x90 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+++			0x94 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+++			0x98 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+++		>;
+++	};
+++
+++	mmc2_pins_hs200: pinmux_mmc2_hs200_pins {
+++		pinctrl-single,pins = <
+++			0x9c (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+++			0xb0 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+++			0xa0 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+++			0xa4 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+++			0xa8 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+++			0xac (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+++			0x8c (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+++			0x90 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+++			0x94 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+++			0x98 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+++		>;
+++	};
+++
+++	mmc4_pins_default: mmc4_pins_default {
+++		pinctrl-single,pins = <
+++			0x3E8 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart1_ctsn.mmc4_clk */
+++			0x3EC (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart1_rtsn.mmc4_cmd */
+++			0x3F0 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart2_rxd.mmc4_dat0 */
+++			0x3F4 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart2_txd.mmc4_dat1 */
+++			0x3F8 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart2_ctsn.mmc4_dat2 */
+++			0x3FC (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart2_rtsn.mmc4_dat3 */
+++		>;
+++	};
+++
+++	mmc4_pins_hs: pinmux_mmc4_hs_pins {
+++		pinctrl-single,pins = <
+++			0x3E8 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart1_ctsn.mmc4_clk */
+++			0x3EC (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart1_rtsn.mmc4_cmd */
+++			0x3F0 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart2_rxd.mmc4_dat0 */
+++			0x3F4 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart2_txd.mmc4_dat1 */
+++			0x3F8 (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart2_ctsn.mmc4_dat2 */
+++			0x3FC (PIN_INPUT_PULLUP | MANUAL_MODE | MUX_MODE3) /* uart2_rtsn.mmc4_dat3 */
+++		>;
+++	};
+++};
+++
+++&dra7_iodelay_core {
+++	mmc1_iodelay_ddr50_conf_sr11: mmc1_iodelay_ddr50_conf_sr11 {
+++		pinctrl-single,pins = <
+++			0x618 (A_DELAY(572) | G_DELAY(540))	/* CFG_MMC1_CLK_IN */
+++			0x624 (A_DELAY(0) | G_DELAY(600))	/* CFG_MMC1_CMD_IN */
+++			0x630 (A_DELAY(403) | G_DELAY(120))	/* CFG_MMC1_DAT0_IN */
+++			0x63c (A_DELAY(23) | G_DELAY(60))	/* CFG_MMC1_DAT1_IN */
+++			0x648 (A_DELAY(25) | G_DELAY(60))	/* CFG_MMC1_DAT2_IN */
+++			0x654 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT3_IN */
+++			0x620 (A_DELAY(1525) | G_DELAY(0))	/* CFG_MMC1_CLK_IN */
+++			0x628 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_CMD_OEN */
+++			0x62c (A_DELAY(55) | G_DELAY(0))	/* CFG_MMC1_CMD_OUT */
+++			0x634 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT0_OEN */
+++			0x638 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT0_OUT */
+++			0x640 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT1_OEN */
+++			0x644 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT1_OUT */
+++			0x64c (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT2_OEN */
+++			0x650 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT2_OUT */
+++			0x658 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT3_OEN */
+++			0x65c (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT3_OUT */
+++		>;
+++	};
+++
+++	mmc1_iodelay_dummy_conf_sr11: mmc1_iodelay_dummy_conf_sr11 {
+++		pinctrl-single,pins = <
+++			0x618 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_CLK_IN */
+++			0x624 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_CMD_IN */
+++			0x630 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT0_IN */
+++			0x63c (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT1_IN */
+++			0x648 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT2_IN */
+++			0x654 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT3_IN */
+++			0x620 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_CLK_IN */
+++			0x628 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_CMD_OEN */
+++			0x62c (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_CMD_OUT */
+++			0x634 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT0_OEN */
+++			0x638 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT0_OUT */
+++			0x640 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT1_OEN */
+++			0x644 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT1_OUT */
+++			0x64c (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT2_OEN */
+++			0x650 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT2_OUT */
+++			0x658 (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT3_OEN */
+++			0x65c (A_DELAY(0) | G_DELAY(0))	/* CFG_MMC1_DAT3_OUT */
+++		>;
+++	};
+++
+++	mmc1_iodelay_ddr50_conf_sr20: mmc1_iodelay_ddr50_conf_sr20 {
+++		pinctrl-single,pins = <
+++			0x618 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_CLK_IN */
+++			0x620 (A_DELAY(1271) | G_DELAY(0))	/* CFG_MMC1_CLK_OUT */
+++			0x624 (A_DELAY(229) | G_DELAY(0))	/* CFG_MMC1_CMD_IN */
+++			0x628 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_CMD_OEN */
+++			0x62C (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_CMD_OUT */
+++			0x630 (A_DELAY(850) | G_DELAY(0))	/* CFG_MMC1_DAT0_IN */
+++			0x634 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT0_OEN */
+++			0x638 (A_DELAY(20) | G_DELAY(0))	/* CFG_MMC1_DAT0_OUT */
+++			0x63C (A_DELAY(468) | G_DELAY(0))	/* CFG_MMC1_DAT1_IN */
+++			0x640 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT1_OEN */
+++			0x644 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT1_OUT */
+++			0x648 (A_DELAY(466) | G_DELAY(0))	/* CFG_MMC1_DAT2_IN */
+++			0x64C (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT2_OEN */
+++			0x650 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT2_OUT */
+++			0x654 (A_DELAY(399) | G_DELAY(0))	/* CFG_MMC1_DAT3_IN */
+++			0x658 (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT3_OEN */
+++			0x65C (A_DELAY(0) | G_DELAY(0))		/* CFG_MMC1_DAT3_OUT */
+++		>;
+++	};
+++
+++	mmc1_iodelay_sdr104_conf_sr20: mmc1_iodelay_sdr104_conf_sr20 {
+++		pinctrl-single,pins = <
+++			0x620 (A_DELAY(1063) | G_DELAY(17))     /* CFG_MMC1_CLK_OUT */
+++			0x628 (A_DELAY(0) | G_DELAY(0))         /* CFG_MMC1_CMD_OEN */
+++			0x62c (A_DELAY(23) | G_DELAY(0))        /* CFG_MMC1_CMD_OUT */
+++			0x634 (A_DELAY(0) | G_DELAY(0))         /* CFG_MMC1_DAT0_OEN */
+++			0x638 (A_DELAY(0) | G_DELAY(0))         /* CFG_MMC1_DAT0_OUT */
+++			0x640 (A_DELAY(0) | G_DELAY(0))         /* CFG_MMC1_DAT1_OEN */
+++			0x644 (A_DELAY(2) | G_DELAY(0))         /* CFG_MMC1_DAT1_OUT */
+++			0x64c (A_DELAY(0) | G_DELAY(0))         /* CFG_MMC1_DAT2_OEN */
+++			0x650 (A_DELAY(0) | G_DELAY(0))         /* CFG_MMC1_DAT2_OUT */
+++			0x658 (A_DELAY(0) | G_DELAY(0))         /* CFG_MMC1_DAT3_OEN */
+++			0x65c (A_DELAY(0) | G_DELAY(0))         /* CFG_MMC1_DAT3_OUT */
+++		>;
+++	};
+++
+++	mmc2_iodelay_ddr_3_3v_conf_sr11: mmc2_iodelay_ddr_3_3v_conf_sr11 {
+++		pinctrl-single,pins = <
+++			0x18c (A_DELAY(0) | G_DELAY(120))	/* CFG_GPMC_A19_IN */
+++			0x1a4 (A_DELAY(265) | G_DELAY(360))	/* CFG_GPMC_A20_IN */
+++			0x1b0 (A_DELAY(0) | G_DELAY(120))	/* CFG_GPMC_A21_IN */
+++			0x1bc (A_DELAY(0) | G_DELAY(120))	/* CFG_GPMC_A22_IN */
+++			0x1c8 (A_DELAY(287) | G_DELAY(420))	/* CFG_GPMC_A23_IN */
+++			0x1d4 (A_DELAY(144) | G_DELAY(240))	/* CFG_GPMC_A24_IN */
+++			0x1e0 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A25_IN */
+++			0x1ec (A_DELAY(0) | G_DELAY(120))	/* CFG_GPMC_A26_IN */
+++			0x1f8 (A_DELAY(120) | G_DELAY(180))	/* CFG_GPMC_A27_IN */
+++			0x360 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_CS1_IN */
+++			0x190 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A19_OEN */
+++			0x194 (A_DELAY(174) | G_DELAY(0))	/* CFG_GPMC_A19_OUT */
+++			0x1a8 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A20_OEN */
+++			0x1ac (A_DELAY(168) | G_DELAY(0))	/* CFG_GPMC_A20_OUT */
+++			0x1b4 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A21_OEN */
+++			0x1b8 (A_DELAY(136) | G_DELAY(0))	/* CFG_GPMC_A21_OUT */
+++			0x1c0 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A22_OEN */
+++			0x1c4 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A22_OUT */
+++			0x1d0 (A_DELAY(879) | G_DELAY(0))	/* CFG_GPMC_A23_OUT */
+++			0x1d8 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A24_OEN */
+++			0x1dc (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A24_OUT */
+++			0x1e4 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A25_OEN */
+++			0x1e8 (A_DELAY(34) | G_DELAY(0))	/* CFG_GPMC_A25_OUT */
+++			0x1f0 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A26_OEN */
+++			0x1f4 (A_DELAY(120) | G_DELAY(0))	/* CFG_GPMC_A26_OUT */
+++			0x1fc (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A27_OEN */
+++			0x200 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A27_OUT */
+++			0x364 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_CS1_OEN */
+++			0x368 (A_DELAY(11) | G_DELAY(0))	/* CFG_GPMC_CS1_OUT */
+++		>;
+++	};
+++
+++	mmc2_iodelay_dummy_conf_sr11: mmc2_iodelay_dummy_conf_sr11 {
+++		pinctrl-single,pins = <
+++			0x18c (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A19_IN */
+++			0x1a4 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A20_IN */
+++			0x1b0 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A21_IN */
+++			0x1bc (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A22_IN */
+++			0x1c8 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A23_IN */
+++			0x1d4 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A24_IN */
+++			0x1e0 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A25_IN */
+++			0x1ec (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A26_IN */
+++			0x1f8 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A27_IN */
+++			0x360 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_CS1_IN */
+++			0x190 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A19_OEN */
+++			0x194 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A19_OUT */
+++			0x1a8 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A20_OEN */
+++			0x1ac (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A20_OUT */
+++			0x1b4 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A21_OEN */
+++			0x1b8 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A21_OUT */
+++			0x1c0 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A22_OEN */
+++			0x1c4 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A22_OUT */
+++			0x1d0 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A23_OUT */
+++			0x1d8 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A24_OEN */
+++			0x1dc (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A24_OUT */
+++			0x1e4 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A25_OEN */
+++			0x1e8 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A25_OUT */
+++			0x1f0 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A26_OEN */
+++			0x1f4 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A26_OUT */
+++			0x1fc (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A27_OEN */
+++			0x200 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_A27_OUT */
+++			0x364 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_CS1_OEN */
+++			0x368 (A_DELAY(0) | G_DELAY(0))	/* CFG_GPMC_CS1_OUT */
+++		>;
+++	};
+++
+++	mmc2_iodelay_ddr_3_3v_conf_sr20: mmc2_iodelay_ddr_3_3v_conf_sr20 {
+++		pinctrl-single,pins = <
+++			0x18c (A_DELAY(270) | G_DELAY(0))	/* CFG_GPMC_A19_IN */
+++			0x1a4 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A20_IN */
+++			0x1b0 (A_DELAY(170) | G_DELAY(0))	/* CFG_GPMC_A21_IN */
+++			0x1bc (A_DELAY(758) | G_DELAY(0))	/* CFG_GPMC_A22_IN */
+++			0x1c8 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A23_IN */
+++			0x1d4 (A_DELAY(81) | G_DELAY(0))	/* CFG_GPMC_A24_IN */
+++			0x1e0 (A_DELAY(286) | G_DELAY(0))	/* CFG_GPMC_A25_IN */
+++			0x1ec (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A26_IN */
+++			0x1f8 (A_DELAY(123) | G_DELAY(0))	/* CFG_GPMC_A27_IN */
+++			0x360 (A_DELAY(346) | G_DELAY(0))	/* CFG_GPMC_CS1_IN */
+++			0x190 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A19_OEN */
+++			0x194 (A_DELAY(55) | G_DELAY(0))	/* CFG_GPMC_A19_OUT */
+++			0x1a8 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A20_OEN */
+++			0x1ac (A_DELAY(422) | G_DELAY(0))	/* CFG_GPMC_A20_OUT */
+++			0x1b4 (A_DELAY(642) | G_DELAY(0))	/* CFG_GPMC_A21_OEN */
+++			0x1b8 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A21_OUT */
+++			0x1c0 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A22_OEN */
+++			0x1c4 (A_DELAY(128) | G_DELAY(0))	/* CFG_GPMC_A22_OUT */
+++			0x1d0 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A23_OUT */
+++			0x1d8 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A24_OEN */
+++			0x1dc (A_DELAY(395) | G_DELAY(0))	/* CFG_GPMC_A24_OUT */
+++			0x1e4 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A25_OEN */
+++			0x1e8 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A25_OUT */
+++			0x1f0 (A_DELAY(623) | G_DELAY(0))	/* CFG_GPMC_A26_OEN */
+++			0x1f4 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A26_OUT */
+++			0x1fc (A_DELAY(54) | G_DELAY(0))	/* CFG_GPMC_A27_OEN */
+++			0x200 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_A27_OUT */
+++			0x364 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_CS1_OEN */
+++			0x368 (A_DELAY(0) | G_DELAY(0))		/* CFG_GPMC_CS1_OUT */
+++		>;
+++	};
+++
+++	mmc2_iodelay_hs200_conf_sr20: mmc2_iodelay_hs200_conf_sr20 {
+++		pinctrl-single,pins = <
+++			0x190 (A_DELAY(274) | G_DELAY(0))       /* CFG_GPMC_A19_OEN */
+++			0x194 (A_DELAY(162) | G_DELAY(0))       /* CFG_GPMC_A19_OUT */
+++			0x1a8 (A_DELAY(401) | G_DELAY(0))       /* CFG_GPMC_A20_OEN */
+++			0x1ac (A_DELAY(73) | G_DELAY(0))        /* CFG_GPMC_A20_OUT */
+++			0x1b4 (A_DELAY(465) | G_DELAY(0))       /* CFG_GPMC_A21_OEN */
+++			0x1b8 (A_DELAY(115) | G_DELAY(0))       /* CFG_GPMC_A21_OUT */
+++			0x1c0 (A_DELAY(633) | G_DELAY(0))       /* CFG_GPMC_A22_OEN */
+++			0x1c4 (A_DELAY(47) | G_DELAY(0))        /* CFG_GPMC_A22_OUT */
+++			0x1d0 (A_DELAY(935) | G_DELAY(280))     /* CFG_GPMC_A23_OUT */
+++			0x1d8 (A_DELAY(621) | G_DELAY(0))       /* CFG_GPMC_A24_OEN */
+++			0x1dc (A_DELAY(0) | G_DELAY(0))         /* CFG_GPMC_A24_OUT */
+++			0x1e4 (A_DELAY(183) | G_DELAY(0))       /* CFG_GPMC_A25_OEN */
+++			0x1e8 (A_DELAY(0) | G_DELAY(0))         /* CFG_GPMC_A25_OUT */
+++			0x1f0 (A_DELAY(467) | G_DELAY(0))       /* CFG_GPMC_A26_OEN */
+++			0x1f4 (A_DELAY(0) | G_DELAY(0))         /* CFG_GPMC_A26_OUT */
+++			0x1fc (A_DELAY(262) | G_DELAY(0))       /* CFG_GPMC_A27_OEN */
+++			0x200 (A_DELAY(46) | G_DELAY(0))        /* CFG_GPMC_A27_OUT */
+++			0x364 (A_DELAY(684) | G_DELAY(0))       /* CFG_GPMC_CS1_OEN */
+++			0x368 (A_DELAY(76) | G_DELAY(0))        /* CFG_GPMC_CS1_OUT */
+++	      >;
+++	};
+++
+++	mmc4_iodelay_ds_manual1_conf_sr11: mmc4_iodelay_ds_manual1_conf_sr11 {
+++		pinctrl-single,pins = <
+++			0x840 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_CTSN_IN */
+++			0x848 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_CTSN_OUT */
+++			0x84c (A_DELAY(96) | G_DELAY(0))	/* CFG_UART1_RTSN_IN */
+++			0x850 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_RTSN_OEN */
+++			0x854 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_RTSN_OUT */
+++			0x870 (A_DELAY(582) | G_DELAY(0))	/* CFG_UART2_CTSN_IN */
+++			0x874 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_CTSN_OEN */
+++			0x878 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_CTSN_OUT */
+++			0x87C (A_DELAY(391) | G_DELAY(0))	/* RCFG_UART2_RTSN_IN */
+++			0x880 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RTSN_OEN */
+++			0x884 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RTSN_OUT */
+++			0x888 (A_DELAY(561) | G_DELAY(0))	/* RCFG_UART2_RXD_IN */
+++			0x88c (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RXD_OEN */
+++			0x890 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RXD_OUT */
+++			0x894 (A_DELAY(588) | G_DELAY(0))	/* CFG_UART2_TXD_IN */
+++			0x898 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_TXD_OEN */
+++			0x89c (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_TXD_OUT */
+++		>;
+++	};
+++
+++	mmc4_iodelay_manual1_conf_sr11: mmc4_iodelay_manual1_conf_sr11 {
+++		pinctrl-single,pins = <
+++			0x840 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_CTSN_IN */
+++			0x848 (A_DELAY(2651) | G_DELAY(0))	/* CFG_UART1_CTSN_OUT */
+++			0x84c (A_DELAY(1572) | G_DELAY(0))	/* CFG_UART1_RTSN_IN */
+++			0x850 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_RTSN_OEN */
+++			0x854 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_RTSN_OUT */
+++			0x870 (A_DELAY(1913) | G_DELAY(0))	/* CFG_UART2_CTSN_IN */
+++			0x874 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_CTSN_OEN */
+++			0x878 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_CTSN_OUT */
+++			0x87C (A_DELAY(1721) | G_DELAY(0))	/* RCFG_UART2_RTSN_IN */
+++			0x880 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RTSN_OEN */
+++			0x884 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RTSN_OUT */
+++			0x888 (A_DELAY(1891) | G_DELAY(0))	/* RCFG_UART2_RXD_IN */
+++			0x88c (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RXD_OEN */
+++			0x890 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RXD_OUT */
+++			0x894 (A_DELAY(1919) | G_DELAY(0))	/* CFG_UART2_TXD_IN */
+++			0x898 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_TXD_OEN */
+++			0x89c (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_TXD_OUT */
+++		>;
+++	};
+++
+++	mmc4_iodelay_ds_manual1_conf_sr20: mmc4_iodelay_ds_manual1_conf_sr20 {
+++		pinctrl-single,pins = <
+++			0x840 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_CTSN_IN */
+++			0x848 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_CTSN_OUT */
+++			0x84c (A_DELAY(307) | G_DELAY(0))	/* CFG_UART1_RTSN_IN */
+++			0x850 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_RTSN_OEN */
+++			0x854 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_RTSN_OUT */
+++			0x870 (A_DELAY(683) | G_DELAY(0))	/* CFG_UART2_CTSN_IN */
+++			0x874 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_CTSN_OEN */
+++			0x878 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_CTSN_OUT */
+++			0x87C (A_DELAY(835) | G_DELAY(0))	/* RCFG_UART2_RTSN_IN */
+++			0x880 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RTSN_OEN */
+++			0x884 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RTSN_OUT */
+++			0x888 (A_DELAY(785) | G_DELAY(0))	/* RCFG_UART2_RXD_IN */
+++			0x88c (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RXD_OEN */
+++			0x890 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RXD_OUT */
+++			0x894 (A_DELAY(613) | G_DELAY(0))	/* CFG_UART2_TXD_IN */
+++			0x898 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_TXD_OEN */
+++			0x89c (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_TXD_OUT */
+++		>;
+++	};
+++
+++	mmc4_iodelay_manual1_conf_sr20: mmc4_iodelay_manual1_conf_sr20 {
+++		pinctrl-single,pins = <
+++			0x840 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_CTSN_IN */
+++			0x848 (A_DELAY(1147) | G_DELAY(0))	/* CFG_UART1_CTSN_OUT */
+++			0x84c (A_DELAY(1834) | G_DELAY(0))	/* CFG_UART1_RTSN_IN */
+++			0x850 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_RTSN_OEN */
+++			0x854 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART1_RTSN_OUT */
+++			0x870 (A_DELAY(1935) | G_DELAY(128))	/* CFG_UART2_CTSN_IN */
+++			0x874 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_CTSN_OEN */
+++			0x878 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_CTSN_OUT */
+++			0x87C (A_DELAY(2172) | G_DELAY(44))	/* RCFG_UART2_RTSN_IN */
+++			0x880 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RTSN_OEN */
+++			0x884 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RTSN_OUT */
+++			0x888 (A_DELAY(2165) | G_DELAY(0))	/* RCFG_UART2_RXD_IN */
+++			0x88c (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RXD_OEN */
+++			0x890 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_RXD_OUT */
+++			0x894 (A_DELAY(1929) | G_DELAY(64))	/* CFG_UART2_TXD_IN */
+++			0x898 (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_TXD_OEN */
+++			0x89c (A_DELAY(0) | G_DELAY(0))		/* CFG_UART2_TXD_OUT */
+++		>;
+++	};
+++};
+++
+++&i2c1 {
+++	status = "okay";
+++	clock-frequency = <400000>;
+++
+++	tps659038: tps659038@58 {
+++		compatible = "ti,tps659038";
+++		reg = <0x58>;
+++
+++		tps659038_pmic {
+++			compatible = "ti,tps659038-pmic";
+++
+++			regulators {
+++				smps123_reg: smps123 {
+++					/* VDD_MPU */
+++					regulator-name = "smps123";
+++					regulator-min-microvolt = < 850000>;
+++					regulator-max-microvolt = <1500000>;
+++					regulator-always-on;
+++					regulator-boot-on;
+++				};
+++
+++				smps45_reg: smps45 {
+++					/* VDD_DSPEVE */
+++					regulator-name = "smps45";
+++					regulator-min-microvolt = < 850000>;
+++					regulator-max-microvolt = <1500000>;
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++
+++				smps6_reg: smps6 {
+++					/* VDD_GPU - over VDD_SMPS6 */
+++					regulator-name = "smps6";
+++					regulator-min-microvolt = <850000>;
+++					regulator-max-microvolt = <1500000>;
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++
+++				smps7_reg: smps7 {
+++					/* CORE_VDD */
+++					regulator-name = "smps7";
+++					regulator-min-microvolt = <850000>;
+++					regulator-max-microvolt = <1500000>;
+++					regulator-always-on;
+++					regulator-boot-on;
+++				};
+++
+++				smps8_reg: smps8 {
+++					/* VDD_IVAHD */
+++					regulator-name = "smps8";
+++					regulator-min-microvolt = < 850000>;
+++					regulator-max-microvolt = <1500000>;
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++
+++				smps9_reg: smps9 {
+++					/* VDDS1V8 */
+++					regulator-name = "smps9";
+++					regulator-min-microvolt = <1800000>;
+++					regulator-max-microvolt = <1800000>;
+++					regulator-always-on;
+++					regulator-boot-on;
+++				};
+++
+++				ldo1_reg: ldo1 {
+++					/* LDO1_OUT --> SDIO  */
+++					regulator-name = "ldo1";
+++					regulator-min-microvolt = <1800000>;
+++					regulator-max-microvolt = <3300000>;
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++
+++				ldo2_reg: ldo2 {
+++					/* VDD_RTCIO */
+++					/* LDO2 -> VDDSHV5, LDO2 also goes to CAN_PHY_3V3 */
+++					regulator-name = "ldo2";
+++					regulator-min-microvolt = <3300000>;
+++					regulator-max-microvolt = <3300000>;
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++
+++				ldo3_reg: ldo3 {
+++					/* VDDA_1V8_PHY */
+++					regulator-name = "ldo3";
+++					regulator-min-microvolt = <1800000>;
+++					regulator-max-microvolt = <1800000>;
+++					regulator-always-on;
+++					regulator-boot-on;
+++				};
+++
+++				ldo9_reg: ldo9 {
+++					/* VDD_RTC */
+++					regulator-name = "ldo9";
+++					regulator-min-microvolt = <1050000>;
+++					regulator-max-microvolt = <1050000>;
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++
+++				ldoln_reg: ldoln {
+++					/* VDDA_1V8_PLL */
+++					regulator-name = "ldoln";
+++					regulator-min-microvolt = <1800000>;
+++					regulator-max-microvolt = <1800000>;
+++					regulator-always-on;
+++					regulator-boot-on;
+++				};
+++
+++				ldousb_reg: ldousb {
+++					/* VDDA_3V_USB: VDDA_USBHS33 */
+++					regulator-name = "ldousb";
+++					regulator-min-microvolt = <3300000>;
+++					regulator-max-microvolt = <3300000>;
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++
+++				/* REGEN1 is unused */
+++
+++				regen2: regen2 {
+++					/* Needed for PMIC internal resources */
+++					regulator-name = "regen2";
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++
+++				/* REGEN3 is unused */
+++
+++				sysen1: sysen1 {
+++					/* PMIC_REGEN_3V3 */
+++					regulator-name = "sysen1";
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++
+++				sysen2: sysen2 {
+++					/* PMIC_REGEN_DDR */
+++					regulator-name = "sysen2";
+++					regulator-boot-on;
+++					regulator-always-on;
+++				};
+++			};
+++		};
+++	};
+++
+++	pcf_lcd: gpio@20 {
+++		compatible = "nxp,pcf8575";
+++		reg = <0x20>;
+++		gpio-controller;
+++		#gpio-cells = <2>;
+++	};
+++
+++	pcf_lcd_tc3587x: gpio@27 {
+++		compatible = "nxp,pcf8575";
+++		reg = <0x27>;
+++		gpio-controller;
+++		#gpio-cells = <2>;
+++	};
+++
+++	pcf_gpio_21: gpio@21 {
+++		compatible = "nxp,pcf8575";
+++		reg = <0x21>;
+++		lines-initial-states = <0x1408>;
+++		gpio-controller;
+++		#gpio-cells = <2>;
+++		interrupt-parent = <&gpio6>;
+++		interrupts = <11 IRQ_TYPE_EDGE_FALLING>;
+++		interrupt-controller;
+++		#interrupt-cells = <2>;
+++	};
+++
+++
+++	tlv320aic3106: tlv320aic3106@18 {
+++		compatible = "ti,tlv320aic3106";
+++		reg = <0x18>;
+++		adc-settle-ms = <40>;
+++		ai3x-micbias-vg = <1>;		/* 2.0V */
+++		status = "okay";
+++
+++		/* Regulators */
+++		AVDD-supply = <&evm_3v3_sw>;
+++		IOVDD-supply = <&evm_3v3_sw>;
+++		DRVDD-supply = <&evm_3v3_sw>;
+++		DVDD-supply = <&aic_dvdd>;
+++	};
+++};
+++
+++
+++i2c_p3_exp: &i2c2 {
+++	status = "okay";
+++	clock-frequency = <400000>;
+++
+++	pcf_hdmi: gpio@26 {
+++		compatible = "nxp,pcf8575";
+++		reg = <0x26>;
+++		lines-initial-states = <0xffeb>;
+++		gpio-controller;
+++		#gpio-cells = <2>;
+++	};
+++
+++	ov10633@37 {
+++		compatible = "ovti,ov10633";
+++		reg = <0x37>;
+++
+++		mux-gpios = <&pcf_hdmi 3	GPIO_ACTIVE_LOW>; /* CAM_FPD_MUX_S0 */
+++		port {
+++			onboardLI: endpoint {
+++				remote-endpoint = <&vin1a>;
+++				hsync-active = <1>;
+++				vsync-active = <1>;
+++				pclk-sample = <0>;
+++			};
+++		};
+++	};
+++
+++	disp_ser: serializer@1b {
+++		status = "disabled";
+++		compatible = "ti,ds90uh925q";
+++		reg = <0x1b>;
+++
+++		#address-cells = <1>;
+++		#size-cells = <0>;
+++		ranges = <0x2c 0x2c>,
+++			<0x1c 0x1c>;
+++
+++		disp_des: deserializer@2c {
+++			compatible = "ti,ds90uh928q";
+++			reg = <0x2c>;
+++			slave-mode;
+++		};
+++
+++		/* TLC chip for LCD panel power and backlight */
+++		fpd_disp: tlc59108@1c {
+++			reg = <0x1c>;
+++			compatible = "ti,tlc59108-fpddisp";
+++			enable-gpios = <&pcf_gpio_21 0 GPIO_ACTIVE_LOW>;
+++			/* P0, SEL_GPMC_AD_VID_S0 */
+++
+++			port@lcd3 {
+++					fpd_in: endpoint {
+++					remote-endpoint = <&dpi_out3>;
+++				};
+++			};
+++		};
+++	};
+++};
+++
+++&i2c3 {
+++	status = "okay";
+++	clock-frequency = <3400000>;
+++};
+++
+++&mcspi1 {
+++	status = "okay";
+++};
+++
+++&mcspi2 {
+++	status = "okay";
+++};
+++
+++&uart1 {
+++	status = "okay";
+++	interrupts-extended = <&gic GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH
+++			       &dra7_pmx_core 0x3e0>;
+++};
+++
+++&uart2 {
+++	status = "okay";
+++};
+++
+++&uart3 {
+++	status = "okay";
+++	gpios = <&pcf_gpio_21 14 GPIO_ACTIVE_LOW>;
+++};
+++
+++&mmc1 {
+++	status = "okay";
+++	pbias-supply = <&pbias_mmc_reg>;
+++	vmmc-supply = <&evm_3v3_sd>;
+++	vmmc_aux-supply = <&ldo1_reg>;
+++	bus-width = <4>;
+++	/*
+++	 * SDCD signal is not being used here - using the fact that GPIO mode
+++	 * is always hardwired.
+++	 */
+++	cd-gpios = <&gpio6 27 0>;
+++	pinctrl-names = "default", "hs", "sdr12", "sdr25", "ddr50", "sdr104";
+++	pinctrl-0 = <&mmc1_pins_default>;
+++	pinctrl-1 = <&mmc1_pins_hs>;
+++	pinctrl-2 = <&mmc1_pins_sdr12>;
+++	pinctrl-3 = <&mmc1_pins_sdr25>;
+++	pinctrl-4 = <&mmc1_pins_ddr50 &mmc1_iodelay_ddr50_conf_sr11>;
+++	pinctrl-5 = <&mmc1_pins_sdr104 &mmc1_iodelay_dummy_conf_sr11>;
+++	sd-uhs-ddr50;
+++	sd-uhs-sdr25;
+++	sd-uhs-sdr12;
+++};
+++
+++&mmc2 {
+++	status = "okay";
+++	vmmc-supply = <&evm_3v3_sw>;
+++	bus-width = <8>;
+++	pinctrl-names = "default", "hs", "ddr_3_3v", "hs200";
+++	pinctrl-0 = <&mmc2_pins_default>;
+++	pinctrl-1 = <&mmc2_pins_hs>;
+++	pinctrl-2 = <&mmc2_pins_ddr_3_3v &mmc2_iodelay_ddr_3_3v_conf_sr11>;
+++	pinctrl-3 = <&mmc2_pins_hs200 &mmc2_iodelay_dummy_conf_sr11>;
+++	mmc-ddr-1_8v;
+++};
+++
+++&mmc4 {
+++	status = "okay";
+++	vmmc-supply = <&vmmcwl_fixed>;
+++	bus-width = <4>;
+++	cap-power-off-card;
+++	keep-power-in-suspend;
+++	ti,non-removable;
+++	pinctrl-names = "default", "hs";
+++	pinctrl-0 = <&mmc4_pins_default &mmc4_iodelay_ds_manual1_conf_sr11>;
+++	pinctrl-1 = <&mmc4_pins_hs &mmc4_iodelay_manual1_conf_sr11>;
+++
+++	#address-cells = <1>;
+++	#size-cells = <0>;
+++	wlcore: wlcore@0 {
+++		compatible = "ti,wlcore";
+++		reg = <2>;
+++		interrupt-parent = <&gpio5>;
+++		interrupts = <7 IRQ_TYPE_LEVEL_HIGH>;
+++	};
+++};
+++
+++&cpu0 {
+++	cpu0-voltdm = <&voltdm_mpu>;
+++	voltage-tolerance = <1>;
+++};
+++
+++&voltdm_mpu {
+++	vdd-supply = <&smps123_reg>;
+++};
+++
+++&voltdm_dspeve {
+++	vdd-supply = <&smps45_reg>;
+++};
+++
+++&voltdm_gpu {
+++	vdd-supply = <&smps6_reg>;
+++};
+++
+++&voltdm_ivahd {
+++	vdd-supply = <&smps8_reg>;
+++};
+++
+++&voltdm_core {
+++	vdd-supply = <&smps7_reg>;
+++};
+++
+++&qspi {
+++	status = "okay";
+++
+++	spi-max-frequency = <64000000>;
+++	m25p80@0 {
+++		compatible = "s25fl256s1";
+++		spi-max-frequency = <64000000>;
+++		reg = <0>;
+++		spi-tx-bus-width = <1>;
+++		spi-rx-bus-width = <4>;
+++		#address-cells = <1>;
+++		#size-cells = <1>;
+++
+++		/* MTD partition table.
+++		 * The ROM checks the first four physical blocks
+++		 * for a valid file to boot and the flash here is
+++		 * 64KiB block size.
+++		 */
+++		partition@0 {
+++			label = "QSPI.SPL";
+++			reg = <0x00000000 0x000010000>;
+++		};
+++		partition@1 {
+++			label = "QSPI.SPL.backup1";
+++			reg = <0x00010000 0x00010000>;
+++		};
+++		partition@2 {
+++			label = "QSPI.SPL.backup2";
+++			reg = <0x00020000 0x00010000>;
+++		};
+++		partition@3 {
+++			label = "QSPI.SPL.backup3";
+++			reg = <0x00030000 0x00010000>;
+++		};
+++		partition@4 {
+++			label = "QSPI.u-boot";
+++			reg = <0x00040000 0x00100000>;
+++		};
+++		partition@5 {
+++			label = "QSPI.u-boot-spl-os";
+++			reg = <0x00140000 0x00080000>;
+++		};
+++		partition@6 {
+++			label = "QSPI.u-boot-env";
+++			reg = <0x001c0000 0x00010000>;
+++		};
+++		partition@7 {
+++			label = "QSPI.u-boot-env.backup1";
+++			reg = <0x001d0000 0x0010000>;
+++		};
+++		partition@8 {
+++			label = "QSPI.kernel";
+++			reg = <0x001e0000 0x0800000>;
+++		};
+++		partition@9 {
+++			label = "QSPI.file-system";
+++			reg = <0x009e0000 0x01620000>;
+++		};
+++	};
+++};
+++
+++&omap_dwc3_1 {
+++	extcon = <&extcon_usb1>;
+++};
+++
+++&omap_dwc3_2 {
+++	extcon = <&extcon_usb2>;
+++};
+++
+++&usb1 {
+++	dr_mode = "otg";
+++};
+++
+++&usb2 {
+++	dr_mode = "host";
+++};
+++
+++&mac {
+++	status = "okay";
+++	dual_emac;
+++	ti,no-idle;
+++};
+++
+++&cpsw_emac0 {
+++	phy_id = <&davinci_mdio>, <2>;
+++	phy-mode = "rgmii";
+++	dual_emac_res_vlan = <1>;
+++};
+++
+++&cpsw_emac1 {
+++	phy_id = <&davinci_mdio>, <3>;
+++	phy-mode = "rgmii";
+++	dual_emac_res_vlan = <2>;
+++};
+++
+++&elm {
+++	status = "okay";
+++};
+++
+++&gpmc {
+++	status = "disabled";
+++	ranges = <0 0 0 0x01000000>;	/* minimum GPMC partition = 16MB */
+++	nand@0,0 {
+++		reg = <0 0 4>;		/* device IO registers */
+++		ti,nand-ecc-opt = "bch8";
+++		ti,elm-id = <&elm>;
+++		nand-bus-width = <16>;
+++		gpmc,device-width = <2>;
+++		gpmc,sync-clk-ps = <0>;
+++		gpmc,cs-on-ns = <0>;
+++		gpmc,cs-rd-off-ns = <80>;
+++		gpmc,cs-wr-off-ns = <80>;
+++		gpmc,adv-on-ns = <0>;
+++		gpmc,adv-rd-off-ns = <60>;
+++		gpmc,adv-wr-off-ns = <60>;
+++		gpmc,we-on-ns = <10>;
+++		gpmc,we-off-ns = <50>;
+++		gpmc,oe-on-ns = <4>;
+++		gpmc,oe-off-ns = <40>;
+++		gpmc,access-ns = <40>;
+++		gpmc,wr-access-ns = <80>;
+++		gpmc,rd-cycle-ns = <80>;
+++		gpmc,wr-cycle-ns = <80>;
+++		gpmc,bus-turnaround-ns = <0>;
+++		gpmc,cycle2cycle-delay-ns = <0>;
+++		gpmc,clk-activation-ns = <0>;
+++		gpmc,wait-monitoring-ns = <0>;
+++		gpmc,wr-data-mux-bus-ns = <0>;
+++		/* MTD partition table */
+++		/* All SPL-* partitions are sized to minimal length
+++		 * which can be independently programmable. For
+++		 * NAND flash this is equal to size of erase-block */
+++		#address-cells = <1>;
+++		#size-cells = <1>;
+++		partition@0 {
+++			label = "NAND.SPL";
+++			reg = <0x00000000 0x000020000>;
+++		};
+++		partition@1 {
+++			label = "NAND.SPL.backup1";
+++			reg = <0x00020000 0x00020000>;
+++		};
+++		partition@2 {
+++			label = "NAND.SPL.backup2";
+++			reg = <0x00040000 0x00020000>;
+++		};
+++		partition@3 {
+++			label = "NAND.SPL.backup3";
+++			reg = <0x00060000 0x00020000>;
+++		};
+++		partition@4 {
+++			label = "NAND.u-boot-spl-os";
+++			reg = <0x00080000 0x00040000>;
+++		};
+++		partition@5 {
+++			label = "NAND.u-boot";
+++			reg = <0x000c0000 0x00100000>;
+++		};
+++		partition@6 {
+++			label = "NAND.u-boot-env";
+++			reg = <0x001c0000 0x00020000>;
+++		};
+++		partition@7 {
+++			label = "NAND.u-boot-env.backup1";
+++			reg = <0x001e0000 0x00020000>;
+++		};
+++		partition@8 {
+++			label = "NAND.kernel";
+++			reg = <0x00200000 0x00800000>;
+++		};
+++		partition@9 {
+++			label = "NAND.file-system";
+++			reg = <0x00a00000 0x0f600000>;
+++		};
+++	};
+++};
+++
+++&gpio7 {
+++	ti,no-reset-on-init;
+++	ti,no-idle-on-init;
+++};
+++
+++&dss {
+++	status = "ok";
+++
+++	vdda_video-supply = <&ldoln_reg>;
+++
+++	ports {
+++		#address-cells = <1>;
+++		#size-cells = <0>;
+++		status = "disabled";
+++
+++		port@lcd3 {
+++			reg = <2>;
+++
+++			dpi_out3: endpoint {
+++				remote-endpoint = <&fpd_in>;
+++				data-lines = <24>;
+++			};
+++		};
+++	};
+++};
+++
+++&hdmi {
+++	status = "ok";
+++	vdda-supply = <&ldo3_reg>;
+++
+++	port {
+++		hdmi_out: endpoint {
+++			remote-endpoint = <&tpd12s015_in>;
+++		};
+++	};
+++};
+++
+++&dcan1 {
+++	status = "ok";
+++	pinctrl-names = "default", "sleep";
+++	pinctrl-0 = <&dcan1_pins_default>;
+++	pinctrl-1 = <&dcan1_pins_sleep>;
+++};
+++
+++&mailbox5 {
+++	status = "okay";
+++	mbox_ipu1_legacy: mbox_ipu1_legacy {
+++		status = "okay";
+++	};
+++	mbox_dsp1_legacy: mbox_dsp1_legacy {
+++		status = "okay";
+++	};
+++};
+++
+++&mailbox6 {
+++	status = "okay";
+++	mbox_ipu2_legacy: mbox_ipu2_legacy {
+++		status = "okay";
+++	};
+++	mbox_dsp2_legacy: mbox_dsp2_legacy {
+++		status = "okay";
+++	};
+++};
+++
+++&mmu0_dsp1 {
+++	status = "okay";
+++};
+++
+++&mmu1_dsp1 {
+++	status = "okay";
+++};
+++
+++&mmu0_dsp2 {
+++	status = "okay";
+++};
+++
+++&mmu1_dsp2 {
+++	status = "okay";
+++};
+++
+++&mmu_ipu1 {
+++	status = "okay";
+++};
+++
+++&mmu_ipu2 {
+++	status = "okay";
+++};
+++
+++&ipu2 {
+++	status = "okay";
+++	memory-region = <&ipu2_cma_pool>;
+++	mboxes = <&mailbox6 &mbox_ipu2_legacy>;
+++	timers = <&timer3>;
+++	watchdog-timers = <&timer4>, <&timer9>;
+++};
+++
+++&ipu1 {
+++	status = "okay";
+++	memory-region = <&ipu1_cma_pool>;
+++	mboxes = <&mailbox5 &mbox_ipu1_legacy>;
+++	timers = <&timer11>;
+++	watchdog-timers = <&timer7>, <&timer8>;
+++};
+++
+++&dsp1 {
+++	status = "okay";
+++	memory-region = <&dsp1_cma_pool>;
+++	mboxes = <&mailbox5 &mbox_dsp1_legacy>;
+++	timers = <&timer5>;
+++	watchdog-timers = <&timer10>;
+++};
+++
+++&dsp2 {
+++	status = "okay";
+++	memory-region = <&dsp2_cma_pool>;
+++	mboxes = <&mailbox6 &mbox_dsp2_legacy>;
+++	timers = <&timer6>;
+++};
+++
+++&atl {
+++	status = "okay";
+++
+++	atl2 {
+++		bws = <DRA7_ATL_WS_MCASP2_FSX>;
+++		aws = <DRA7_ATL_WS_MCASP3_FSX>;
+++	};
+++};
+++
+++&mcasp3 {
+++	fck_parent = "atl_clkin2_ck";
+++
+++	status = "okay";
+++
+++	op-mode = <0>;          /* MCASP_IIS_MODE */
+++	tdm-slots = <2>;
+++	/* 4 serializer */
+++	serial-dir = <  /* 0: INACTIVE, 1: TX, 2: RX */
+++		1 2 0 0
+++	>;
+++	tx-num-evt = <8>;
+++	rx-num-evt = <8>;
+++};
+++
+++&mcasp7 {
+++	#sound-dai-cells = <0>;
+++
+++	status = "okay";
+++
+++	op-mode = <0>;  /* MCASP_IIS_MODE */
+++	tdm-slots = <4>;
+++	/* 4 serializer */
+++	serial-dir = <  /* 0: INACTIVE, 1: TX, 2: RX */
+++		2 1 0 0
+++	>;
+++	tx-num-evt = <8>;
+++	rx-num-evt = <8>;
+++};
+++
+++&mcasp8 {
+++	/* not used for audio. only the AXR2 pin is used as GPIO */
+++	status = "okay";
+++};
+++
+++&usb2_phy1 {
+++	phy-supply = <&ldousb_reg>;
+++};
+++
+++&usb2_phy2 {
+++	phy-supply = <&ldousb_reg>;
+++};
+++
+++&vip1 {
+++	status = "okay";
+++};
+++
+++video_in: &vin1a {
+++	status = "okay";
+++	endpoint@0 {
+++		slave-mode;
+++		remote-endpoint = <&onboardLI>;
+++	};
+++};
+++
+++#include "dra7xx-jamr3.dtsi"
+++
+++&tvp_5158{
+++	mux-gpios = <&pcf_hdmi 3 GPIO_ACTIVE_HIGH>,	/*CAM_FPD_MUX_S0*/
+++			<&pcf_jamr3_21 8 GPIO_ACTIVE_LOW>;	/*SEL_TVP_FPD*/
+++};
++-- 
++1.9.1
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0004-dra7xx-dom0-dts-switch-to-the-dom0-device-tree.patch b/recipes-kernel/linux/linux-kernel-patches/0004-dra7xx-dom0-dts-switch-to-the-dom0-device-tree.patch
+new file mode 100644
+index 0000000..8d409da
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0004-dra7xx-dom0-dts-switch-to-the-dom0-device-tree.patch
+@@ -0,0 +1,756 @@
++From a55738f5f4137bc4b0f05b674a400b713274f075 Mon Sep 17 00:00:00 2001
++From: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Date: Mon, 21 Mar 2016 14:57:19 +0200
++Subject: [PATCH] dra7xx: dom0: dts: switch to the dom0 device tree
++
++Work done:
++ * Removed unused clocks
++ * Changed some interrupt numbers
++
++Change-Id: Idd3fb28d8f09867f84f11dc3586e4d96c0d4e93c
++Signed-off-by: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Signed-off-by: Oleksandr Baglei <oleksandr.baglei@globallogic.com>
++---
++ arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts |   2 +-
++ arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts  |   6 +-
++ arch/arm/boot/dts/dra7-evm-dom0.dts       | 457 +++++++++++++++++++++++++++++-
++ 3 files changed, 457 insertions(+), 8 deletions(-)
++
++diff --git a/arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts b/arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts
++index 5cfc07e..593a92a 100644
++--- a/arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts
+++++ b/arch/arm/boot/dts/dra7-evm-dom0-lcd10.dts
++@@ -6,7 +6,7 @@
++  * published by the Free Software Foundation.
++  */
++ 
++-#include "dra7-evm.dts"
+++#include "dra7-evm-dom0.dts"
++ #include "dra7xx-evm-lcd10.dtsi"
++ 
++ &ldc3001 {
++diff --git a/arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts b/arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts
++index 4ed8ebe..e3a5cd8 100644
++--- a/arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts
+++++ b/arch/arm/boot/dts/dra7-evm-dom0-lcd7.dts
++@@ -6,5 +6,9 @@
++  * published by the Free Software Foundation.
++  */
++ 
++-#include "dra7-evm.dts"
+++#include "dra7-evm-dom0.dts"
++ #include "dra7xx-evm-lcd7.dtsi"
+++
+++&mxt244 {
+++	interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
+++};
++diff --git a/arch/arm/boot/dts/dra7-evm-dom0.dts b/arch/arm/boot/dts/dra7-evm-dom0.dts
++index 181d6e5..210d836 100644
++--- a/arch/arm/boot/dts/dra7-evm-dom0.dts
+++++ b/arch/arm/boot/dts/dra7-evm-dom0.dts
++@@ -16,9 +16,44 @@
++ 	model = "TI DRA742";
++ 	compatible = "ti,dra7-evm", "ti,dra742", "ti,dra74", "ti,dra7";
++ 
+++	chosen {
+++		bootargs = "dom0_mem=512M console=dtuart dtuart=serial0 dom0_max_vcpus=2 bootscrub=0 flask_enforcing=1";
+++		xen,dom0-bootargs = "console=hvc0 earlyprintk omapdrm.num_crtc=2 root=/dev/sda12 rw rootwait rootfstype=ext4 uio_pdrv_genirq.of_id=generic-uio";
+++		modules {
+++			#address-cells = <1>;
+++			#size-cells = <1>;
+++			module@1 {
+++				compatible = "xen,linux-zimage", "xen,multiboot-module";
+++				reg = <0xc0000000 0x02000000>;
+++			};
+++			module@2 {
+++				compatible = "xen,xsm-policy", "xen,multiboot-module";
+++				reg = <0xc3000000 0x10000>;
+++			};
+++		};
+++	};
+++
+++	hypervisor {
+++		compatible = "xen,xen-4.5", "xen,xen";
+++		reg = <0x4b000000 0x20000 0x0 0x0>;
+++		interrupts = <1 15 0xf08>;
+++	};
+++
+++	timer {
+++		clock-frequency = <6144000>;
+++	};
+++
+++	psci {
+++		compatible = "arm,psci";
+++		method = "hvc";
+++		cpu_on = <2>;
+++	};
+++
++ 	memory {
++ 		device_type = "memory";
++-		reg = <0x80000000 0x60000000>; /* 1536 MB */
+++		reg = <0x80000000 0x20000000>, /* 512 MiB */
+++		      <0xA0000000 0x20000000>, /* 512 MiB */
+++		      <0xC0000000 0x20000000>; /* 512 MiB */
++ 	};
++ 
++ 	reserved_mem: reserved-memory {
++@@ -55,6 +90,11 @@
++ 		};
++ 	};
++ 
+++	pmu {
+++		interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
+++			     <GIC_SPI 132 IRQ_TYPE_LEVEL_HIGH>;
+++	};
+++
++ 	extcon_usb1: extcon_usb1 {
++ 		compatible = "linux,extcon-usb-gpio";
++ 		id-gpios = <&pcf_gpio_21 1 GPIO_ACTIVE_HIGH>;
++@@ -195,9 +235,57 @@
++ 	};
++ 
++     ocp {
++-        gpu: gpu@0x56000000 {
++-            gpu0-voltdm = <&voltdm_gpu>;
++-        };
+++		interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>,
+++			     <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+++
+++		sar_memory {
+++			reg = <0x4AE22000 0x8FFF>;
+++		};
+++
+++		axi@0 {
+++			interrupt-map-mask = <>;
+++			interrupt-map = <>;
+++		};
+++
+++		axi@1 {
+++			pcie@51000000 {
+++				interrupts = <0 118 0x4>, <0 122 0x4>;
+++				interrupt-map-mask = <>;
+++				interrupt-map = <>;
+++			};
+++		};
+++
+++		dmm@4e000000 {
+++			interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+++		};
+++
+++		bb2d {
+++			interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+++		};
+++
+++		vpe {
+++			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+++		};
+++
+++		domd_map {
+++			reg = <0x40300000 0x80000>,             /* OCMC_RAM1 */
+++			      <0x40400000 0x100000>,            /* OCMC_RAM2 */
+++			      <0x40500000 0x100000>,            /* OCMC_RAM3 */
+++			      <0x48243000 0x1000>,              /* PRM_MPU */
+++			      <0x48281000 0x1000>,              /* WAKEUPGEN */
+++			      <0x4A002000 0x2000>,              /* CTRL_MODULE_CORE */
+++			      <0x4A0D9000 0x1000>,              /* SMARTREFLEX_MPU */
+++			      <0x4A0DD000 0x1000>,              /* SMARTREFLEX_CORE */
+++			      <0x4A102000 0x1000>,              /* OCP_WP_NOC */
+++			      <0x4A183000 0x1000>,              /* SMARTREFLEX_DSPEVE */
+++			      <0x4AE0C000 0x1000>,              /* CTRL_MODULE_WKUP */
+++			      <0x4C000000 0x1000>,              /* EMIF1, may be not needed */
+++			      <0x4D000000 0x1000>,              /* EMIF2, may be not needed */
+++			      <0x60000000 0x20000000>,          /* TILER */
+++			      <0x4806A000 0x1000>,              /* UART1 (earlyprintk) */
+++			      <0x480B2000 0x1000>,              /* HDQ1W */
+++			      <0x48484000 0x5000>;              /* GMAC_SW */
+++		};
++     };
++ 
++ 	primary_sound: primary_sound {
++@@ -729,9 +817,69 @@
++ 	};
++ };
++ 
+++&gic {
+++	interrupts = <1 9 0xf04>;
+++};
+++
+++&pcie1 {
+++	interrupts = <0 71 0x4>, <0 79 0x4>;
+++	interrupt-map-mask = <>;
+++	interrupt-map = <>;
+++};
+++
+++&bandgap {
+++	interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&sdma {
+++	interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&edma {
+++	interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&gpio1 {
+++	interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&gpio2 {
+++	interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&gpio3 {
+++	interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&gpio4 {
+++	interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&gpio5 {
+++	interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&gpio6 {
+++	interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&gpio7 {
+++	interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&gpio8 {
+++	interrupts = <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
++ &i2c1 {
++ 	status = "okay";
++ 	clock-frequency = <400000>;
+++	interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
++ 
++ 	tps659038: tps659038@58 {
++ 		compatible = "ti,tps659038";
++@@ -924,6 +1072,7 @@
++ i2c_p3_exp: &i2c2 {
++ 	status = "okay";
++ 	clock-frequency = <400000>;
+++	interrupts = <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>;
++ 
++ 	pcf_hdmi: gpio@26 {
++ 		compatible = "nxp,pcf8575";
++@@ -983,33 +1132,39 @@ i2c_p3_exp: &i2c2 {
++ &i2c3 {
++ 	status = "okay";
++ 	clock-frequency = <3400000>;
+++	interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &mcspi1 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &mcspi2 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &uart1 {
++ 	status = "okay";
++-	interrupts-extended = <&gic GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH
++-			       &dra7_pmx_core 0x3e0>;
+++	pinctrl-names = "default";
+++	interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &uart2 {
++ 	status = "okay";
+++	interrupts-extended = <&gic GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &uart3 {
++ 	status = "okay";
++ 	gpios = <&pcf_gpio_21 14 GPIO_ACTIVE_LOW>;
+++	interrupts-extended = <&gic GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &mmc1 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>;
++ 	pbias-supply = <&pbias_mmc_reg>;
++ 	vmmc-supply = <&evm_3v3_sd>;
++ 	vmmc_aux-supply = <&ldo1_reg>;
++@@ -1033,6 +1188,7 @@ i2c_p3_exp: &i2c2 {
++ 
++ &mmc2 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
++ 	vmmc-supply = <&evm_3v3_sw>;
++ 	bus-width = <8>;
++ 	pinctrl-names = "default", "hs", "ddr_3_3v", "hs200";
++@@ -1045,6 +1201,7 @@ i2c_p3_exp: &i2c2 {
++ 
++ &mmc4 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
++ 	vmmc-supply = <&vmmcwl_fixed>;
++ 	bus-width = <4>;
++ 	cap-power-off-card;
++@@ -1064,6 +1221,14 @@ i2c_p3_exp: &i2c2 {
++ 	};
++ };
++ 
+++&pruss1 {
+++	interrupts = <>;
+++};
+++
+++&pruss2 {
+++	interrupts = <>;
+++};
+++
++ &cpu0 {
++ 	cpu0-voltdm = <&voltdm_mpu>;
++ 	voltage-tolerance = <1>;
++@@ -1078,6 +1243,7 @@ i2c_p3_exp: &i2c2 {
++ };
++ 
++ &voltdm_gpu {
+++	status = "disabled";
++ 	vdd-supply = <&smps6_reg>;
++ };
++ 
++@@ -1091,6 +1257,7 @@ i2c_p3_exp: &i2c2 {
++ 
++ &qspi {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
++ 
++ 	spi-max-frequency = <64000000>;
++ 	m25p80@0 {
++@@ -1151,23 +1318,51 @@ i2c_p3_exp: &i2c2 {
++ };
++ 
++ &omap_dwc3_1 {
+++	interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
++ 	extcon = <&extcon_usb1>;
++ };
++ 
++ &omap_dwc3_2 {
+++	interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
++ 	extcon = <&extcon_usb2>;
++ };
++ 
+++&omap_dwc3_3 {
+++	interrupts = <>;
+++};
+++
+++&omap_dwc3_4 {
+++	interrupts = <>;
+++};
+++
+++&usb3 {
+++	interrupts = <>;
+++};
+++
+++&usb4 {
+++	interrupts = <>;
+++};
+++
++ &usb1 {
++ 	dr_mode = "otg";
+++	interrupts = <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &usb2 {
++ 	dr_mode = "host";
+++	interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &mac {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
++ 	dual_emac;
++ 	ti,no-idle;
++ };
++@@ -1186,6 +1381,7 @@ i2c_p3_exp: &i2c2 {
++ 
++ &elm {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &gpmc {
++@@ -1276,6 +1472,10 @@ i2c_p3_exp: &i2c2 {
++ 
++ 	vdda_video-supply = <&ldoln_reg>;
++ 
+++	dispc@58001000 {
+++		interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>;
+++	};
+++
++ 	ports {
++ 		#address-cells = <1>;
++ 		#size-cells = <0>;
++@@ -1294,6 +1494,7 @@ i2c_p3_exp: &i2c2 {
++ 
++ &hdmi {
++ 	status = "ok";
+++	interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
++ 	vdda-supply = <&ldo3_reg>;
++ 
++ 	port {
++@@ -1305,13 +1506,40 @@ i2c_p3_exp: &i2c2 {
++ 
++ &dcan1 {
++ 	status = "ok";
+++	interrupts = <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>;
++ 	pinctrl-names = "default", "sleep";
++ 	pinctrl-0 = <&dcan1_pins_default>;
++ 	pinctrl-1 = <&dcan1_pins_sleep>;
++ };
++ 
+++&dcan2 {
+++	interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&mailbox1 {
+++	interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&mailbox2 {
+++	interrupts = <>;
+++};
+++
+++&mailbox3 {
+++	interrupts = <>;
+++};
+++
+++&mailbox4 {
+++	interrupts = <>;
+++};
+++
++ &mailbox5 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
++ 	mbox_ipu1_legacy: mbox_ipu1_legacy {
++ 		status = "okay";
++ 	};
++@@ -1322,6 +1550,10 @@ i2c_p3_exp: &i2c2 {
++ 
++ &mailbox6 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
++ 	mbox_ipu2_legacy: mbox_ipu2_legacy {
++ 		status = "okay";
++ 	};
++@@ -1330,28 +1562,148 @@ i2c_p3_exp: &i2c2 {
++ 	};
++ };
++ 
+++&mailbox7 {
+++	interrupts = <>;
+++};
+++
+++&mailbox8 {
+++	interrupts = <>;
+++};
+++
+++&mailbox9 {
+++	interrupts = <>;
+++};
+++
+++&mailbox10 {
+++	interrupts = <>;
+++};
+++
+++&mailbox11 {
+++	interrupts = <>;
+++};
+++
+++&mailbox12 {
+++	interrupts = <>;
+++};
+++
+++&mailbox13 {
+++	interrupts = <>;
+++};
+++
+++&timer1 {
+++	interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer2 {
+++	interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer3 {
+++	interrupts = <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer4 {
+++	interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer5 {
+++	interrupts = <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer6 {
+++	interrupts = <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer7 {
+++	interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer8 {
+++	interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer9 {
+++	interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer10 {
+++	interrupts = <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer11 {
+++	interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&timer13 {
+++	interrupts = <>;
+++};
+++
+++&timer14 {
+++	interrupts = <>;
+++};
+++
+++&timer15 {
+++	interrupts = <>;
+++};
+++
+++&timer16 {
+++	interrupts = <>;
+++};
+++
+++&wdt2 {
+++	interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&gpu {
+++	status = "disabled";
+++	interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&qspi {
+++	interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&pcie1_phy {
+++	status = "disabled";
+++};
+++
+++&sata {
+++	interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&rtc {
+++	interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
++ &mmu0_dsp1 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &mmu1_dsp1 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &mmu0_dsp2 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &mmu1_dsp2 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &mmu_ipu1 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &mmu_ipu2 {
++ 	status = "okay";
+++	interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &ipu2 {
++@@ -1394,11 +1746,18 @@ i2c_p3_exp: &i2c2 {
++ 	};
++ };
++ 
+++&crossbar_mpu {
+++	compatible = "";
+++};
+++
++ &mcasp3 {
++ 	fck_parent = "atl_clkin2_ck";
++ 
++ 	status = "okay";
++ 
+++	interrupts = <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>;
+++
++ 	op-mode = <0>;          /* MCASP_IIS_MODE */
++ 	tdm-slots = <2>;
++ 	/* 4 serializer */
++@@ -1409,11 +1768,19 @@ i2c_p3_exp: &i2c2 {
++ 	rx-num-evt = <8>;
++ };
++ 
+++&mcasp6 {
+++	interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
++ &mcasp7 {
++ 	#sound-dai-cells = <0>;
++ 
++ 	status = "okay";
++ 
+++	interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
+++
++ 	op-mode = <0>;  /* MCASP_IIS_MODE */
++ 	tdm-slots = <4>;
++ 	/* 4 serializer */
++@@ -1427,6 +1794,9 @@ i2c_p3_exp: &i2c2 {
++ &mcasp8 {
++ 	/* not used for audio. only the AXR2 pin is used as GPIO */
++ 	status = "okay";
+++
+++	interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ &usb2_phy1 {
++@@ -1437,8 +1807,43 @@ i2c_p3_exp: &i2c2 {
++ 	phy-supply = <&ldousb_reg>;
++ };
++ 
+++&aes1 {
+++	interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&aes2 {
+++	interrupts = <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&des {
+++	interrupts = <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&sham {
+++	interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&rng {
+++	interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
++ &vip1 {
++ 	status = "okay";
+++
+++	interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+++		     <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
+++};
+++
+++&vip2 {
+++	interrupts = <>;
+++};
+++
+++&vip3 {
+++	interrupts = <>;
+++};
+++
+++&cal {
+++	interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++ video_in: &vin1a {
++@@ -1455,3 +1860,43 @@ video_in: &vin1a {
++ 	mux-gpios = <&pcf_hdmi 3 GPIO_ACTIVE_HIGH>,	/*CAM_FPD_MUX_S0*/
++ 			<&pcf_jamr3_21 8 GPIO_ACTIVE_LOW>;	/*SEL_TVP_FPD*/
++ };
+++
+++&dpll_gpu_byp_mux {
+++	compatible = "";
+++};
+++
+++&dpll_gpu_ck {
+++	compatible = "";
+++};
+++
+++&dpll_core_m2_ck {
+++	compatible = "";
+++};
+++
+++&gpu_dclk {
+++	compatible = "";
+++};
+++
+++&clkoutmux0_clk_mux {
+++	clocks = <&sys_clk1_dclk_div>, <&sys_clk2_dclk_div>, <&per_abe_x1_dclk_div>, <&mpu_dclk_div>, <&dsp_gclk_div>, <&iva_dclk>, <&core_dpll_out_dclk_div>, <&emif_phy_dclk_div>, <&gmac_250m_dclk_div>, <&video2_dclk_div>, <&video1_dclk_div>, <&hdmi_dclk_div>, <&func_96m_aon_dclk_div>, <&l3init_480m_dclk_div>, <&usb_otg_dclk_div>, <&sata_dclk_div>, <&pcie2_dclk_div>, <&pcie_dclk_div>, <&emu_dclk_div>, <&secure_32k_dclk_div>, <&eve_dclk_div>;
+++};
+++
+++&clkoutmux1_clk_mux {
+++	clocks = <&sys_clk1_dclk_div>, <&sys_clk2_dclk_div>, <&per_abe_x1_dclk_div>, <&mpu_dclk_div>, <&dsp_gclk_div>, <&iva_dclk>, <&core_dpll_out_dclk_div>, <&emif_phy_dclk_div>, <&gmac_250m_dclk_div>, <&video2_dclk_div>, <&video1_dclk_div>, <&hdmi_dclk_div>, <&func_96m_aon_dclk_div>, <&l3init_480m_dclk_div>, <&usb_otg_dclk_div>, <&sata_dclk_div>, <&pcie2_dclk_div>, <&pcie_dclk_div>, <&emu_dclk_div>, <&secure_32k_dclk_div>, <&eve_dclk_div>;
+++};
+++
+++&clkoutmux2_clk_mux {
+++	clocks = <&sys_clk1_dclk_div>, <&sys_clk2_dclk_div>, <&per_abe_x1_dclk_div>, <&mpu_dclk_div>, <&dsp_gclk_div>, <&iva_dclk>, <&core_dpll_out_dclk_div>, <&emif_phy_dclk_div>, <&gmac_250m_dclk_div>, <&video2_dclk_div>, <&video1_dclk_div>, <&hdmi_dclk_div>, <&func_96m_aon_dclk_div>, <&l3init_480m_dclk_div>, <&usb_otg_dclk_div>, <&sata_dclk_div>, <&pcie2_dclk_div>, <&pcie_dclk_div>, <&emu_dclk_div>, <&secure_32k_dclk_div>, <&eve_dclk_div>;
+++};
+++
+++&gpu_core_gclk_mux {
+++	compatible = "";
+++};
+++
+++&gpu_hyd_gclk_mux {
+++	compatible = "";
+++};
+++
+++&gpu_clkdm {
+++	compatible = "";
+++};
++-- 
++1.9.1
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0005-ARM-OMAP2-Wakeupgen-doesn-t-enable-ES2-PM-mode-under.patch b/recipes-kernel/linux/linux-kernel-patches/0005-ARM-OMAP2-Wakeupgen-doesn-t-enable-ES2-PM-mode-under.patch
+new file mode 100644
+index 0000000..428b7f7
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0005-ARM-OMAP2-Wakeupgen-doesn-t-enable-ES2-PM-mode-under.patch
+@@ -0,0 +1,42 @@
++From 5351c932db29cf806c4b109f807ea4c7a2700f12 Mon Sep 17 00:00:00 2001
++From: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Date: Wed, 14 Jan 2015 16:44:24 +0200
++Subject: [PATCH] ARM: OMAP2+: Wakeupgen: doesn't enable ES2 PM mode under Xen
++
++In case if kernel is running under Xen the smc operations
++are not allowed and this should be done in the u-boot.
++
++Change-Id: Ibc42d736db2d2fe9d1b0aedc6f8116aafa11e47b
++Signed-off-by: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++---
++ arch/arm/mach-omap2/omap-wakeupgen.c | 6 +++++-
++ 1 file changed, 5 insertions(+), 1 deletion(-)
++
++diff --git a/arch/arm/mach-omap2/omap-wakeupgen.c b/arch/arm/mach-omap2/omap-wakeupgen.c
++index 0e68575..95533a2 100644
++--- a/arch/arm/mach-omap2/omap-wakeupgen.c
+++++ b/arch/arm/mach-omap2/omap-wakeupgen.c
++@@ -25,6 +25,7 @@
++ #include <linux/notifier.h>
++ #include <linux/cpu_pm.h>
++ #include <linux/irqchip/arm-gic.h>
+++#include <xen/xen.h>
++ 
++ #include "omap-wakeupgen.h"
++ #include "omap-secure.h"
++@@ -515,8 +516,11 @@ int __init omap_wakeupgen_init(void)
++ 	 *
++ 	 * We do not support ES1 behavior anymore. OMAP5 is assumed to be
++ 	 * ES2.0, and the same is applicable for DRA7.
+++	 *
+++	 * In case if kernel is running under Xen the smc operations are not
+++	 * allowed and this setting should be done in the u-boot
++ 	 */
++-	if (soc_is_omap54xx() || soc_is_dra7xx()) {
+++	if ((soc_is_omap54xx() || soc_is_dra7xx()) && xen_domain()) {
++ 		val = __raw_readl(wakeupgen_base + OMAP_AMBA_IF_MODE);
++ 		val |= BIT(5);
++ 		omap_smc1(OMAP5_MON_AMBA_IF_INDEX, val);
++-- 
++1.9.1
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0006-xen-disabling-CNTFRQ-register-configuration.patch b/recipes-kernel/linux/linux-kernel-patches/0006-xen-disabling-CNTFRQ-register-configuration.patch
+new file mode 100644
+index 0000000..6cc7999
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0006-xen-disabling-CNTFRQ-register-configuration.patch
+@@ -0,0 +1,32 @@
++From 3c7a6adc5eafd936cdb73f493756e4554f07f629 Mon Sep 17 00:00:00 2001
++From: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Date: Tue, 3 Nov 2015 11:37:14 +0200
++Subject: [PATCH] xen: disabling CNTFRQ register configuration
++
++disabling "ARM: OMAP5/DRA7: realtime_counter: Configure CNTFRQ
++register" for virtualized systems
++
++Change-Id: I0511fa35ff8cd1205a12bd6778ca1632408836a8
++Signed-off-by: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Signed-off-by: Oleksandr Baglei <oleksandr.baglei@globallogic.com>
++---
++ arch/arm/mach-omap2/timer.c | 2 ++
++ 1 file changed, 2 insertions(+)
++
++diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
++index d2ddc4a..52d2cbc 100644
++--- a/arch/arm/mach-omap2/timer.c
+++++ b/arch/arm/mach-omap2/timer.c
++@@ -77,7 +77,9 @@ static unsigned long arch_timer_freq;
++ 
++ void set_cntfreq(void)
++ {
+++#ifndef CONFIG_XEN
++ 	omap_smc1(OMAP5_DRA7_MON_SET_CNTFRQ_INDEX, arch_timer_freq);
+++#endif
++ }
++ #endif
++ 
++-- 
++1.9.1
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0007-dra7-dom0-introduce-hardware-data.patch b/recipes-kernel/linux/linux-kernel-patches/0007-dra7-dom0-introduce-hardware-data.patch
+new file mode 100644
+index 0000000..b2d5ea4
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0007-dra7-dom0-introduce-hardware-data.patch
+@@ -0,0 +1,6586 @@
++From 76ff628ab8f0f92f6b4d8e6b602bbb26b0f9b8ca Mon Sep 17 00:00:00 2001
++From: Andrii Tseglytskyi <andrii.tseglytskyi@globallogic.com>
++Date: Thu, 28 May 2015 11:51:44 +0300
++Subject: [PATCH] dra7: dom0: introduce hardware data
++
++Introduced files are copies of the original files.
++
++Change-Id: I8e05044ed54c3019331baa5aee23ceb74820fd28
++Signed-off-by: Andrii Tseglytskyi <andrii.tseglytskyi@globallogic.com>
++Signed-off-by: Oleksandr Baglei <oleksandr.baglei@globallogic.com>
++Signed-off-by: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++---
++ arch/arm/mach-omap2/Makefile                    |   12 +
++ arch/arm/mach-omap2/clockdomains7xx_dom0_data.c |  740 ++++
++ arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c  | 4880 +++++++++++++++++++++++
++ arch/arm/mach-omap2/powerdomains7xx_dom0_data.c |  454 +++
++ drivers/clk/ti/Makefile                         |   11 +-
++ drivers/clk/ti/clk-7xx_dom0.c                   |  400 ++
++ 6 files changed, 6495 insertions(+), 2 deletions(-)
++ create mode 100644 arch/arm/mach-omap2/clockdomains7xx_dom0_data.c
++ create mode 100644 arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c
++ create mode 100644 arch/arm/mach-omap2/powerdomains7xx_dom0_data.c
++ create mode 100644 drivers/clk/ti/clk-7xx_dom0.c
++
++diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
++index 60fabed..0b3d582 100644
++--- a/arch/arm/mach-omap2/Makefile
+++++ b/arch/arm/mach-omap2/Makefile
++@@ -165,7 +165,11 @@ obj-$(CONFIG_SOC_AM43XX)		+= powerdomains43xx_data.o
++ obj-$(CONFIG_SOC_OMAP5)			+= $(powerdomain-common)
++ obj-$(CONFIG_SOC_OMAP5)			+= powerdomains54xx_data.o
++ obj-$(CONFIG_SOC_DRA7XX)		+= $(powerdomain-common)
+++ifeq ($(CONFIG_XEN_DOM0),y)
+++obj-$(CONFIG_SOC_DRA7XX)		+= powerdomains7xx_dom0_data.o
+++else
++ obj-$(CONFIG_SOC_DRA7XX)		+= powerdomains7xx_data.o
+++endif
++ 
++ # PRCM clockdomain control
++ clockdomain-common			+= clockdomain.o
++@@ -185,7 +189,11 @@ obj-$(CONFIG_SOC_AM43XX)		+= clockdomains43xx_data.o
++ obj-$(CONFIG_SOC_OMAP5)			+= $(clockdomain-common)
++ obj-$(CONFIG_SOC_OMAP5)			+= clockdomains54xx_data.o
++ obj-$(CONFIG_SOC_DRA7XX)		+= $(clockdomain-common)
+++ifeq ($(CONFIG_XEN_DOM0),y)
+++obj-$(CONFIG_SOC_DRA7XX)		+= clockdomains7xx_dom0_data.o
+++else
++ obj-$(CONFIG_SOC_DRA7XX)		+= clockdomains7xx_data.o
+++endif
++ 
++ # Clock framework
++ obj-$(CONFIG_ARCH_OMAP2)		+= $(clock-common) clock2xxx.o
++@@ -237,7 +245,11 @@ obj-$(CONFIG_SOC_AM43XX)		+= omap_hwmod_2xxx_3xxx_ipblock_data.o
++ obj-$(CONFIG_SOC_AM43XX)		+= omap_hwmod_33xx_43xx_ipblock_data.o
++ obj-$(CONFIG_ARCH_OMAP4)		+= omap_hwmod_44xx_data.o
++ obj-$(CONFIG_SOC_OMAP5)			+= omap_hwmod_54xx_data.o
+++ifeq ($(CONFIG_XEN_DOM0),y)
+++obj-$(CONFIG_SOC_DRA7XX)		+= omap_hwmod_7xx_dom0_data.o
+++else
++ obj-$(CONFIG_SOC_DRA7XX)		+= omap_hwmod_7xx_data.o
+++endif
++ 
++ # EMU peripherals
++ obj-$(CONFIG_OMAP3_EMU)			+= emu.o
++diff --git a/arch/arm/mach-omap2/clockdomains7xx_dom0_data.c b/arch/arm/mach-omap2/clockdomains7xx_dom0_data.c
++new file mode 100644
++index 0000000..b3cbd09
++--- /dev/null
+++++ b/arch/arm/mach-omap2/clockdomains7xx_dom0_data.c
++@@ -0,0 +1,740 @@
+++/*
+++ * DRA7xx Clock domains framework
+++ *
+++ * Copyright (C) 2009-2013 Texas Instruments, Inc.
+++ * Copyright (C) 2009-2011 Nokia Corporation
+++ *
+++ * Generated by code originally written by:
+++ * Abhijit Pagare (abhijitpagare@ti.com)
+++ * Benoit Cousson (b-cousson@ti.com)
+++ * Paul Walmsley (paul@pwsan.com)
+++ *
+++ * This file is automatically generated from the OMAP hardware databases.
+++ * We respectfully ask that any modifications to this file be coordinated
+++ * with the public linux-omap@vger.kernel.org mailing list and the
+++ * authors above to ensure that the autogeneration scripts are kept
+++ * up-to-date with the file contents.
+++ *
+++ * This program is free software; you can redistribute it and/or modify
+++ * it under the terms of the GNU General Public License version 2 as
+++ * published by the Free Software Foundation.
+++ */
+++
+++#include <linux/kernel.h>
+++#include <linux/io.h>
+++
+++#include "clockdomain.h"
+++#include "cm1_7xx.h"
+++#include "cm2_7xx.h"
+++
+++#include "cm-regbits-7xx.h"
+++#include "prm7xx.h"
+++#include "prcm44xx.h"
+++#include "prcm_mpu7xx.h"
+++
+++/* Static Dependencies for DRA7xx Clock Domains */
+++
+++static struct clkdm_dep cam_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep dma_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "dss_clkdm" },
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "ipu_clkdm" },
+++	{ .clkdm_name = "ipu1_clkdm" },
+++	{ .clkdm_name = "ipu2_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ .clkdm_name = "l3init_clkdm" },
+++	{ .clkdm_name = "l4cfg_clkdm" },
+++	{ .clkdm_name = "l4per_clkdm" },
+++	{ .clkdm_name = "l4per2_clkdm" },
+++	{ .clkdm_name = "l4per3_clkdm" },
+++	{ .clkdm_name = "l4sec_clkdm" },
+++	{ .clkdm_name = "pcie_clkdm" },
+++	{ .clkdm_name = "wkupaon_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep dsp1_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "atl_clkdm" },
+++	{ .clkdm_name = "cam_clkdm" },
+++	{ .clkdm_name = "dsp2_clkdm" },
+++	{ .clkdm_name = "dss_clkdm" },
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve1_clkdm" },
+++	{ .clkdm_name = "eve2_clkdm" },
+++	{ .clkdm_name = "eve3_clkdm" },
+++	{ .clkdm_name = "eve4_clkdm" },
+++	{ .clkdm_name = "gmac_clkdm" },
+++	{ .clkdm_name = "gpu_clkdm" },
+++	{ .clkdm_name = "ipu_clkdm" },
+++	{ .clkdm_name = "ipu1_clkdm" },
+++	{ .clkdm_name = "ipu2_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ .clkdm_name = "l3init_clkdm" },
+++	{ .clkdm_name = "l4per_clkdm" },
+++	{ .clkdm_name = "l4per2_clkdm" },
+++	{ .clkdm_name = "l4per3_clkdm" },
+++	{ .clkdm_name = "l4sec_clkdm" },
+++	{ .clkdm_name = "pcie_clkdm" },
+++	{ .clkdm_name = "vpe_clkdm" },
+++	{ .clkdm_name = "wkupaon_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep dsp2_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "atl_clkdm" },
+++	{ .clkdm_name = "cam_clkdm" },
+++	{ .clkdm_name = "dsp1_clkdm" },
+++	{ .clkdm_name = "dss_clkdm" },
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve1_clkdm" },
+++	{ .clkdm_name = "eve2_clkdm" },
+++	{ .clkdm_name = "eve3_clkdm" },
+++	{ .clkdm_name = "eve4_clkdm" },
+++	{ .clkdm_name = "gmac_clkdm" },
+++	{ .clkdm_name = "gpu_clkdm" },
+++	{ .clkdm_name = "ipu_clkdm" },
+++	{ .clkdm_name = "ipu1_clkdm" },
+++	{ .clkdm_name = "ipu2_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ .clkdm_name = "l3init_clkdm" },
+++	{ .clkdm_name = "l4per_clkdm" },
+++	{ .clkdm_name = "l4per2_clkdm" },
+++	{ .clkdm_name = "l4per3_clkdm" },
+++	{ .clkdm_name = "l4sec_clkdm" },
+++	{ .clkdm_name = "pcie_clkdm" },
+++	{ .clkdm_name = "vpe_clkdm" },
+++	{ .clkdm_name = "wkupaon_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep dss_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep eve1_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve2_clkdm" },
+++	{ .clkdm_name = "eve3_clkdm" },
+++	{ .clkdm_name = "eve4_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep eve2_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve1_clkdm" },
+++	{ .clkdm_name = "eve3_clkdm" },
+++	{ .clkdm_name = "eve4_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep eve3_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve1_clkdm" },
+++	{ .clkdm_name = "eve2_clkdm" },
+++	{ .clkdm_name = "eve4_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep eve4_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve1_clkdm" },
+++	{ .clkdm_name = "eve2_clkdm" },
+++	{ .clkdm_name = "eve3_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep gmac_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "l4per2_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep gpu_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep ipu1_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "atl_clkdm" },
+++	{ .clkdm_name = "dsp1_clkdm" },
+++	{ .clkdm_name = "dsp2_clkdm" },
+++	{ .clkdm_name = "dss_clkdm" },
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve1_clkdm" },
+++	{ .clkdm_name = "eve2_clkdm" },
+++	{ .clkdm_name = "eve3_clkdm" },
+++	{ .clkdm_name = "eve4_clkdm" },
+++	{ .clkdm_name = "gmac_clkdm" },
+++	{ .clkdm_name = "gpu_clkdm" },
+++	{ .clkdm_name = "ipu_clkdm" },
+++	{ .clkdm_name = "ipu2_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ .clkdm_name = "l3init_clkdm" },
+++	{ .clkdm_name = "l3main1_clkdm" },
+++	{ .clkdm_name = "l4cfg_clkdm" },
+++	{ .clkdm_name = "l4per_clkdm" },
+++	{ .clkdm_name = "l4per2_clkdm" },
+++	{ .clkdm_name = "l4per3_clkdm" },
+++	{ .clkdm_name = "l4sec_clkdm" },
+++	{ .clkdm_name = "pcie_clkdm" },
+++	{ .clkdm_name = "vpe_clkdm" },
+++	{ .clkdm_name = "wkupaon_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep ipu2_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "atl_clkdm" },
+++	{ .clkdm_name = "dsp1_clkdm" },
+++	{ .clkdm_name = "dsp2_clkdm" },
+++	{ .clkdm_name = "dss_clkdm" },
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve1_clkdm" },
+++	{ .clkdm_name = "eve2_clkdm" },
+++	{ .clkdm_name = "eve3_clkdm" },
+++	{ .clkdm_name = "eve4_clkdm" },
+++	{ .clkdm_name = "gmac_clkdm" },
+++	{ .clkdm_name = "gpu_clkdm" },
+++	{ .clkdm_name = "ipu_clkdm" },
+++	{ .clkdm_name = "ipu1_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ .clkdm_name = "l3init_clkdm" },
+++	{ .clkdm_name = "l3main1_clkdm" },
+++	{ .clkdm_name = "l4cfg_clkdm" },
+++	{ .clkdm_name = "l4per_clkdm" },
+++	{ .clkdm_name = "l4per2_clkdm" },
+++	{ .clkdm_name = "l4per3_clkdm" },
+++	{ .clkdm_name = "l4sec_clkdm" },
+++	{ .clkdm_name = "pcie_clkdm" },
+++	{ .clkdm_name = "vpe_clkdm" },
+++	{ .clkdm_name = "wkupaon_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep iva_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep l3init_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ .clkdm_name = "l4cfg_clkdm" },
+++	{ .clkdm_name = "l4per_clkdm" },
+++	{ .clkdm_name = "l4per3_clkdm" },
+++	{ .clkdm_name = "l4sec_clkdm" },
+++	{ .clkdm_name = "wkupaon_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep l4per2_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "dsp1_clkdm" },
+++	{ .clkdm_name = "dsp2_clkdm" },
+++	{ .clkdm_name = "ipu1_clkdm" },
+++	{ .clkdm_name = "ipu2_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep l4sec_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "l4per_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep mpu_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "cam_clkdm" },
+++	{ .clkdm_name = "dsp1_clkdm" },
+++	{ .clkdm_name = "dsp2_clkdm" },
+++	{ .clkdm_name = "dss_clkdm" },
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve1_clkdm" },
+++	{ .clkdm_name = "eve2_clkdm" },
+++	{ .clkdm_name = "eve3_clkdm" },
+++	{ .clkdm_name = "eve4_clkdm" },
+++	{ .clkdm_name = "gmac_clkdm" },
+++	{ .clkdm_name = "gpu_clkdm" },
+++	{ .clkdm_name = "ipu_clkdm" },
+++	{ .clkdm_name = "ipu1_clkdm" },
+++	{ .clkdm_name = "ipu2_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ .clkdm_name = "l3init_clkdm" },
+++	{ .clkdm_name = "l3main1_clkdm" },
+++	{ .clkdm_name = "l4cfg_clkdm" },
+++	{ .clkdm_name = "l4per_clkdm" },
+++	{ .clkdm_name = "l4per2_clkdm" },
+++	{ .clkdm_name = "l4per3_clkdm" },
+++	{ .clkdm_name = "l4sec_clkdm" },
+++	{ .clkdm_name = "pcie_clkdm" },
+++	{ .clkdm_name = "vpe_clkdm" },
+++	{ .clkdm_name = "wkupaon_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep pcie_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "atl_clkdm" },
+++	{ .clkdm_name = "cam_clkdm" },
+++	{ .clkdm_name = "dsp1_clkdm" },
+++	{ .clkdm_name = "dsp2_clkdm" },
+++	{ .clkdm_name = "dss_clkdm" },
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "eve1_clkdm" },
+++	{ .clkdm_name = "eve2_clkdm" },
+++	{ .clkdm_name = "eve3_clkdm" },
+++	{ .clkdm_name = "eve4_clkdm" },
+++	{ .clkdm_name = "gmac_clkdm" },
+++	{ .clkdm_name = "gpu_clkdm" },
+++	{ .clkdm_name = "ipu_clkdm" },
+++	{ .clkdm_name = "ipu1_clkdm" },
+++	{ .clkdm_name = "iva_clkdm" },
+++	{ .clkdm_name = "l3init_clkdm" },
+++	{ .clkdm_name = "l4cfg_clkdm" },
+++	{ .clkdm_name = "l4per_clkdm" },
+++	{ .clkdm_name = "l4per2_clkdm" },
+++	{ .clkdm_name = "l4per3_clkdm" },
+++	{ .clkdm_name = "l4sec_clkdm" },
+++	{ .clkdm_name = "vpe_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clkdm_dep vpe_wkup_sleep_deps[] = {
+++	{ .clkdm_name = "emif_clkdm" },
+++	{ .clkdm_name = "l4per3_clkdm" },
+++	{ NULL },
+++};
+++
+++static struct clockdomain l4per3_7xx_clkdm = {
+++	.name		  = "l4per3_clkdm",
+++	.pwrdm		  = { .name = "l4per_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_L4PER_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_L4PER_L4PER3_CDOFFS,
+++	.dep_bit	  = DRA7XX_L4PER3_STATDEP_SHIFT,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain l4per2_7xx_clkdm = {
+++	.name		  = "l4per2_clkdm",
+++	.pwrdm		  = { .name = "l4per_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_L4PER_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_L4PER_L4PER2_CDOFFS,
+++	.dep_bit	  = DRA7XX_L4PER2_STATDEP_SHIFT,
+++	.wkdep_srcs	  = l4per2_wkup_sleep_deps,
+++	.sleepdep_srcs	  = l4per2_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_SWSUP,
+++};
+++
+++static struct clockdomain mpu0_7xx_clkdm = {
+++	.name		  = "mpu0_clkdm",
+++	.pwrdm		  = { .name = "cpu0_pwrdm" },
+++	.prcm_partition	  = DRA7XX_MPU_PRCM_PARTITION,
+++	.cm_inst	  = DRA7XX_MPU_PRCM_CM_C0_INST,
+++	.clkdm_offs	  = DRA7XX_MPU_PRCM_CM_C0_CPU0_CDOFFS,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain iva_7xx_clkdm = {
+++	.name		  = "iva_clkdm",
+++	.pwrdm		  = { .name = "iva_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_IVA_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_IVA_IVA_CDOFFS,
+++	.dep_bit	  = DRA7XX_IVA_STATDEP_SHIFT,
+++	.wkdep_srcs	  = iva_wkup_sleep_deps,
+++	.sleepdep_srcs	  = iva_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain coreaon_7xx_clkdm = {
+++	.name		  = "coreaon_clkdm",
+++	.pwrdm		  = { .name = "coreaon_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_COREAON_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_COREAON_COREAON_CDOFFS,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain ipu1_7xx_clkdm = {
+++	.name		  = "ipu1_clkdm",
+++	.pwrdm		  = { .name = "ipu_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_IPU_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_IPU_IPU1_CDOFFS,
+++	.dep_bit	  = DRA7XX_IPU1_STATDEP_SHIFT,
+++	.wkdep_srcs	  = ipu1_wkup_sleep_deps,
+++	.sleepdep_srcs	  = ipu1_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain ipu2_7xx_clkdm = {
+++	.name		  = "ipu2_clkdm",
+++	.pwrdm		  = { .name = "core_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_CORE_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_CORE_IPU2_CDOFFS,
+++	.dep_bit	  = DRA7XX_IPU2_STATDEP_SHIFT,
+++	.wkdep_srcs	  = ipu2_wkup_sleep_deps,
+++	.sleepdep_srcs	  = ipu2_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain l3init_7xx_clkdm = {
+++	.name		  = "l3init_clkdm",
+++	.pwrdm		  = { .name = "l3init_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_L3INIT_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_L3INIT_L3INIT_CDOFFS,
+++	.dep_bit	  = DRA7XX_L3INIT_STATDEP_SHIFT,
+++	.wkdep_srcs	  = l3init_wkup_sleep_deps,
+++	.sleepdep_srcs	  = l3init_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain l4sec_7xx_clkdm = {
+++	.name		  = "l4sec_clkdm",
+++	.pwrdm		  = { .name = "l4per_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_L4PER_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_L4PER_L4SEC_CDOFFS,
+++	.dep_bit	  = DRA7XX_L4SEC_STATDEP_SHIFT,
+++	.wkdep_srcs	  = l4sec_wkup_sleep_deps,
+++	.sleepdep_srcs	  = l4sec_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_SWSUP,
+++};
+++
+++static struct clockdomain l3main1_7xx_clkdm = {
+++	.name		  = "l3main1_clkdm",
+++	.pwrdm		  = { .name = "core_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_CORE_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_CORE_L3MAIN1_CDOFFS,
+++	.dep_bit	  = DRA7XX_L3MAIN1_STATDEP_SHIFT,
+++	.flags		  = CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain vpe_7xx_clkdm = {
+++	.name		  = "vpe_clkdm",
+++	.pwrdm		  = { .name = "vpe_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_VPE_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_VPE_VPE_CDOFFS,
+++	.dep_bit	  = DRA7XX_VPE_STATDEP_SHIFT,
+++	.wkdep_srcs	  = vpe_wkup_sleep_deps,
+++	.sleepdep_srcs	  = vpe_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain mpu_7xx_clkdm = {
+++	.name		  = "mpu_clkdm",
+++	.pwrdm		  = { .name = "mpu_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_MPU_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_MPU_MPU_CDOFFS,
+++	.wkdep_srcs	  = mpu_wkup_sleep_deps,
+++	.sleepdep_srcs	  = mpu_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain custefuse_7xx_clkdm = {
+++	.name		  = "custefuse_clkdm",
+++	.pwrdm		  = { .name = "custefuse_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_CUSTEFUSE_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_CUSTEFUSE_CUSTEFUSE_CDOFFS,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain ipu_7xx_clkdm = {
+++	.name		  = "ipu_clkdm",
+++	.pwrdm		  = { .name = "ipu_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_IPU_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_IPU_IPU_CDOFFS,
+++	.dep_bit	  = DRA7XX_IPU_STATDEP_SHIFT,
+++	.flags		  = CLKDM_CAN_SWSUP,
+++};
+++
+++static struct clockdomain mpu1_7xx_clkdm = {
+++	.name		  = "mpu1_clkdm",
+++	.pwrdm		  = { .name = "cpu1_pwrdm" },
+++	.prcm_partition	  = DRA7XX_MPU_PRCM_PARTITION,
+++	.cm_inst	  = DRA7XX_MPU_PRCM_CM_C1_INST,
+++	.clkdm_offs	  = DRA7XX_MPU_PRCM_CM_C1_CPU1_CDOFFS,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain gmac_7xx_clkdm = {
+++	.name		  = "gmac_clkdm",
+++	.pwrdm		  = { .name = "l3init_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_L3INIT_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_L3INIT_GMAC_CDOFFS,
+++	.dep_bit	  = DRA7XX_GMAC_STATDEP_SHIFT,
+++	.wkdep_srcs	  = gmac_wkup_sleep_deps,
+++	.sleepdep_srcs	  = gmac_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_SWSUP,
+++};
+++
+++static struct clockdomain l4cfg_7xx_clkdm = {
+++	.name		  = "l4cfg_clkdm",
+++	.pwrdm		  = { .name = "core_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_CORE_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_CORE_L4CFG_CDOFFS,
+++	.dep_bit	  = DRA7XX_L4CFG_STATDEP_SHIFT,
+++	.flags		  = CLKDM_CAN_DISABLE_AUTO,
+++};
+++
+++static struct clockdomain dma_7xx_clkdm = {
+++	.name		  = "dma_clkdm",
+++	.pwrdm		  = { .name = "core_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_CORE_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_CORE_DMA_CDOFFS,
+++	.wkdep_srcs	  = dma_wkup_sleep_deps,
+++	.sleepdep_srcs	  = dma_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain rtc_7xx_clkdm = {
+++	.name		  = "rtc_clkdm",
+++	.pwrdm		  = { .name = "rtc_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_RTC_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_RTC_RTC_CDOFFS,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain pcie_7xx_clkdm = {
+++	.name		  = "pcie_clkdm",
+++	.pwrdm		  = { .name = "l3init_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_L3INIT_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_L3INIT_PCIE_CDOFFS,
+++	.dep_bit	  = DRA7XX_PCIE_STATDEP_SHIFT,
+++	.wkdep_srcs	  = pcie_wkup_sleep_deps,
+++	.sleepdep_srcs	  = pcie_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain atl_7xx_clkdm = {
+++	.name		  = "atl_clkdm",
+++	.pwrdm		  = { .name = "core_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_CORE_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_CORE_ATL_CDOFFS,
+++	.dep_bit	  = DRA7XX_ATL_STATDEP_SHIFT,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain l3instr_7xx_clkdm = {
+++	.name		  = "l3instr_clkdm",
+++	.pwrdm		  = { .name = "core_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_CORE_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_CORE_L3INSTR_CDOFFS,
+++};
+++
+++static struct clockdomain dss_7xx_clkdm = {
+++	.name		  = "dss_clkdm",
+++	.pwrdm		  = { .name = "dss_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_DSS_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_DSS_DSS_CDOFFS,
+++	.dep_bit	  = DRA7XX_DSS_STATDEP_SHIFT,
+++	.wkdep_srcs	  = dss_wkup_sleep_deps,
+++	.sleepdep_srcs	  = dss_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain emif_7xx_clkdm = {
+++	.name		  = "emif_clkdm",
+++	.pwrdm		  = { .name = "core_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_CORE_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_CORE_EMIF_CDOFFS,
+++	.dep_bit	  = DRA7XX_EMIF_STATDEP_SHIFT,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain emu_7xx_clkdm = {
+++	.name		  = "emu_clkdm",
+++	.pwrdm		  = { .name = "emu_pwrdm" },
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.cm_inst	  = DRA7XX_PRM_EMU_CM_INST,
+++	.clkdm_offs	  = DRA7XX_PRM_EMU_CM_EMU_CDOFFS,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_HWSUP,
+++};
+++
+++static struct clockdomain dsp2_7xx_clkdm = {
+++	.name		  = "dsp2_clkdm",
+++	.pwrdm		  = { .name = "dsp2_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_DSP2_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_DSP2_DSP2_CDOFFS,
+++	.dep_bit	  = DRA7XX_DSP2_STATDEP_SHIFT,
+++	.wkdep_srcs	  = dsp2_wkup_sleep_deps,
+++	.sleepdep_srcs	  = dsp2_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain dsp1_7xx_clkdm = {
+++	.name		  = "dsp1_clkdm",
+++	.pwrdm		  = { .name = "dsp1_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_DSP1_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_DSP1_DSP1_CDOFFS,
+++	.dep_bit	  = DRA7XX_DSP1_STATDEP_SHIFT,
+++	.wkdep_srcs	  = dsp1_wkup_sleep_deps,
+++	.sleepdep_srcs	  = dsp1_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain cam_7xx_clkdm = {
+++	.name		  = "cam_clkdm",
+++	.pwrdm		  = { .name = "cam_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_CAM_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_CAM_CAM_CDOFFS,
+++	.dep_bit	  = DRA7XX_CAM_STATDEP_SHIFT,
+++	.wkdep_srcs	  = cam_wkup_sleep_deps,
+++	.sleepdep_srcs	  = cam_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_SWSUP,
+++};
+++
+++static struct clockdomain l4per_7xx_clkdm = {
+++	.name		  = "l4per_clkdm",
+++	.pwrdm		  = { .name = "l4per_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_L4PER_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_L4PER_L4PER_CDOFFS,
+++	.dep_bit	  = DRA7XX_L4PER_STATDEP_SHIFT,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain gpu_7xx_clkdm = {
+++	.name		  = "gpu_clkdm",
+++	.pwrdm		  = { .name = "gpu_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_GPU_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_GPU_GPU_CDOFFS,
+++	.dep_bit	  = DRA7XX_GPU_STATDEP_SHIFT,
+++	.wkdep_srcs	  = gpu_wkup_sleep_deps,
+++	.sleepdep_srcs	  = gpu_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain eve4_7xx_clkdm = {
+++	.name		  = "eve4_clkdm",
+++	.pwrdm		  = { .name = "eve4_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_EVE4_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_EVE4_EVE4_CDOFFS,
+++	.dep_bit	  = DRA7XX_EVE4_STATDEP_SHIFT,
+++	.wkdep_srcs	  = eve4_wkup_sleep_deps,
+++	.sleepdep_srcs	  = eve4_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain eve2_7xx_clkdm = {
+++	.name		  = "eve2_clkdm",
+++	.pwrdm		  = { .name = "eve2_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_EVE2_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_EVE2_EVE2_CDOFFS,
+++	.dep_bit	  = DRA7XX_EVE2_STATDEP_SHIFT,
+++	.wkdep_srcs	  = eve2_wkup_sleep_deps,
+++	.sleepdep_srcs	  = eve2_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain eve3_7xx_clkdm = {
+++	.name		  = "eve3_clkdm",
+++	.pwrdm		  = { .name = "eve3_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_EVE3_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_EVE3_EVE3_CDOFFS,
+++	.dep_bit	  = DRA7XX_EVE3_STATDEP_SHIFT,
+++	.wkdep_srcs	  = eve3_wkup_sleep_deps,
+++	.sleepdep_srcs	  = eve3_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++static struct clockdomain wkupaon_7xx_clkdm = {
+++	.name		  = "wkupaon_clkdm",
+++	.pwrdm		  = { .name = "wkupaon_pwrdm" },
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.cm_inst	  = DRA7XX_PRM_WKUPAON_CM_INST,
+++	.clkdm_offs	  = DRA7XX_PRM_WKUPAON_CM_WKUPAON_CDOFFS,
+++	.dep_bit	  = DRA7XX_WKUPAON_STATDEP_SHIFT,
+++	.flags		  = CLKDM_CAN_FORCE_WAKEUP | CLKDM_CAN_DISABLE_AUTO,
+++};
+++
+++static struct clockdomain eve1_7xx_clkdm = {
+++	.name		  = "eve1_clkdm",
+++	.pwrdm		  = { .name = "eve1_pwrdm" },
+++	.prcm_partition	  = DRA7XX_CM_CORE_AON_PARTITION,
+++	.cm_inst	  = DRA7XX_CM_CORE_AON_EVE1_INST,
+++	.clkdm_offs	  = DRA7XX_CM_CORE_AON_EVE1_EVE1_CDOFFS,
+++	.dep_bit	  = DRA7XX_EVE1_STATDEP_SHIFT,
+++	.wkdep_srcs	  = eve1_wkup_sleep_deps,
+++	.sleepdep_srcs	  = eve1_wkup_sleep_deps,
+++	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+++};
+++
+++/* As clockdomains are added or removed above, this list must also be changed */
+++static struct clockdomain *clockdomains_dra7xx[] __initdata = {
+++	&l4per3_7xx_clkdm,
+++	&l4per2_7xx_clkdm,
+++	&mpu0_7xx_clkdm,
+++	&iva_7xx_clkdm,
+++	&coreaon_7xx_clkdm,
+++	&ipu1_7xx_clkdm,
+++	&ipu2_7xx_clkdm,
+++	&l3init_7xx_clkdm,
+++	&l4sec_7xx_clkdm,
+++	&l3main1_7xx_clkdm,
+++	&vpe_7xx_clkdm,
+++	&mpu_7xx_clkdm,
+++	&custefuse_7xx_clkdm,
+++	&ipu_7xx_clkdm,
+++	&mpu1_7xx_clkdm,
+++	&gmac_7xx_clkdm,
+++	&l4cfg_7xx_clkdm,
+++	&dma_7xx_clkdm,
+++	&rtc_7xx_clkdm,
+++	&pcie_7xx_clkdm,
+++	&atl_7xx_clkdm,
+++	&l3instr_7xx_clkdm,
+++	&dss_7xx_clkdm,
+++	&emif_7xx_clkdm,
+++	&emu_7xx_clkdm,
+++	&dsp2_7xx_clkdm,
+++	&dsp1_7xx_clkdm,
+++	&cam_7xx_clkdm,
+++	&l4per_7xx_clkdm,
+++	&gpu_7xx_clkdm,
+++	&eve4_7xx_clkdm,
+++	&eve2_7xx_clkdm,
+++	&eve3_7xx_clkdm,
+++	&wkupaon_7xx_clkdm,
+++	&eve1_7xx_clkdm,
+++	NULL
+++};
+++
+++void __init dra7xx_clockdomains_init(void)
+++{
+++	clkdm_register_platform_funcs(&omap4_clkdm_operations);
+++	clkdm_register_clkdms(clockdomains_dra7xx);
+++	clkdm_complete_init();
+++}
++diff --git a/arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c b/arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c
++new file mode 100644
++index 0000000..06eb4b7
++--- /dev/null
+++++ b/arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c
++@@ -0,0 +1,4880 @@
+++/*
+++ * Hardware modules present on the DRA7xx chips
+++ *
+++ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com
+++ *
+++ * Paul Walmsley
+++ * Benoit Cousson
+++ *
+++ * This file is automatically generated from the OMAP hardware databases.
+++ * We respectfully ask that any modifications to this file be coordinated
+++ * with the public linux-omap@vger.kernel.org mailing list and the
+++ * authors above to ensure that the autogeneration scripts are kept
+++ * up-to-date with the file contents.
+++ *
+++ * This program is free software; you can redistribute it and/or modify
+++ * it under the terms of the GNU General Public License version 2 as
+++ * published by the Free Software Foundation.
+++ */
+++
+++#include <linux/io.h>
+++#include <linux/platform_data/gpio-omap.h>
+++#include <linux/power/smartreflex.h>
+++#include <linux/i2c-omap.h>
+++
+++#include <linux/omap-dma.h>
+++#include <linux/platform_data/spi-omap2-mcspi.h>
+++#include <linux/platform_data/asoc-ti-mcbsp.h>
+++#include <linux/platform_data/iommu-omap.h>
+++#include <plat/dmtimer.h>
+++
+++#include "omap_hwmod.h"
+++#include "omap_hwmod_common_data.h"
+++#include "cm1_7xx.h"
+++#include "cm2_7xx.h"
+++#include "prm7xx.h"
+++#include "i2c.h"
+++#include "mmc.h"
+++#include "wd_timer.h"
+++#include "soc.h"
+++
+++/* Base offset for all DRA7XX interrupts external to MPUSS */
+++#define DRA7XX_IRQ_GIC_START	32
+++
+++/* Base offset for all DRA7XX dma requests */
+++#define DRA7XX_DMA_REQ_START	1
+++
+++
+++/*
+++ * IP blocks
+++ */
+++
+++/*
+++ * 'dmm' class
+++ * instance(s): dmm
+++ */
+++static struct omap_hwmod_class dra7xx_dmm_hwmod_class = {
+++	.name	= "dmm",
+++};
+++
+++/* dmm */
+++static struct omap_hwmod dra7xx_dmm_hwmod = {
+++	.name		= "dmm",
+++	.class		= &dra7xx_dmm_hwmod_class,
+++	.clkdm_name	= "emif_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_EMIF_DMM_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_EMIF_DMM_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'emif_ocp_fw' class
+++ * instance(s): emif_ocp_fw
+++ */
+++static struct omap_hwmod_class dra7xx_emif_ocp_fw_hwmod_class = {
+++	.name	= "emif_ocp_fw",
+++};
+++
+++/* emif_ocp_fw */
+++static struct omap_hwmod dra7xx_emif_ocp_fw_hwmod = {
+++	.name		= "emif_ocp_fw",
+++	.class		= &dra7xx_emif_ocp_fw_hwmod_class,
+++	.clkdm_name	= "emif_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_EMIF_EMIF_OCP_FW_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_EMIF_EMIF_OCP_FW_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'l3' class
+++ * instance(s): l3_instr, l3_main_1, l3_main_2
+++ */
+++static struct omap_hwmod_class dra7xx_l3_hwmod_class = {
+++	.name	= "l3",
+++};
+++
+++/* l3_instr */
+++static struct omap_hwmod dra7xx_l3_instr_hwmod = {
+++	.name		= "l3_instr",
+++	.class		= &dra7xx_l3_hwmod_class,
+++	.clkdm_name	= "l3instr_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INSTR_L3_INSTR_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INSTR_L3_INSTR_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* l3_main_1 */
+++static struct omap_hwmod dra7xx_l3_main_1_hwmod = {
+++	.name		= "l3_main_1",
+++	.class		= &dra7xx_l3_hwmod_class,
+++	.clkdm_name	= "l3main1_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3MAIN1_L3_MAIN_1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3MAIN1_L3_MAIN_1_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* l3_main_2 */
+++static struct omap_hwmod dra7xx_l3_main_2_hwmod = {
+++	.name		= "l3_main_2",
+++	.class		= &dra7xx_l3_hwmod_class,
+++	.clkdm_name	= "l3instr_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INSTR_L3_MAIN_2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INSTR_L3_MAIN_2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'l4' class
+++ * instance(s): l4_cfg, l4_per1, l4_per2, l4_per3, l4_wkup
+++ */
+++static struct omap_hwmod_class dra7xx_l4_hwmod_class = {
+++	.name	= "l4",
+++};
+++
+++/* l4_cfg */
+++static struct omap_hwmod dra7xx_l4_cfg_hwmod = {
+++	.name		= "l4_cfg",
+++	.class		= &dra7xx_l4_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_L4_CFG_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_L4_CFG_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* l4_per1 */
+++static struct omap_hwmod dra7xx_l4_per1_hwmod = {
+++	.name		= "l4_per1",
+++	.class		= &dra7xx_l4_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_L4_PER1_CLKCTRL_OFFSET,
+++			.flags = HWMOD_OMAP4_NO_CONTEXT_LOSS_BIT,
+++		},
+++	},
+++};
+++
+++/* l4_per2 */
+++static struct omap_hwmod dra7xx_l4_per2_hwmod = {
+++	.name		= "l4_per2",
+++	.class		= &dra7xx_l4_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_L4_PER2_CLKCTRL_OFFSET,
+++			.flags = HWMOD_OMAP4_NO_CONTEXT_LOSS_BIT,
+++		},
+++	},
+++};
+++
+++/* l4_per3 */
+++static struct omap_hwmod dra7xx_l4_per3_hwmod = {
+++	.name		= "l4_per3",
+++	.class		= &dra7xx_l4_hwmod_class,
+++	.clkdm_name	= "l4per3_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER3_L4_PER3_CLKCTRL_OFFSET,
+++			.flags = HWMOD_OMAP4_NO_CONTEXT_LOSS_BIT,
+++		},
+++	},
+++};
+++
+++/* l4_wkup */
+++static struct omap_hwmod dra7xx_l4_wkup_hwmod = {
+++	.name		= "l4_wkup",
+++	.class		= &dra7xx_l4_hwmod_class,
+++	.clkdm_name	= "wkupaon_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_WKUPAON_L4_WKUP_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_WKUPAON_L4_WKUP_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'atl' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class dra7xx_atl_hwmod_class = {
+++	.name	= "atl",
+++};
+++
+++/* atl */
+++static struct omap_hwmod dra7xx_atl_hwmod = {
+++	.name		= "atl",
+++	.class		= &dra7xx_atl_hwmod_class,
+++	.clkdm_name	= "atl_clkdm",
+++	.main_clk	= "atl_gfclk_mux",
+++	.lockdep_class	= HWMOD_LOCKDEP_SUBCLASS_CLASS1,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_ATL_ATL_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_ATL_ATL_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'bb2d' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class dra7xx_bb2d_hwmod_class = {
+++	.name	= "bb2d",
+++};
+++
+++/* bb2d */
+++static struct omap_hwmod dra7xx_bb2d_hwmod = {
+++	.name		= "bb2d",
+++	.class		= &dra7xx_bb2d_hwmod_class,
+++	.clkdm_name	= "dss_clkdm",
+++	.main_clk	= "dpll_core_h24x2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSS_BB2D_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_DSS_BB2D_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'vpe' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_vpe_sysc = {
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_MIDLEMODE | SYSC_HAS_SIDLEMODE),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   MSTANDBY_FORCE | MSTANDBY_NO |
+++			   MSTANDBY_SMART),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_vpe_hwmod_class = {
+++	.name	= "vpe",
+++	.sysc	= &dra7xx_vpe_sysc,
+++};
+++
+++/* vpe */
+++static struct omap_hwmod dra7xx_vpe_hwmod = {
+++	.name		= "vpe",
+++	.class		= &dra7xx_vpe_hwmod_class,
+++	.clkdm_name	= "vpe_clkdm",
+++	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_VPE_VPE_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_VPE_VPE_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'vip' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_vip_sysc = {
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_MIDLEMODE | SYSC_HAS_SIDLEMODE),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   MSTANDBY_FORCE | MSTANDBY_NO |
+++			   MSTANDBY_SMART),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_vip_hwmod_class = {
+++	.name	= "vip",
+++	.sysc	= &dra7xx_vip_sysc,
+++};
+++
+++/* vip1 */
+++static struct omap_hwmod dra7xx_vip1_hwmod = {
+++	.name		= "vip1",
+++	.class		= &dra7xx_vip_hwmod_class,
+++	.clkdm_name	= "cam_clkdm",
+++	.main_clk	= "vip1_gclk_mux",
+++	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_CAM_VIP1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_CAM_VIP1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* vip2 */
+++static struct omap_hwmod dra7xx_vip2_hwmod = {
+++	.name		= "vip2",
+++	.class		= &dra7xx_vip_hwmod_class,
+++	.clkdm_name	= "cam_clkdm",
+++	.main_clk	= "vip2_gclk_mux",
+++	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_CAM_VIP2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_CAM_VIP2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* vip3 */
+++static struct omap_hwmod dra7xx_vip3_hwmod = {
+++	.name		= "vip3",
+++	.class		= &dra7xx_vip_hwmod_class,
+++	.clkdm_name	= "cam_clkdm",
+++	.main_clk	= "vip3_gclk_mux",
+++	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_CAM_VIP3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_CAM_VIP3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'cal' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_cal_sysc = {
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_RESET_STATUS |
+++			   SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   MSTANDBY_FORCE | MSTANDBY_NO),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_cal_hwmod_class = {
+++	.name	= "cal",
+++	.sysc	= &dra7xx_cal_sysc,
+++};
+++
+++/* cal */
+++static struct omap_hwmod dra7xx_cal_hwmod = {
+++	.name		= "cal",
+++	.class		= &dra7xx_cal_hwmod_class,
+++	.clkdm_name	= "cam_clkdm",
+++	.main_clk	= "vip2_gclk_mux",
+++	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_CAM_VIP2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_CAM_VIP2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'counter' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_counter_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= SYSC_HAS_SIDLEMODE,
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_counter_hwmod_class = {
+++	.name	= "counter",
+++	.sysc	= &dra7xx_counter_sysc,
+++};
+++
+++/* counter_32k */
+++static struct omap_hwmod dra7xx_counter_32k_hwmod = {
+++	.name		= "counter_32k",
+++	.class		= &dra7xx_counter_hwmod_class,
+++	.clkdm_name	= "wkupaon_clkdm",
+++	.flags		= HWMOD_SWSUP_SIDLE,
+++	.main_clk	= "wkupaon_iclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_WKUPAON_COUNTER_32K_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_WKUPAON_COUNTER_32K_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'ctrl_module' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class dra7xx_ctrl_module_hwmod_class = {
+++	.name	= "ctrl_module",
+++};
+++
+++/* ctrl_module_wkup */
+++static struct omap_hwmod dra7xx_ctrl_module_wkup_hwmod = {
+++	.name		= "ctrl_module_wkup",
+++	.class		= &dra7xx_ctrl_module_hwmod_class,
+++	.clkdm_name	= "wkupaon_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.flags = HWMOD_OMAP4_NO_CONTEXT_LOSS_BIT,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'gmac' class
+++ * cpsw/gmac sub system
+++ */
+++static struct omap_hwmod_class_sysconfig dra7xx_gmac_sysc = {
+++	.rev_offs	= 0x0,
+++	.sysc_offs	= 0x8,
+++	.syss_offs	= 0x4,
+++	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
+++			   SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | MSTANDBY_FORCE |
+++			   MSTANDBY_NO),
+++	.sysc_fields	= &omap_hwmod_sysc_type3,
+++};
+++
+++static struct omap_hwmod_class dra7xx_gmac_hwmod_class = {
+++	.name		= "gmac",
+++	.sysc		= &dra7xx_gmac_sysc,
+++};
+++
+++static struct omap_hwmod dra7xx_gmac_hwmod = {
+++	.name		= "gmac",
+++	.class		= &dra7xx_gmac_hwmod_class,
+++	.clkdm_name	= "gmac_clkdm",
+++	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
+++	.main_clk	= "dpll_gmac_ck",
+++	.mpu_rt_idx	= 1,
+++	.prcm		= {
+++		.omap4	= {
+++			.clkctrl_offs	= DRA7XX_CM_GMAC_GMAC_CLKCTRL_OFFSET,
+++			.context_offs	= DRA7XX_RM_GMAC_GMAC_CONTEXT_OFFSET,
+++			.modulemode	= MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'mdio' class
+++ */
+++static struct omap_hwmod_class dra7xx_mdio_hwmod_class = {
+++	.name		= "davinci_mdio",
+++};
+++
+++static struct omap_hwmod dra7xx_mdio_hwmod = {
+++	.name		= "davinci_mdio",
+++	.class		= &dra7xx_mdio_hwmod_class,
+++	.clkdm_name	= "gmac_clkdm",
+++	.main_clk	= "dpll_gmac_ck",
+++};
+++
+++/*
+++ * 'dcan' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class dra7xx_dcan_hwmod_class = {
+++	.name	= "dcan",
+++};
+++
+++/* dcan1 */
+++static struct omap_hwmod dra7xx_dcan1_hwmod = {
+++	.name		= "dcan1",
+++	.class		= &dra7xx_dcan_hwmod_class,
+++	.clkdm_name	= "wkupaon_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_WKUPAON_DCAN1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_WKUPAON_DCAN1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* dcan2 */
+++static struct omap_hwmod dra7xx_dcan2_hwmod = {
+++	.name		= "dcan2",
+++	.class		= &dra7xx_dcan_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_DCAN2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_DCAN2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* pwmss  */
+++static struct omap_hwmod_class_sysconfig dra7xx_epwmss_sysc = {
+++	.rev_offs	= 0x0,
+++	.sysc_offs	= 0x4,
+++	.sysc_flags	= SYSC_HAS_SIDLEMODE | SYSC_HAS_RESET_STATUS,
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++struct omap_hwmod_class dra7xx_epwmss_hwmod_class = {
+++	.name		= "epwmss",
+++	.sysc		= &dra7xx_epwmss_sysc,
+++};
+++
+++static struct omap_hwmod_class dra7xx_ecap_hwmod_class = {
+++	.name		= "ecap",
+++};
+++
+++static struct omap_hwmod_class dra7xx_eqep_hwmod_class = {
+++	.name		= "eqep",
+++};
+++
+++struct omap_hwmod_class dra7xx_ehrpwm_hwmod_class = {
+++	.name		= "ehrpwm",
+++};
+++
+++/* epwmss0 */
+++struct omap_hwmod dra7xx_epwmss0_hwmod = {
+++	.name		= "epwmss0",
+++	.class		= &dra7xx_epwmss_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++	.prcm		= {
+++		.omap4	= {
+++			.modulemode	= MODULEMODE_SWCTRL,
+++			.clkctrl_offs	= DRA7XX_CM_L4PER2_PWMSS1_CLKCTRL_OFFSET,
+++			.context_offs	= DRA7XX_RM_L4PER2_PWMSS1_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* ecap0 */
+++struct omap_hwmod dra7xx_ecap0_hwmod = {
+++	.name		= "ecap0",
+++	.class		= &dra7xx_ecap_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++};
+++
+++/* eqep0 */
+++struct omap_hwmod dra7xx_eqep0_hwmod = {
+++	.name		= "eqep0",
+++	.class		= &dra7xx_eqep_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++};
+++
+++/* ehrpwm0 */
+++struct omap_hwmod dra7xx_ehrpwm0_hwmod = {
+++	.name		= "ehrpwm0",
+++	.class		= &dra7xx_ehrpwm_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++};
+++
+++/* epwmss1 */
+++struct omap_hwmod dra7xx_epwmss1_hwmod = {
+++	.name		= "epwmss1",
+++	.class		= &dra7xx_epwmss_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++	.prcm		= {
+++		.omap4	= {
+++			.modulemode	= MODULEMODE_SWCTRL,
+++			.clkctrl_offs	= DRA7XX_CM_L4PER2_PWMSS2_CLKCTRL_OFFSET,
+++			.context_offs	= DRA7XX_RM_L4PER2_PWMSS2_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* ecap1 */
+++struct omap_hwmod dra7xx_ecap1_hwmod = {
+++	.name		= "ecap1",
+++	.class		= &dra7xx_ecap_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++};
+++
+++/* eqep1 */
+++struct omap_hwmod dra7xx_eqep1_hwmod = {
+++	.name		= "eqep1",
+++	.class		= &dra7xx_eqep_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++};
+++
+++/* ehrpwm1 */
+++struct omap_hwmod dra7xx_ehrpwm1_hwmod = {
+++	.name		= "ehrpwm1",
+++	.class		= &dra7xx_ehrpwm_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++};
+++
+++/* epwmss2 */
+++struct omap_hwmod dra7xx_epwmss2_hwmod = {
+++	.name		= "epwmss2",
+++	.class		= &dra7xx_epwmss_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++	.prcm		= {
+++		.omap4	= {
+++			.modulemode	= MODULEMODE_SWCTRL,
+++			.clkctrl_offs	= DRA7XX_CM_L4PER2_PWMSS3_CLKCTRL_OFFSET,
+++			.context_offs	= DRA7XX_RM_L4PER2_PWMSS3_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* ecap2 */
+++struct omap_hwmod dra7xx_ecap2_hwmod = {
+++	.name		= "ecap2",
+++	.class		= &dra7xx_ecap_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++};
+++
+++/* eqep2 */
+++struct omap_hwmod dra7xx_eqep2_hwmod = {
+++	.name		= "eqep2",
+++	.class		= &dra7xx_eqep_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++};
+++
+++/* ehrpwm2 */
+++struct omap_hwmod dra7xx_ehrpwm2_hwmod = {
+++	.name		= "ehrpwm2",
+++	.class		= &dra7xx_ehrpwm_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++};
+++
+++/*
+++ * 'dma' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_dma_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x002c,
+++	.syss_offs	= 0x0028,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_CLOCKACTIVITY |
+++			   SYSC_HAS_EMUFREE | SYSC_HAS_MIDLEMODE |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
+++			   SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP | MSTANDBY_FORCE | MSTANDBY_NO |
+++			   MSTANDBY_SMART | MSTANDBY_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_dma_hwmod_class = {
+++	.name	= "dma",
+++	.sysc	= &dra7xx_dma_sysc,
+++};
+++
+++/* dma dev_attr */
+++static struct omap_dma_dev_attr dma_dev_attr = {
+++	.dev_caps	= RESERVE_CHANNEL | DMA_LINKED_LCH | GLOBAL_PRIORITY |
+++			  IS_CSSA_32 | IS_CDSA_32 | IS_RW_PRIORITY,
+++	.lch_count	= 32,
+++};
+++
+++/* dma_system */
+++static struct omap_hwmod dra7xx_dma_system_hwmod = {
+++	.name		= "dma_system",
+++	.class		= &dra7xx_dma_hwmod_class,
+++	.clkdm_name	= "dma_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DMA_DMA_SYSTEM_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_DMA_DMA_SYSTEM_CONTEXT_OFFSET,
+++		},
+++	},
+++	.dev_attr	= &dma_dev_attr,
+++};
+++
+++/* tpcc */
+++static struct omap_hwmod_class dra7xx_tpcc_hwmod_class = {
+++	.name		= "tpcc",
+++};
+++
+++struct omap_hwmod dra7xx_tpcc_hwmod = {
+++	.name		= "tpcc",
+++	.class		= &dra7xx_tpcc_hwmod_class,
+++	.clkdm_name	= "l3main1_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm		= {
+++		.omap4	= {
+++			.modulemode	= MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* 'tptc' class */
+++static struct omap_hwmod_class dra7xx_tptc_hwmod_class = {
+++	.name		= "tptc",
+++};
+++
+++/* tptc0 */
+++struct omap_hwmod dra7xx_tptc0_hwmod = {
+++	.name		= "tptc0",
+++	.class		= &dra7xx_tptc_hwmod_class,
+++	.clkdm_name	= "l3main1_clkdm",
+++	.flags		= HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+++			  HWMOD_NEEDS_REIDLE,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm		= {
+++		.omap4	= {
+++			.modulemode	= MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* tptc1 */
+++struct omap_hwmod dra7xx_tptc1_hwmod = {
+++	.name		= "tptc1",
+++	.class		= &dra7xx_tptc_hwmod_class,
+++	.clkdm_name	= "l3main1_clkdm",
+++	.flags		= HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+++			  HWMOD_NEEDS_REIDLE,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm		= {
+++		.omap4	= {
+++			.modulemode	= MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* tptc2 */
+++struct omap_hwmod dra7xx_tptc2_hwmod = {
+++	.name		= "tptc2",
+++	.class		= &dra7xx_tptc_hwmod_class,
+++	.clkdm_name	= "l3main1_clkdm",
+++	.flags		= HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+++			  HWMOD_NEEDS_REIDLE,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm		= {
+++		.omap4	= {
+++			.modulemode	= MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'dsp' class
+++ * dsp sub-system
+++ */
+++
+++static struct omap_hwmod_class dra7xx_dsp_hwmod_class = {
+++	.name   = "dsp",
+++};
+++
+++static struct omap_hwmod_rst_info dra7xx_dsp_resets[] = {
+++	{ .name = "dsp", .rst_shift = 0 },
+++};
+++
+++/* dsp1 processor */
+++static struct omap_hwmod dra7xx_dsp1_hwmod = {
+++	.name		= "dsp1",
+++	.class		= &dra7xx_dsp_hwmod_class,
+++	.clkdm_name	= "dsp1_clkdm",
+++	.rst_lines	= dra7xx_dsp_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_dsp_resets),
+++	.main_clk	= "dpll_dsp_m2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSP1_DSP1_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_DSP1_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_DSP1_DSP1_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* dsp2 processor */
+++static struct omap_hwmod dra7xx_dsp2_hwmod = {
+++	.name		= "dsp2",
+++	.class		= &dra7xx_dsp_hwmod_class,
+++	.clkdm_name	= "dsp2_clkdm",
+++	.rst_lines	= dra7xx_dsp_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_dsp_resets),
+++	.main_clk	= "dpll_dsp_m2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSP2_DSP2_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_DSP2_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_DSP2_DSP2_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'dss' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_dss_sysc = {
+++	.rev_offs	= 0x0000,
+++	.syss_offs	= 0x0014,
+++	.sysc_flags	= SYSS_HAS_RESET_STATUS,
+++};
+++
+++static struct omap_hwmod_class dra7xx_dss_hwmod_class = {
+++	.name	= "dss",
+++	.sysc	= &dra7xx_dss_sysc,
+++	.reset	= omap_dss_reset,
+++};
+++
+++/* dss */
+++static struct omap_hwmod_dma_info dra7xx_dss_sdma_reqs[] = {
+++	{ .dma_req = 75 + DRA7XX_DMA_REQ_START },
+++	{ .dma_req = -1 }
+++};
+++
+++static struct omap_hwmod_opt_clk dss_opt_clks[] = {
+++	{ .role = "dss_clk", .clk = "dss_dss_clk" },
+++	{ .role = "hdmi_phy_clk", .clk = "dss_48mhz_clk" },
+++	{ .role = "32khz_clk", .clk = "dss_32khz_clk" },
+++	{ .role = "video2_clk", .clk = "dss_video2_clk" },
+++	{ .role = "video1_clk", .clk = "dss_video1_clk" },
+++	{ .role = "hdmi_clk", .clk = "dss_hdmi_clk" },
+++};
+++
+++static struct omap_hwmod dra7xx_dss_hwmod = {
+++	.name		= "dss_core",
+++	.class		= &dra7xx_dss_hwmod_class,
+++	.clkdm_name	= "dss_clkdm",
+++	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
+++	.sdma_reqs	= dra7xx_dss_sdma_reqs,
+++	.main_clk	= "dss_dss_clk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSS_DSS_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_DSS_DSS_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.opt_clks	= dss_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(dss_opt_clks),
+++};
+++
+++/*
+++ * 'dispc' class
+++ * display controller
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_dispc_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.syss_offs	= 0x0014,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_CLOCKACTIVITY |
+++			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_MIDLEMODE |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
+++			   SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_dispc_hwmod_class = {
+++	.name	= "dispc",
+++	.sysc	= &dra7xx_dispc_sysc,
+++};
+++
+++/* dss_dispc */
+++/* dss_dispc dev_attr */
+++static struct omap_dss_dispc_dev_attr dss_dispc_dev_attr = {
+++	.has_framedonetv_irq	= 1,
+++	.manager_count		= 4,
+++};
+++
+++static struct omap_hwmod dra7xx_dss_dispc_hwmod = {
+++	.name		= "dss_dispc",
+++	.class		= &dra7xx_dispc_hwmod_class,
+++	.clkdm_name	= "dss_clkdm",
+++	.main_clk	= "dss_dss_clk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSS_DSS_CLKCTRL_OFFSET,
+++			.flags = HWMOD_OMAP4_NO_CONTEXT_LOSS_BIT,
+++		},
+++	},
+++	.dev_attr	= &dss_dispc_dev_attr,
+++	.parent_hwmod	= &dra7xx_dss_hwmod,
+++};
+++
+++/*
+++ * 'hdmi' class
+++ * hdmi controller
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_hdmi_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_RESET_STATUS | SYSC_HAS_SIDLEMODE |
+++			   SYSC_HAS_SOFTRESET),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_hdmi_hwmod_class = {
+++	.name	= "hdmi",
+++	.sysc	= &dra7xx_hdmi_sysc,
+++};
+++
+++/* dss_hdmi */
+++
+++static struct omap_hwmod_opt_clk dss_hdmi_opt_clks[] = {
+++	{ .role = "sys_clk", .clk = "dss_hdmi_clk" },
+++};
+++
+++static struct omap_hwmod dra7xx_dss_hdmi_hwmod = {
+++	.name		= "dss_hdmi",
+++	.class		= &dra7xx_hdmi_hwmod_class,
+++	.clkdm_name	= "dss_clkdm",
+++	.main_clk	= "dss_48mhz_clk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSS_DSS_CLKCTRL_OFFSET,
+++			.flags = HWMOD_OMAP4_NO_CONTEXT_LOSS_BIT,
+++		},
+++	},
+++	.opt_clks	= dss_hdmi_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(dss_hdmi_opt_clks),
+++	.parent_hwmod	= &dra7xx_dss_hwmod,
+++};
+++
+++/* AES (the 'P' (public) device) */
+++static struct omap_hwmod_class_sysconfig dra7xx_aes_sysc = {
+++	.rev_offs	= 0x0080,
+++	.sysc_offs	= 0x0084,
+++	.syss_offs	= 0x0088,
+++	.sysc_flags	= SYSS_HAS_RESET_STATUS,
+++};
+++
+++static struct omap_hwmod_class dra7xx_aes_hwmod_class = {
+++	.name	= "aes",
+++	.sysc	= &dra7xx_aes_sysc,
+++	.rev	= 2,
+++};
+++
+++/* AES1 */
+++static struct omap_hwmod dra7xx_aes1_hwmod = {
+++	.name		= "aes1",
+++	.class		= &dra7xx_aes_hwmod_class,
+++	.clkdm_name	= "l4sec_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4SEC_AES1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4SEC_AES1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* AES2 */
+++static struct omap_hwmod dra7xx_aes2_hwmod = {
+++	.name		= "aes2",
+++	.class		= &dra7xx_aes_hwmod_class,
+++	.clkdm_name	= "l4sec_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4SEC_AES2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4SEC_AES2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* sha0 HIB2 (the 'P' (public) device) */
+++static struct omap_hwmod_class_sysconfig dra7xx_sha0_sysc = {
+++	.rev_offs	= 0x100,
+++	.sysc_offs	= 0x110,
+++	.syss_offs	= 0x114,
+++	.sysc_flags	= SYSS_HAS_RESET_STATUS,
+++};
+++
+++static struct omap_hwmod_class dra7xx_sha0_hwmod_class = {
+++	.name		= "sham",
+++	.sysc		= &dra7xx_sha0_sysc,
+++	.rev		= 2,
+++};
+++
+++struct omap_hwmod dra7xx_sha0_hwmod = {
+++	.name		= "sham",
+++	.class		= &dra7xx_sha0_hwmod_class,
+++	.clkdm_name	= "l4sec_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm		= {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4SEC_SHA2MD51_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4SEC_SHA2MD51_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'elm' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_elm_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.syss_offs	= 0x0014,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_CLOCKACTIVITY |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
+++			   SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_elm_hwmod_class = {
+++	.name	= "elm",
+++	.sysc	= &dra7xx_elm_sysc,
+++};
+++
+++/* elm */
+++
+++static struct omap_hwmod dra7xx_elm_hwmod = {
+++	.name		= "elm",
+++	.class		= &dra7xx_elm_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_ELM_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_ELM_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'gpio' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_gpio_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.syss_offs	= 0x0114,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_ENAWAKEUP |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
+++			   SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_gpio_hwmod_class = {
+++	.name	= "gpio",
+++	.sysc	= &dra7xx_gpio_sysc,
+++	.rev	= 2,
+++};
+++
+++/* gpio dev_attr */
+++static struct omap_gpio_dev_attr gpio_dev_attr = {
+++	.bank_width	= 32,
+++	.dbck_flag	= true,
+++};
+++
+++/* gpio1 */
+++static struct omap_hwmod_opt_clk gpio1_opt_clks[] = {
+++	{ .role = "dbclk", .clk = "gpio1_dbclk" },
+++};
+++
+++static struct omap_hwmod dra7xx_gpio1_hwmod = {
+++	.name		= "gpio1",
+++	.class		= &dra7xx_gpio_hwmod_class,
+++	.clkdm_name	= "wkupaon_clkdm",
+++	.main_clk	= "wkupaon_iclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_WKUPAON_GPIO1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_WKUPAON_GPIO1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= gpio1_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(gpio1_opt_clks),
+++	.dev_attr	= &gpio_dev_attr,
+++};
+++
+++/* gpio2 */
+++static struct omap_hwmod_opt_clk gpio2_opt_clks[] = {
+++	{ .role = "dbclk", .clk = "gpio2_dbclk" },
+++};
+++
+++static struct omap_hwmod dra7xx_gpio2_hwmod = {
+++	.name		= "gpio2",
+++	.class		= &dra7xx_gpio_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_GPIO2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_GPIO2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= gpio2_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(gpio2_opt_clks),
+++	.dev_attr	= &gpio_dev_attr,
+++};
+++
+++/* gpio3 */
+++static struct omap_hwmod_opt_clk gpio3_opt_clks[] = {
+++	{ .role = "dbclk", .clk = "gpio3_dbclk" },
+++};
+++
+++static struct omap_hwmod dra7xx_gpio3_hwmod = {
+++	.name		= "gpio3",
+++	.class		= &dra7xx_gpio_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_GPIO3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_GPIO3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= gpio3_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(gpio3_opt_clks),
+++	.dev_attr	= &gpio_dev_attr,
+++};
+++
+++/* gpio4 */
+++static struct omap_hwmod_opt_clk gpio4_opt_clks[] = {
+++	{ .role = "dbclk", .clk = "gpio4_dbclk" },
+++};
+++
+++static struct omap_hwmod dra7xx_gpio4_hwmod = {
+++	.name		= "gpio4",
+++	.class		= &dra7xx_gpio_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_GPIO4_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_GPIO4_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= gpio4_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(gpio4_opt_clks),
+++	.dev_attr	= &gpio_dev_attr,
+++};
+++
+++/* gpio5 */
+++static struct omap_hwmod_opt_clk gpio5_opt_clks[] = {
+++	{ .role = "dbclk", .clk = "gpio5_dbclk" },
+++};
+++
+++static struct omap_hwmod dra7xx_gpio5_hwmod = {
+++	.name		= "gpio5",
+++	.class		= &dra7xx_gpio_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_GPIO5_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_GPIO5_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= gpio5_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(gpio5_opt_clks),
+++	.dev_attr	= &gpio_dev_attr,
+++};
+++
+++/* gpio6 */
+++static struct omap_hwmod_opt_clk gpio6_opt_clks[] = {
+++	{ .role = "dbclk", .clk = "gpio6_dbclk" },
+++};
+++
+++static struct omap_hwmod dra7xx_gpio6_hwmod = {
+++	.name		= "gpio6",
+++	.class		= &dra7xx_gpio_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_GPIO6_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_GPIO6_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= gpio6_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(gpio6_opt_clks),
+++	.dev_attr	= &gpio_dev_attr,
+++};
+++
+++/* gpio7 */
+++static struct omap_hwmod_opt_clk gpio7_opt_clks[] = {
+++	{ .role = "dbclk", .clk = "gpio7_dbclk" },
+++};
+++
+++static struct omap_hwmod dra7xx_gpio7_hwmod = {
+++	.name		= "gpio7",
+++	.class		= &dra7xx_gpio_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_GPIO7_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_GPIO7_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= gpio7_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(gpio7_opt_clks),
+++	.dev_attr	= &gpio_dev_attr,
+++};
+++
+++/* gpio8 */
+++static struct omap_hwmod_opt_clk gpio8_opt_clks[] = {
+++	{ .role = "dbclk", .clk = "gpio8_dbclk" },
+++};
+++
+++static struct omap_hwmod dra7xx_gpio8_hwmod = {
+++	.name		= "gpio8",
+++	.class		= &dra7xx_gpio_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_GPIO8_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_GPIO8_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= gpio8_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(gpio8_opt_clks),
+++	.dev_attr	= &gpio_dev_attr,
+++};
+++
+++/*
+++ * 'gpmc' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_gpmc_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.syss_offs	= 0x0014,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_SIDLEMODE |
+++			   SYSC_HAS_SOFTRESET | SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= SIDLE_FORCE | SIDLE_NO | SIDLE_SMART,
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_gpmc_hwmod_class = {
+++	.name	= "gpmc",
+++	.sysc	= &dra7xx_gpmc_sysc,
+++};
+++
+++/* gpmc */
+++
+++static struct omap_hwmod dra7xx_gpmc_hwmod = {
+++	.name		= "gpmc",
+++	.class		= &dra7xx_gpmc_hwmod_class,
+++	.clkdm_name	= "l3main1_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3MAIN1_GPMC_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3MAIN1_GPMC_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'gpu' class
+++ * 2d/3d graphics accelerator
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_gpu_sysc = {
+++	.rev_offs       = 0x0000,
+++	.sysc_offs      = 0x0010,
+++	.sysc_flags     = (SYSC_HAS_MIDLEMODE | SYSC_HAS_SIDLEMODE),
+++	.idlemodes      = (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP | MSTANDBY_FORCE | MSTANDBY_NO |
+++			   MSTANDBY_SMART | MSTANDBY_SMART_WKUP),
+++	.sysc_fields    = &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_gpu_hwmod_class = {
+++	.name   = "gpu",
+++	.sysc   = &dra7xx_gpu_sysc,
+++};
+++
+++static struct omap_hwmod dra7xx_gpu_hwmod = {
+++	.name           = "gpu",
+++	.class          = &dra7xx_gpu_hwmod_class,
+++	.clkdm_name     = "gpu_clkdm",
+++	.main_clk       = "gpu_core_gclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_GPU_GPU_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_GPU_GPU_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'hdq1w' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_hdq1w_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0014,
+++	.syss_offs	= 0x0018,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_SOFTRESET |
+++			   SYSS_HAS_RESET_STATUS),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_hdq1w_hwmod_class = {
+++	.name	= "hdq1w",
+++	.sysc	= &dra7xx_hdq1w_sysc,
+++};
+++
+++/* hdq1w */
+++
+++static struct omap_hwmod dra7xx_hdq1w_hwmod = {
+++	.name		= "hdq1w",
+++	.class		= &dra7xx_hdq1w_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_INIT_NO_RESET,
+++	.main_clk	= "func_12m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_HDQ1W_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_HDQ1W_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'i2c' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_i2c_sysc = {
+++	.sysc_offs	= 0x0010,
+++	.syss_offs	= 0x0090,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_CLOCKACTIVITY |
+++			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
+++			   SYSC_HAS_SOFTRESET | SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.clockact	= CLOCKACT_TEST_ICLK,
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_i2c_hwmod_class = {
+++	.name	= "i2c",
+++	.sysc	= &dra7xx_i2c_sysc,
+++	.reset	= &omap_i2c_reset,
+++	.rev	= OMAP_I2C_IP_VERSION_2,
+++};
+++
+++/* i2c dev_attr */
+++static struct omap_i2c_dev_attr i2c_dev_attr = {
+++	.flags	= OMAP_I2C_FLAG_BUS_SHIFT_NONE,
+++};
+++
+++/* i2c1 */
+++static struct omap_hwmod dra7xx_i2c1_hwmod = {
+++	.name		= "i2c1",
+++	.class		= &dra7xx_i2c_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_16BIT_REG | HWMOD_SET_DEFAULT_CLOCKACT,
+++	.main_clk	= "func_96m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_I2C1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_I2C1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &i2c_dev_attr,
+++};
+++
+++/* i2c2 */
+++static struct omap_hwmod dra7xx_i2c2_hwmod = {
+++	.name		= "i2c2",
+++	.class		= &dra7xx_i2c_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_16BIT_REG | HWMOD_SET_DEFAULT_CLOCKACT,
+++	.main_clk	= "func_96m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_I2C2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_I2C2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &i2c_dev_attr,
+++};
+++
+++/* i2c3 */
+++static struct omap_hwmod dra7xx_i2c3_hwmod = {
+++	.name		= "i2c3",
+++	.class		= &dra7xx_i2c_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_16BIT_REG | HWMOD_SET_DEFAULT_CLOCKACT,
+++	.main_clk	= "func_96m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_I2C3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_I2C3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &i2c_dev_attr,
+++};
+++
+++/* i2c4 */
+++static struct omap_hwmod dra7xx_i2c4_hwmod = {
+++	.name		= "i2c4",
+++	.class		= &dra7xx_i2c_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.flags		= HWMOD_16BIT_REG | HWMOD_SET_DEFAULT_CLOCKACT,
+++	.main_clk	= "func_96m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_I2C4_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_I2C4_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &i2c_dev_attr,
+++};
+++
+++/* i2c5 */
+++static struct omap_hwmod dra7xx_i2c5_hwmod = {
+++	.name		= "i2c5",
+++	.class		= &dra7xx_i2c_hwmod_class,
+++	.clkdm_name	= "ipu_clkdm",
+++	.flags		= HWMOD_16BIT_REG | HWMOD_SET_DEFAULT_CLOCKACT,
+++	.main_clk	= "func_96m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU_I2C5_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU_I2C5_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &i2c_dev_attr,
+++};
+++
+++/*
+++ * 'ipu' class
+++ * imaging processor unit
+++ */
+++
+++static struct omap_hwmod_class dra7xx_ipu_hwmod_class = {
+++	.name	= "ipu",
+++};
+++
+++static struct omap_hwmod_rst_info dra7xx_ipu_resets[] = {
+++	{ .name = "cpu0", .rst_shift = 0 },
+++	{ .name = "cpu1", .rst_shift = 1 },
+++};
+++
+++/* ipu1 processor */
+++static struct omap_hwmod dra7xx_ipu1_hwmod = {
+++	.name		= "ipu1",
+++	.class		= &dra7xx_ipu_hwmod_class,
+++	.clkdm_name	= "ipu1_clkdm",
+++	.rst_lines	= dra7xx_ipu_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_ipu_resets),
+++	.main_clk	= "ipu1_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU1_IPU1_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_IPU1_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU1_IPU1_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* ipu2 processor */
+++static struct omap_hwmod dra7xx_ipu2_hwmod = {
+++	.name		= "ipu2",
+++	.class		= &dra7xx_ipu_hwmod_class,
+++	.clkdm_name	= "ipu2_clkdm",
+++	.rst_lines	= dra7xx_ipu_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_ipu_resets),
+++	.main_clk	= "dpll_core_h22x2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU2_IPU2_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_IPU2_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU2_IPU2_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'mailbox' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_mailbox_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_RESET_STATUS | SYSC_HAS_SIDLEMODE |
+++			   SYSC_HAS_SOFTRESET),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_mailbox_hwmod_class = {
+++	.name	= "mailbox",
+++	.sysc	= &dra7xx_mailbox_sysc,
+++};
+++
+++/* mailbox1 */
+++static struct omap_hwmod dra7xx_mailbox1_hwmod = {
+++	.name		= "mailbox1",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX1_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox2 */
+++static struct omap_hwmod dra7xx_mailbox2_hwmod = {
+++	.name		= "mailbox2",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX2_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox3 */
+++static struct omap_hwmod dra7xx_mailbox3_hwmod = {
+++	.name		= "mailbox3",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX3_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox4 */
+++static struct omap_hwmod dra7xx_mailbox4_hwmod = {
+++	.name		= "mailbox4",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX4_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX4_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox5 */
+++static struct omap_hwmod dra7xx_mailbox5_hwmod = {
+++	.name		= "mailbox5",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX5_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX5_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox6 */
+++static struct omap_hwmod dra7xx_mailbox6_hwmod = {
+++	.name		= "mailbox6",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX6_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX6_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox7 */
+++static struct omap_hwmod dra7xx_mailbox7_hwmod = {
+++	.name		= "mailbox7",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX7_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX7_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox8 */
+++static struct omap_hwmod dra7xx_mailbox8_hwmod = {
+++	.name		= "mailbox8",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX8_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX8_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox9 */
+++static struct omap_hwmod dra7xx_mailbox9_hwmod = {
+++	.name		= "mailbox9",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX9_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX9_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox10 */
+++static struct omap_hwmod dra7xx_mailbox10_hwmod = {
+++	.name		= "mailbox10",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX10_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX10_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox11 */
+++static struct omap_hwmod dra7xx_mailbox11_hwmod = {
+++	.name		= "mailbox11",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX11_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX11_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox12 */
+++static struct omap_hwmod dra7xx_mailbox12_hwmod = {
+++	.name		= "mailbox12",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX12_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX12_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* mailbox13 */
+++static struct omap_hwmod dra7xx_mailbox13_hwmod = {
+++	.name		= "mailbox13",
+++	.class		= &dra7xx_mailbox_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_MAILBOX13_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_MAILBOX13_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'mcspi' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_mcspi_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_EMUFREE | SYSC_HAS_RESET_STATUS |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_mcspi_hwmod_class = {
+++	.name	= "mcspi",
+++	.sysc	= &dra7xx_mcspi_sysc,
+++	.rev	= OMAP4_MCSPI_REV,
+++};
+++
+++/* mcspi1 */
+++/* mcspi1 dev_attr */
+++static struct omap2_mcspi_dev_attr mcspi1_dev_attr = {
+++	.num_chipselect	= 4,
+++};
+++
+++static struct omap_hwmod dra7xx_mcspi1_hwmod = {
+++	.name		= "mcspi1",
+++	.class		= &dra7xx_mcspi_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "func_48m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_MCSPI1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_MCSPI1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &mcspi1_dev_attr,
+++};
+++
+++/* mcspi2 */
+++/* mcspi2 dev_attr */
+++static struct omap2_mcspi_dev_attr mcspi2_dev_attr = {
+++	.num_chipselect	= 2,
+++};
+++
+++static struct omap_hwmod dra7xx_mcspi2_hwmod = {
+++	.name		= "mcspi2",
+++	.class		= &dra7xx_mcspi_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "func_48m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_MCSPI2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_MCSPI2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &mcspi2_dev_attr,
+++};
+++
+++/* mcspi3 */
+++/* mcspi3 dev_attr */
+++static struct omap2_mcspi_dev_attr mcspi3_dev_attr = {
+++	.num_chipselect	= 2,
+++};
+++
+++static struct omap_hwmod dra7xx_mcspi3_hwmod = {
+++	.name		= "mcspi3",
+++	.class		= &dra7xx_mcspi_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "func_48m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_MCSPI3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_MCSPI3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &mcspi3_dev_attr,
+++};
+++
+++/* mcspi4 */
+++/* mcspi4 dev_attr */
+++static struct omap2_mcspi_dev_attr mcspi4_dev_attr = {
+++	.num_chipselect	= 1,
+++};
+++
+++static struct omap_hwmod dra7xx_mcspi4_hwmod = {
+++	.name		= "mcspi4",
+++	.class		= &dra7xx_mcspi_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "func_48m_fclk",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_MCSPI4_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_MCSPI4_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &mcspi4_dev_attr,
+++};
+++
+++/*
+++ * 'mcasp' class
+++ *
+++ */
+++static struct omap_hwmod_class_sysconfig dra7xx_mcasp_sysc = {
+++	.sysc_offs	= 0x0004,
+++	.sysc_flags	= SYSC_HAS_SIDLEMODE,
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+++	.sysc_fields	= &omap_hwmod_sysc_type3,
+++};
+++
+++static struct omap_hwmod_class dra7xx_mcasp_hwmod_class = {
+++	.name	= "mcasp",
+++	.sysc	= &dra7xx_mcasp_sysc,
+++};
+++
+++/* mcasp2 */
+++static struct omap_hwmod dra7xx_mcasp2_hwmod = {
+++	.name		= "mcasp2",
+++	.class		= &dra7xx_mcasp_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "mcasp2_ahclkx_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_MCASP2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_MCASP2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* mcasp3 */
+++static struct omap_hwmod dra7xx_mcasp3_hwmod = {
+++	.name		= "mcasp3",
+++	.class		= &dra7xx_mcasp_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "mcasp3_ahclkx_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_MCASP3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_MCASP3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* mcasp6 */
+++static struct omap_hwmod dra7xx_mcasp6_hwmod = {
+++	.name		= "mcasp6",
+++	.class		= &dra7xx_mcasp_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "mcasp6_ahclkx_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_MCASP6_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_MCASP6_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* mcasp7 */
+++static struct omap_hwmod dra7xx_mcasp7_hwmod = {
+++	.name		= "mcasp7",
+++	.class		= &dra7xx_mcasp_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "mcasp7_ahclkx_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_MCASP7_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_MCASP7_CONTEXT_OFFSET,
+++			.modulemode = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* mcasp8 */
+++static struct omap_hwmod dra7xx_mcasp8_hwmod = {
+++	.name		= "mcasp8",
+++	.class		= &dra7xx_mcasp_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "mcasp8_ahclkx_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_MCASP8_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_MCASP8_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'mmc' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_mmc_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_EMUFREE | SYSC_HAS_MIDLEMODE |
+++			   SYSC_HAS_RESET_STATUS | SYSC_HAS_SIDLEMODE |
+++			   SYSC_HAS_SOFTRESET),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP | MSTANDBY_FORCE | MSTANDBY_NO |
+++			   MSTANDBY_SMART | MSTANDBY_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_mmc_hwmod_class = {
+++	.name	= "mmc",
+++	.sysc	= &dra7xx_mmc_sysc,
+++};
+++
+++/* mmc1 */
+++static struct omap_hwmod_opt_clk mmc1_opt_clks[] = {
+++	{ .role = "clk32k", .clk = "mmc1_clk32k" },
+++};
+++
+++/* mmc1 dev_attr */
+++static struct omap_mmc_dev_attr mmc1_dev_attr = {
+++	.flags	= OMAP_HSMMC_SUPPORTS_DUAL_VOLT,
+++};
+++
+++static struct omap_hwmod dra7xx_mmc1_hwmod = {
+++	.name		= "mmc1",
+++	.class		= &dra7xx_mmc_hwmod_class,
+++	.clkdm_name	= "l3init_clkdm",
+++	.main_clk	= "mmc1_fclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_MMC1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_MMC1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.opt_clks	= mmc1_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(mmc1_opt_clks),
+++	.dev_attr	= &mmc1_dev_attr,
+++};
+++
+++/* mmc2 */
+++static struct omap_hwmod_opt_clk mmc2_opt_clks[] = {
+++	{ .role = "clk32k", .clk = "mmc2_clk32k" },
+++};
+++
+++static struct omap_hwmod dra7xx_mmc2_hwmod = {
+++	.name		= "mmc2",
+++	.class		= &dra7xx_mmc_hwmod_class,
+++	.clkdm_name	= "l3init_clkdm",
+++	.main_clk	= "mmc2_fclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_MMC2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_MMC2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.opt_clks	= mmc2_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(mmc2_opt_clks),
+++};
+++
+++/* mmc3 */
+++static struct omap_hwmod_opt_clk mmc3_opt_clks[] = {
+++	{ .role = "clk32k", .clk = "mmc3_clk32k" },
+++};
+++
+++static struct omap_hwmod dra7xx_mmc3_hwmod = {
+++	.name		= "mmc3",
+++	.class		= &dra7xx_mmc_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "mmc3_gfclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_MMC3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_MMC3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.opt_clks	= mmc3_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(mmc3_opt_clks),
+++};
+++
+++/* mmc4 */
+++static struct omap_hwmod_opt_clk mmc4_opt_clks[] = {
+++	{ .role = "clk32k", .clk = "mmc4_clk32k" },
+++};
+++
+++static struct omap_hwmod dra7xx_mmc4_hwmod = {
+++	.name		= "mmc4",
+++	.class		= &dra7xx_mmc_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "mmc4_gfclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_MMC4_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_MMC4_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.opt_clks	= mmc4_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(mmc4_opt_clks),
+++};
+++
+++/*
+++ * 'mmu' class
+++ * The memory management unit performs virtual to physical address translation
+++ * for its requestors.
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_mmu_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.syss_offs	= 0x0014,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_CLOCKACTIVITY |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
+++			   SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_mmu_hwmod_class = {
+++	.name = "mmu",
+++	.sysc = &dra7xx_mmu_sysc,
+++};
+++
+++/* DSP MMUs */
+++static struct omap_hwmod_rst_info dra7xx_mmu_dsp_resets[] = {
+++	{ .name = "mmu_cache", .rst_shift = 1 },
+++};
+++
+++/* mmu0 - dsp1 */
+++static struct omap_hwmod dra7xx_mmu0_dsp1_hwmod = {
+++	.name		= "mmu0_dsp1",
+++	.class		= &dra7xx_mmu_hwmod_class,
+++	.clkdm_name	= "dsp1_clkdm",
+++	.rst_lines	= dra7xx_mmu_dsp_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_mmu_dsp_resets),
+++	.main_clk	= "dpll_dsp_m2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSP1_DSP1_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_DSP1_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_DSP1_DSP1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* mmu1 - dsp1 */
+++static struct omap_hwmod dra7xx_mmu1_dsp1_hwmod = {
+++	.name		= "mmu1_dsp1",
+++	.class		= &dra7xx_mmu_hwmod_class,
+++	.clkdm_name	= "dsp1_clkdm",
+++	.rst_lines	= dra7xx_mmu_dsp_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_mmu_dsp_resets),
+++	.main_clk	= "dpll_dsp_m2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSP1_DSP1_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_DSP1_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_DSP1_DSP1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* mmu0 - dsp2 */
+++static struct omap_hwmod dra7xx_mmu0_dsp2_hwmod = {
+++	.name		= "mmu0_dsp2",
+++	.class		= &dra7xx_mmu_hwmod_class,
+++	.clkdm_name	= "dsp2_clkdm",
+++	.rst_lines	= dra7xx_mmu_dsp_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_mmu_dsp_resets),
+++	.main_clk	= "dpll_dsp_m2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSP2_DSP2_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_DSP2_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_DSP2_DSP2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* mmu1 - dsp2 */
+++static struct omap_hwmod dra7xx_mmu1_dsp2_hwmod = {
+++	.name		= "mmu1_dsp2",
+++	.class		= &dra7xx_mmu_hwmod_class,
+++	.clkdm_name	= "dsp2_clkdm",
+++	.rst_lines	= dra7xx_mmu_dsp_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_mmu_dsp_resets),
+++	.main_clk	= "dpll_dsp_m2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_DSP2_DSP2_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_DSP2_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_DSP2_DSP2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* IPU MMUs */
+++static struct omap_hwmod_rst_info dra7xx_mmu_ipu_resets[] = {
+++	{ .name = "mmu_cache", .rst_shift = 2 },
+++};
+++
+++/* mmu ipu1 */
+++static struct omap_hwmod dra7xx_mmu_ipu1_hwmod = {
+++	.name		= "mmu_ipu1",
+++	.class		= &dra7xx_mmu_hwmod_class,
+++	.clkdm_name	= "ipu1_clkdm",
+++	.rst_lines	= dra7xx_mmu_ipu_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_mmu_ipu_resets),
+++	.main_clk	= "ipu1_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU1_IPU1_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_IPU1_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU1_IPU1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* mmu ipu2 */
+++static struct omap_hwmod dra7xx_mmu_ipu2_hwmod = {
+++	.name		= "mmu_ipu2",
+++	.class		= &dra7xx_mmu_hwmod_class,
+++	.clkdm_name	= "ipu2_clkdm",
+++	.rst_lines	= dra7xx_mmu_ipu_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_mmu_ipu_resets),
+++	.main_clk	= "dpll_core_h22x2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU2_IPU2_CLKCTRL_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_IPU2_RSTCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU2_IPU2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'mpu' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class dra7xx_mpu_hwmod_class = {
+++	.name	= "mpu",
+++};
+++
+++/* mpu */
+++static struct omap_hwmod dra7xx_mpu_hwmod = {
+++	.name		= "mpu",
+++	.class		= &dra7xx_mpu_hwmod_class,
+++	.clkdm_name	= "mpu_clkdm",
+++	.flags		= HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET,
+++	.main_clk	= "dpll_mpu_m2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_MPU_MPU_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_MPU_MPU_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'ocp2scp' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_ocp2scp_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.syss_offs	= 0x0014,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_SIDLEMODE |
+++			   SYSC_HAS_SOFTRESET | SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_ocp2scp_hwmod_class = {
+++	.name	= "ocp2scp",
+++	.sysc	= &dra7xx_ocp2scp_sysc,
+++};
+++
+++/* ocp2scp1 */
+++static struct omap_hwmod dra7xx_ocp2scp1_hwmod = {
+++	.name		= "ocp2scp1",
+++	.class		= &dra7xx_ocp2scp_hwmod_class,
+++	.clkdm_name	= "l3init_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_OCP2SCP1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_OCP2SCP1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* ocp2scp3 */
+++static struct omap_hwmod dra7xx_ocp2scp3_hwmod = {
+++	.name		= "ocp2scp3",
+++	.class		= &dra7xx_ocp2scp_hwmod_class,
+++	.clkdm_name	= "l3init_clkdm",
+++	.main_clk	= "l4_root_clk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_OCP2SCP3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_OCP2SCP3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'PCIE' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class dra7xx_pciess_hwmod_class = {
+++	.name	= "pcie",
+++};
+++
+++/* pcie1 */
+++static struct omap_hwmod_rst_info dra7xx_pciess1_resets[] = {
+++	{ .name = "pcie", .rst_shift = 0 },
+++};
+++
+++static struct omap_hwmod dra7xx_pciess1_hwmod = {
+++	.name		= "pcie1",
+++	.class		= &dra7xx_pciess_hwmod_class,
+++	.clkdm_name	= "pcie_clkdm",
+++	.rst_lines	= dra7xx_pciess1_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_pciess1_resets),
+++	.main_clk	= "l4_root_clk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_PCIESS1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_PCIESS1_CONTEXT_OFFSET,
+++			.rstctrl_offs	= DRA7XX_RM_L3INIT_RSTCTRL_OFFSET,
+++			.modulemode	= MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* pcie2 */
+++static struct omap_hwmod_rst_info dra7xx_pciess2_resets[] = {
+++	{ .name = "pcie", .rst_shift = 1 },
+++};
+++
+++static struct omap_hwmod dra7xx_pciess2_hwmod = {
+++	.name		= "pcie2",
+++	.class		= &dra7xx_pciess_hwmod_class,
+++	.clkdm_name	= "pcie_clkdm",
+++	.rst_lines	= dra7xx_pciess2_resets,
+++	.rst_lines_cnt	= ARRAY_SIZE(dra7xx_pciess2_resets),
+++	.main_clk	= "l4_root_clk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_PCIESS2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_PCIESS2_CONTEXT_OFFSET,
+++			.rstctrl_offs = DRA7XX_RM_L3INIT_RSTCTRL_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'pru-icss' class
+++ * Programmable Real-Time Unit and Industrial Communication Subsystem
+++ */
+++static struct omap_hwmod_class dra7xx_pruss_hwmod_class = {
+++	.name	= "pruss",
+++};
+++
+++/* pru-icss1 */
+++static struct omap_hwmod dra7xx_pruss1_hwmod = {
+++	.name		= "pruss1",
+++	.class		= &dra7xx_pruss_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.prcm		= {
+++		.omap4	= {
+++			.clkctrl_offs	= DRA7XX_CM_L4PER2_PRUSS1_CLKCTRL_OFFSET,
+++			.context_offs	= DRA7XX_RM_L4PER2_PRUSS1_CONTEXT_OFFSET,
+++			.modulemode	= MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* pru-icss2 */
+++static struct omap_hwmod dra7xx_pruss2_hwmod = {
+++	.name		= "pruss2",
+++	.class		= &dra7xx_pruss_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.prcm		= {
+++		.omap4	= {
+++			.clkctrl_offs	= DRA7XX_CM_L4PER2_PRUSS2_CLKCTRL_OFFSET,
+++			.context_offs	= DRA7XX_RM_L4PER2_PRUSS2_CONTEXT_OFFSET,
+++			.modulemode	= MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'qspi' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_qspi_sysc = {
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= SYSC_HAS_SIDLEMODE,
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_qspi_hwmod_class = {
+++	.name	= "qspi",
+++	.sysc	= &dra7xx_qspi_sysc,
+++};
+++
+++/* qspi */
+++static struct omap_hwmod dra7xx_qspi_hwmod = {
+++	.name		= "qspi",
+++	.class		= &dra7xx_qspi_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "qspi_gfclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_QSPI_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_QSPI_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'rtcss' class
+++ *
+++ */
+++static struct omap_hwmod_class_sysconfig dra7xx_rtcss_sysc = {
+++	.sysc_offs	= 0x0078,
+++	.sysc_flags	= SYSC_HAS_SIDLEMODE,
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type3,
+++};
+++
+++static struct omap_hwmod_class dra7xx_rtcss_hwmod_class = {
+++	.name	= "rtcss",
+++	.sysc	= &dra7xx_rtcss_sysc,
+++	.reset	= &omap_hwmod_rtc_unlock,
+++};
+++
+++/* rtcss */
+++static struct omap_hwmod dra7xx_rtcss_hwmod = {
+++	.name		= "rtcss",
+++	.class		= &dra7xx_rtcss_hwmod_class,
+++	.clkdm_name	= "rtc_clkdm",
+++	.main_clk	= "sys_32k_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_RTC_RTCSS_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_RTC_RTCSS_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'sata' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_sata_sysc = {
+++	.sysc_offs	= 0x0000,
+++	.sysc_flags	= (SYSC_HAS_MIDLEMODE | SYSC_HAS_SIDLEMODE),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP | MSTANDBY_FORCE | MSTANDBY_NO |
+++			   MSTANDBY_SMART | MSTANDBY_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_sata_hwmod_class = {
+++	.name	= "sata",
+++	.sysc	= &dra7xx_sata_sysc,
+++};
+++
+++/* sata */
+++
+++static struct omap_hwmod dra7xx_sata_hwmod = {
+++	.name		= "sata",
+++	.class		= &dra7xx_sata_hwmod_class,
+++	.clkdm_name	= "l3init_clkdm",
+++	.flags		= HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY,
+++	.main_clk	= "func_48m_fclk",
+++	.mpu_rt_idx	= 1,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_SATA_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_SATA_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'smartreflex' class
+++ *
+++ */
+++
+++/* The IP is not compliant to type1 / type2 scheme */
+++static struct omap_hwmod_sysc_fields omap_hwmod_sysc_type_smartreflex = {
+++	.sidle_shift	= 24,
+++	.enwkup_shift	= 26,
+++};
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_smartreflex_sysc = {
+++	.sysc_offs	= 0x0038,
+++	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type_smartreflex,
+++};
+++
+++static struct omap_hwmod_class dra7xx_smartreflex_hwmod_class = {
+++	.name	= "smartreflex",
+++	.sysc	= &dra7xx_smartreflex_sysc,
+++	.rev	= 2,
+++};
+++
+++/* smartreflex_core */
+++/* smartreflex_core dev_attr */
+++static struct omap_smartreflex_dev_attr smartreflex_core_dev_attr = {
+++	.sensor_voltdm_name	= "core",
+++};
+++
+++static struct omap_hwmod dra7xx_smartreflex_core_hwmod = {
+++	.name		= "smartreflex_core",
+++	.class		= &dra7xx_smartreflex_hwmod_class,
+++	.clkdm_name	= "coreaon_clkdm",
+++	.main_clk	= "wkupaon_iclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_COREAON_SMARTREFLEX_CORE_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_COREAON_SMARTREFLEX_CORE_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &smartreflex_core_dev_attr,
+++};
+++
+++/* smartreflex_mpu */
+++/* smartreflex_mpu dev_attr */
+++static struct omap_smartreflex_dev_attr smartreflex_mpu_dev_attr = {
+++	.sensor_voltdm_name	= "mpu",
+++};
+++
+++static struct omap_hwmod dra7xx_smartreflex_mpu_hwmod = {
+++	.name		= "smartreflex_mpu",
+++	.class		= &dra7xx_smartreflex_hwmod_class,
+++	.clkdm_name	= "coreaon_clkdm",
+++	.main_clk	= "wkupaon_iclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_COREAON_SMARTREFLEX_MPU_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_COREAON_SMARTREFLEX_MPU_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++	.dev_attr	= &smartreflex_mpu_dev_attr,
+++};
+++
+++/*
+++ * 'spinlock' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_spinlock_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.syss_offs	= 0x0014,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_ENAWAKEUP |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
+++			   SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_spinlock_hwmod_class = {
+++	.name	= "spinlock",
+++	.sysc	= &dra7xx_spinlock_sysc,
+++};
+++
+++/* spinlock */
+++static struct omap_hwmod dra7xx_spinlock_hwmod = {
+++	.name		= "spinlock",
+++	.class		= &dra7xx_spinlock_hwmod_class,
+++	.clkdm_name	= "l4cfg_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4CFG_SPINLOCK_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4CFG_SPINLOCK_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'timer' class
+++ *
+++ * This class contains several variants: ['timer_1ms', 'timer_secure',
+++ * 'timer']
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_timer_1ms_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_EMUFREE | SYSC_HAS_RESET_STATUS |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_timer_1ms_hwmod_class = {
+++	.name	= "timer",
+++	.sysc	= &dra7xx_timer_1ms_sysc,
+++};
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_timer_secure_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_EMUFREE | SYSC_HAS_RESET_STATUS |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_timer_secure_hwmod_class = {
+++	.name	= "timer",
+++	.sysc	= &dra7xx_timer_secure_sysc,
+++};
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_timer_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_EMUFREE | SYSC_HAS_RESET_STATUS |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_timer_hwmod_class = {
+++	.name	= "timer",
+++	.sysc	= &dra7xx_timer_sysc,
+++};
+++
+++/* timer1 */
+++static struct omap_hwmod dra7xx_timer1_hwmod = {
+++	.name		= "timer1",
+++	.class		= &dra7xx_timer_1ms_hwmod_class,
+++	.clkdm_name	= "wkupaon_clkdm",
+++	.main_clk	= "timer1_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_WKUPAON_TIMER1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_WKUPAON_TIMER1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer2 */
+++static struct omap_hwmod dra7xx_timer2_hwmod = {
+++	.name		= "timer2",
+++	.class		= &dra7xx_timer_1ms_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "timer2_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_TIMER2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_TIMER2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer3 */
+++static struct omap_hwmod dra7xx_timer3_hwmod = {
+++	.name		= "timer3",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "timer3_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_TIMER3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_TIMER3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer4 */
+++static struct omap_hwmod dra7xx_timer4_hwmod = {
+++	.name		= "timer4",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "timer4_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_TIMER4_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_TIMER4_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer5 */
+++static struct omap_hwmod dra7xx_timer5_hwmod = {
+++	.name		= "timer5",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "ipu_clkdm",
+++	.main_clk	= "timer5_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU_TIMER5_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU_TIMER5_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer6 */
+++static struct omap_hwmod dra7xx_timer6_hwmod = {
+++	.name		= "timer6",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "ipu_clkdm",
+++	.main_clk	= "timer6_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU_TIMER6_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU_TIMER6_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer7 */
+++static struct omap_hwmod dra7xx_timer7_hwmod = {
+++	.name		= "timer7",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "ipu_clkdm",
+++	.main_clk	= "timer7_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU_TIMER7_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU_TIMER7_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer8 */
+++static struct omap_hwmod dra7xx_timer8_hwmod = {
+++	.name		= "timer8",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "ipu_clkdm",
+++	.main_clk	= "timer8_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU_TIMER8_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU_TIMER8_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer9 */
+++static struct omap_hwmod dra7xx_timer9_hwmod = {
+++	.name		= "timer9",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "timer9_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_TIMER9_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_TIMER9_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer10 */
+++static struct omap_hwmod dra7xx_timer10_hwmod = {
+++	.name		= "timer10",
+++	.class		= &dra7xx_timer_1ms_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "timer10_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_TIMER10_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_TIMER10_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer11 */
+++static struct omap_hwmod dra7xx_timer11_hwmod = {
+++	.name		= "timer11",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "timer11_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_TIMER11_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_TIMER11_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer12 */
+++static struct omap_hwmod dra7xx_timer12_hwmod = {
+++	.name		= "timer12",
+++	.class		= &dra7xx_timer_secure_hwmod_class,
+++	.clkdm_name	= "wkupaon_clkdm",
+++	.main_clk	= "secure_32k_clk_src_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_WKUPAON_TIMER12_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_WKUPAON_TIMER12_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* timer13 */
+++static struct omap_hwmod dra7xx_timer13_hwmod = {
+++	.name		= "timer13",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "l4per3_clkdm",
+++	.main_clk	= "timer13_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER3_TIMER13_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER3_TIMER13_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer14 */
+++static struct omap_hwmod dra7xx_timer14_hwmod = {
+++	.name		= "timer14",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "l4per3_clkdm",
+++	.main_clk	= "timer14_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER3_TIMER14_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER3_TIMER14_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer15 */
+++static struct omap_hwmod dra7xx_timer15_hwmod = {
+++	.name		= "timer15",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "l4per3_clkdm",
+++	.main_clk	= "timer15_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER3_TIMER15_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER3_TIMER15_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* timer16 */
+++static struct omap_hwmod dra7xx_timer16_hwmod = {
+++	.name		= "timer16",
+++	.class		= &dra7xx_timer_hwmod_class,
+++	.clkdm_name	= "l4per3_clkdm",
+++	.main_clk	= "timer16_gfclk_mux",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER3_TIMER16_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER3_TIMER16_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'uart' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_uart_sysc = {
+++	.rev_offs	= 0x0050,
+++	.sysc_offs	= 0x0054,
+++	.syss_offs	= 0x0058,
+++	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_ENAWAKEUP |
+++			   SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
+++			   SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_uart_hwmod_class = {
+++	.name	= "uart",
+++	.sysc	= &dra7xx_uart_sysc,
+++};
+++
+++/* uart1 */
+++static struct omap_hwmod dra7xx_uart1_hwmod = {
+++	.name		= "uart1",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "uart1_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT | DEBUG_OMAP2UART1_FLAGS,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_UART1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_UART1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* uart2 */
+++static struct omap_hwmod dra7xx_uart2_hwmod = {
+++	.name		= "uart2",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "uart2_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_UART2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_UART2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* uart3 */
+++static struct omap_hwmod dra7xx_uart3_hwmod = {
+++	.name		= "uart3",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "uart3_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT | DEBUG_OMAP4UART3_FLAGS,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_UART3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_UART3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* uart4 */
+++static struct omap_hwmod dra7xx_uart4_hwmod = {
+++	.name		= "uart4",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "uart4_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT | DEBUG_OMAP4UART4_FLAGS,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_UART4_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_UART4_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* uart5 */
+++static struct omap_hwmod dra7xx_uart5_hwmod = {
+++	.name		= "uart5",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "l4per_clkdm",
+++	.main_clk	= "uart5_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER_UART5_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER_UART5_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* uart6 */
+++static struct omap_hwmod dra7xx_uart6_hwmod = {
+++	.name		= "uart6",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "ipu_clkdm",
+++	.main_clk	= "uart6_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_IPU_UART6_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_IPU_UART6_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* uart7 */
+++static struct omap_hwmod dra7xx_uart7_hwmod = {
+++	.name		= "uart7",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "uart7_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_UART7_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_UART7_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* uart8 */
+++static struct omap_hwmod dra7xx_uart8_hwmod = {
+++	.name		= "uart8",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "uart8_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_UART8_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_UART8_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* uart9 */
+++static struct omap_hwmod dra7xx_uart9_hwmod = {
+++	.name		= "uart9",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "l4per2_clkdm",
+++	.main_clk	= "uart9_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4PER2_UART9_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4PER2_UART9_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* uart10 */
+++static struct omap_hwmod dra7xx_uart10_hwmod = {
+++	.name		= "uart10",
+++	.class		= &dra7xx_uart_hwmod_class,
+++	.clkdm_name	= "wkupaon_clkdm",
+++	.main_clk	= "uart10_gfclk_mux",
+++	.flags		= HWMOD_SWSUP_SIDLE_ACT,
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_WKUPAON_UART10_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_WKUPAON_UART10_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++/* DES (the 'P' (public) device) */
+++static struct omap_hwmod_class_sysconfig dra7xx_des_sysc = {
+++	.rev_offs	= 0x0030,
+++	.sysc_offs	= 0x0034,
+++	.syss_offs	= 0x0038,
+++	.sysc_flags	= SYSS_HAS_RESET_STATUS,
+++};
+++
+++static struct omap_hwmod_class dra7xx_des_hwmod_class = {
+++	.name	= "des",
+++	.sysc	= &dra7xx_des_sysc,
+++};
+++
+++/* DES */
+++static struct omap_hwmod dra7xx_des_hwmod = {
+++	.name		= "des",
+++	.class		= &dra7xx_des_hwmod_class,
+++	.clkdm_name	= "l4sec_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4SEC_DES3DES_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4SEC_DES3DES_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* rng */
+++static struct omap_hwmod_class_sysconfig dra7xx_rng_sysc = {
+++	.rev_offs       = 0x1fe0,
+++	.sysc_offs      = 0x1fe4,
+++	.sysc_flags     = SYSC_HAS_AUTOIDLE | SYSC_HAS_SIDLEMODE,
+++	.idlemodes      = SIDLE_FORCE | SIDLE_NO,
+++	.sysc_fields    = &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_rng_hwmod_class = {
+++	.name           = "rng",
+++	.sysc           = &dra7xx_rng_sysc,
+++};
+++
+++static struct omap_hwmod dra7xx_rng_hwmod = {
+++	.name           = "rng",
+++	.class          = &dra7xx_rng_hwmod_class,
+++	.flags		= HWMOD_SWSUP_SIDLE,
+++	.clkdm_name     = "l4sec_clkdm",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L4SEC_RNG_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L4SEC_RNG_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'usb_otg_ss' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_usb_otg_ss_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.sysc_flags	= (SYSC_HAS_DMADISABLE | SYSC_HAS_MIDLEMODE |
+++			   SYSC_HAS_SIDLEMODE),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP | MSTANDBY_FORCE | MSTANDBY_NO |
+++			   MSTANDBY_SMART | MSTANDBY_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type2,
+++};
+++
+++static struct omap_hwmod_class dra7xx_usb_otg_ss_hwmod_class = {
+++	.name	= "usb_otg_ss",
+++	.sysc	= &dra7xx_usb_otg_ss_sysc,
+++};
+++
+++/* usb_otg_ss1 */
+++static struct omap_hwmod_opt_clk usb_otg_ss1_opt_clks[] = {
+++	{ .role = "refclk960m", .clk = "usb_otg_ss1_refclk960m" },
+++};
+++
+++static struct omap_hwmod dra7xx_usb_otg_ss1_hwmod = {
+++	.name		= "usb_otg_ss1",
+++	.class		= &dra7xx_usb_otg_ss_hwmod_class,
+++	.clkdm_name	= "l3init_clkdm",
+++	.main_clk	= "dpll_core_h13x2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_USB_OTG_SS1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_USB_OTG_SS1_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= usb_otg_ss1_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(usb_otg_ss1_opt_clks),
+++};
+++
+++/* usb_otg_ss2 */
+++static struct omap_hwmod_opt_clk usb_otg_ss2_opt_clks[] = {
+++	{ .role = "refclk960m", .clk = "usb_otg_ss2_refclk960m" },
+++};
+++
+++static struct omap_hwmod dra7xx_usb_otg_ss2_hwmod = {
+++	.name		= "usb_otg_ss2",
+++	.class		= &dra7xx_usb_otg_ss_hwmod_class,
+++	.clkdm_name	= "l3init_clkdm",
+++	.main_clk	= "dpll_core_h13x2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_USB_OTG_SS2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_USB_OTG_SS2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++	.opt_clks	= usb_otg_ss2_opt_clks,
+++	.opt_clks_cnt	= ARRAY_SIZE(usb_otg_ss2_opt_clks),
+++};
+++
+++/* usb_otg_ss3 */
+++static struct omap_hwmod dra7xx_usb_otg_ss3_hwmod = {
+++	.name		= "usb_otg_ss3",
+++	.class		= &dra7xx_usb_otg_ss_hwmod_class,
+++	.clkdm_name	= "l3init_clkdm",
+++	.main_clk	= "dpll_core_h13x2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_USB_OTG_SS3_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_USB_OTG_SS3_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/* usb_otg_ss4 */
+++static struct omap_hwmod dra7xx_usb_otg_ss4_hwmod = {
+++	.name		= "usb_otg_ss4",
+++	.class		= &dra7xx_usb_otg_ss_hwmod_class,
+++	.clkdm_name	= "l3init_clkdm",
+++	.main_clk	= "dpll_core_h13x2_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3INIT_USB_OTG_SS4_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3INIT_USB_OTG_SS4_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_HWCTRL,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'vcp' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class dra7xx_vcp_hwmod_class = {
+++	.name	= "vcp",
+++};
+++
+++/* vcp1 */
+++static struct omap_hwmod dra7xx_vcp1_hwmod = {
+++	.name		= "vcp1",
+++	.class		= &dra7xx_vcp_hwmod_class,
+++	.clkdm_name	= "l3main1_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3MAIN1_VCP1_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3MAIN1_VCP1_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/* vcp2 */
+++static struct omap_hwmod dra7xx_vcp2_hwmod = {
+++	.name		= "vcp2",
+++	.class		= &dra7xx_vcp_hwmod_class,
+++	.clkdm_name	= "l3main1_clkdm",
+++	.main_clk	= "l3_iclk_div",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_L3MAIN1_VCP2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_L3MAIN1_VCP2_CONTEXT_OFFSET,
+++		},
+++	},
+++};
+++
+++/*
+++ * 'wd_timer' class
+++ *
+++ */
+++
+++static struct omap_hwmod_class_sysconfig dra7xx_wd_timer_sysc = {
+++	.rev_offs	= 0x0000,
+++	.sysc_offs	= 0x0010,
+++	.syss_offs	= 0x0014,
+++	.sysc_flags	= (SYSC_HAS_EMUFREE | SYSC_HAS_SIDLEMODE |
+++			   SYSC_HAS_SOFTRESET | SYSS_HAS_RESET_STATUS),
+++	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+++			   SIDLE_SMART_WKUP),
+++	.sysc_fields	= &omap_hwmod_sysc_type1,
+++};
+++
+++static struct omap_hwmod_class dra7xx_wd_timer_hwmod_class = {
+++	.name		= "wd_timer",
+++	.sysc		= &dra7xx_wd_timer_sysc,
+++	.pre_shutdown	= &omap2_wd_timer_disable,
+++	.reset		= &omap2_wd_timer_reset,
+++};
+++
+++/* wd_timer2 */
+++static struct omap_hwmod dra7xx_wd_timer2_hwmod = {
+++	.name		= "wd_timer2",
+++	.class		= &dra7xx_wd_timer_hwmod_class,
+++	.clkdm_name	= "wkupaon_clkdm",
+++	.main_clk	= "sys_32k_ck",
+++	.prcm = {
+++		.omap4 = {
+++			.clkctrl_offs = DRA7XX_CM_WKUPAON_WD_TIMER2_CLKCTRL_OFFSET,
+++			.context_offs = DRA7XX_RM_WKUPAON_WD_TIMER2_CONTEXT_OFFSET,
+++			.modulemode   = MODULEMODE_SWCTRL,
+++		},
+++	},
+++};
+++
+++
+++/*
+++ * Interfaces
+++ */
+++
+++/* l3_main_2 -> l3_instr */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_2__l3_instr = {
+++	.master		= &dra7xx_l3_main_2_hwmod,
+++	.slave		= &dra7xx_l3_instr_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_cfg -> l3_main_1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__l3_main_1 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_l3_main_1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/*
+++ * Interfaces
+++ */
+++
+++static struct omap_hwmod_addr_space dra7xx_dmm_addrs[] = {
+++	{
+++		.pa_start	= 0x4e000000,
+++		.pa_end		= 0x4e0007ff,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l3_main_1 -> dmm */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__dmm = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_dmm_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_dmm_addrs,
+++	.user		= OCP_USER_SDMA,
+++};
+++
+++/* dmm -> emif_ocp_fw */
+++static struct omap_hwmod_ocp_if dra7xx_dmm__emif_ocp_fw = {
+++	.master		= &dra7xx_dmm_hwmod,
+++	.slave		= &dra7xx_emif_ocp_fw_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* mpu -> l3_main_1 */
+++static struct omap_hwmod_ocp_if dra7xx_mpu__l3_main_1 = {
+++	.master		= &dra7xx_mpu_hwmod,
+++	.slave		= &dra7xx_l3_main_1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++/* l3_main_1 -> l3_main_2 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__l3_main_2 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_l3_main_2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++/* l4_cfg -> l3_main_2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__l3_main_2 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_l3_main_2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> l4_cfg */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__l4_cfg = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_l4_cfg_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> mmu0_dsp1 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__mmu0_dsp1 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_mmu0_dsp1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> mmu1_dsp1 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__mmu1_dsp1 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_mmu1_dsp1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> mmu0_dsp2 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__mmu0_dsp2 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_mmu0_dsp2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> mmu1_dsp2 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__mmu1_dsp2 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_mmu1_dsp2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> mmu_ipu1 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__mmu_ipu1 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_mmu_ipu1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> mmu_ipu2 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__mmu_ipu2 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_mmu_ipu2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> l4_per1 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__l4_per1 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_l4_per1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> l4_per2 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__l4_per2 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_l4_per2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> l4_per3 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__l4_per3 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_l4_per3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> l4_wkup */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__l4_wkup = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_l4_wkup_hwmod,
+++	.clk		= "wkupaon_iclk_mux",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> atl */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__atl = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_atl_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> bb2d */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__bb2d = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_bb2d_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_wkup -> counter_32k */
+++static struct omap_hwmod_ocp_if dra7xx_l4_wkup__counter_32k = {
+++	.master		= &dra7xx_l4_wkup_hwmod,
+++	.slave		= &dra7xx_counter_32k_hwmod,
+++	.clk		= "wkupaon_iclk_mux",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_wkup -> ctrl_module_wkup */
+++static struct omap_hwmod_ocp_if dra7xx_l4_wkup__ctrl_module_wkup = {
+++	.master		= &dra7xx_l4_wkup_hwmod,
+++	.slave		= &dra7xx_ctrl_module_wkup_hwmod,
+++	.clk		= "wkupaon_iclk_mux",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__cpgmac0 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_gmac_hwmod,
+++	.clk		= "dpll_gmac_ck",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++static struct omap_hwmod_ocp_if dra7xx_gmac__mdio = {
+++	.master		= &dra7xx_gmac_hwmod,
+++	.slave		= &dra7xx_mdio_hwmod,
+++	.user		= OCP_USER_MPU,
+++};
+++
+++/* l4_wkup -> dcan1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_wkup__dcan1 = {
+++	.master		= &dra7xx_l4_wkup_hwmod,
+++	.slave		= &dra7xx_dcan1_hwmod,
+++	.clk		= "wkupaon_iclk_mux",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> dcan2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__dcan2 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_dcan2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_dma_system_addrs[] = {
+++	{
+++		.pa_start	= 0x4a056000,
+++		.pa_end		= 0x4a056fff,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l4_cfg -> dma_system */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__dma_system = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_dma_system_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_dma_system_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++
+++/* l4_cfg -> tpcc */
+++struct omap_hwmod_ocp_if dra7xx_l4_cfg__tpcc = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_tpcc_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++/* l4_cfg -> tptc0 */
+++static struct omap_hwmod_addr_space dra7xx_tptc0_addr_space[] = {
+++	{
+++		.pa_start	= 0x43400000,
+++		.pa_end		= 0x43400212,
+++		.flags		= ADDR_TYPE_RT,
+++	},
+++	{ }
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_l4_cfg__tptc0 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_tptc0_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_tptc0_addr_space,
+++	.user		= OCP_USER_MPU,
+++};
+++
+++/* l4_cfg -> tptc1 */
+++static struct omap_hwmod_addr_space dra7xx_tptc1_addr_space[] = {
+++	{
+++		.pa_start	= 0x43500000,
+++		.pa_end		= 0x43500212,
+++		.flags		= ADDR_TYPE_RT,
+++	},
+++	{ }
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_l4_cfg__tptc1 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_tptc1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_tptc1_addr_space,
+++	.user		= OCP_USER_MPU,
+++};
+++
+++/* dsp1 -> l3_main_1 */
+++static struct omap_hwmod_ocp_if dra7xx_dsp1__l3_main_1 = {
+++	.master		= &dra7xx_dsp1_hwmod,
+++	.slave		= &dra7xx_l3_main_1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* dsp2 -> l3_main_1 */
+++static struct omap_hwmod_ocp_if dra7xx_dsp2__l3_main_1 = {
+++	.master		= &dra7xx_dsp2_hwmod,
+++	.slave		= &dra7xx_l3_main_1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_dss_addrs[] = {
+++	{
+++		.name		= "family",
+++		.pa_start	= 0x58000000,
+++		.pa_end		= 0x5800007f,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++};
+++
+++/* l3_main_1 -> dss */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__dss = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_dss_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_dss_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_dss_dispc_addrs[] = {
+++	{
+++		.name		= "dispc",
+++		.pa_start	= 0x58001000,
+++		.pa_end		= 0x58001fff,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++};
+++
+++/* l3_main_1 -> dispc */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__dispc = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_dss_dispc_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_dss_dispc_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_dss_hdmi_addrs[] = {
+++	{
+++		.name		= "hdmi_wp",
+++		.pa_start	= 0x58040000,
+++		.pa_end		= 0x580400ff,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l3_main_1 -> dispc */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__hdmi = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_dss_hdmi_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_dss_hdmi_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> aes1 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__aes1 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_aes1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> aes2 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__aes2 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_aes2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> sha0 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__sha0 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_sha0_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> mcasp2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__mcasp2 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_mcasp2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++/* l4_per2 -> mcasp3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__mcasp3 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_mcasp3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> mcasp6 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__mcasp6 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_mcasp6_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> mcasp7 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__mcasp7 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_mcasp7_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> mcasp8 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__mcasp8 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_mcasp8_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_elm_addrs[] = {
+++	{
+++		.pa_start	= 0x48078000,
+++		.pa_end		= 0x48078fff,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l4_per1 -> elm */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__elm = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_elm_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_elm_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_wkup -> gpio1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_wkup__gpio1 = {
+++	.master		= &dra7xx_l4_wkup_hwmod,
+++	.slave		= &dra7xx_gpio1_hwmod,
+++	.clk		= "wkupaon_iclk_mux",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> gpio2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__gpio2 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_gpio2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> gpio3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__gpio3 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_gpio3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> gpio4 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__gpio4 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_gpio4_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> gpio5 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__gpio5 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_gpio5_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> gpio6 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__gpio6 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_gpio6_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_l4_per2__epwmss0 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_epwmss0_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_epwmss0__ecap0 = {
+++	.master		= &dra7xx_epwmss0_hwmod,
+++	.slave		= &dra7xx_ecap0_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_epwmss0__eqep0 = {
+++	.master		= &dra7xx_epwmss0_hwmod,
+++	.slave		= &dra7xx_eqep0_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_epwmss0__ehrpwm0 = {
+++	.master		= &dra7xx_epwmss0_hwmod,
+++	.slave		= &dra7xx_ehrpwm0_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_l4_per2__epwmss1 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_epwmss1_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_epwmss1__ecap1 = {
+++	.master		= &dra7xx_epwmss1_hwmod,
+++	.slave		= &dra7xx_ecap1_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_epwmss1__eqep1 = {
+++	.master		= &dra7xx_epwmss1_hwmod,
+++	.slave		= &dra7xx_eqep1_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_epwmss1__ehrpwm1 = {
+++	.master		= &dra7xx_epwmss1_hwmod,
+++	.slave		= &dra7xx_ehrpwm1_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_l4_per2__epwmss2 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_epwmss2_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_epwmss2__ecap2 = {
+++	.master		= &dra7xx_epwmss2_hwmod,
+++	.slave		= &dra7xx_ecap2_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_epwmss2__eqep2 = {
+++	.master		= &dra7xx_epwmss2_hwmod,
+++	.slave		= &dra7xx_eqep2_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++struct omap_hwmod_ocp_if dra7xx_epwmss2__ehrpwm2 = {
+++	.master		= &dra7xx_epwmss2_hwmod,
+++	.slave		= &dra7xx_ehrpwm2_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU,
+++};
+++
+++/* l4_per1 -> gpio7 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__gpio7 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_gpio7_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> gpio8 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__gpio8 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_gpio8_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_gpmc_addrs[] = {
+++	{
+++		.pa_start	= 0x50000000,
+++		.pa_end		= 0x500003ff,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l3_main_1 -> gpmc */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__gpmc = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_gpmc_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_gpmc_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_gpu_addrs[] = {
+++	{
+++		.name           = "klio",
+++		.pa_start       = 0x56000000,
+++		.pa_end         = 0x56001fff,
+++	},
+++	{
+++		.name           = "hydra2",
+++		.pa_start       = 0x56004000,
+++		.pa_end         = 0x56004fff,
+++	},
+++	{
+++		.name           = "klio_0",
+++		.pa_start       = 0x56008000,
+++		.pa_end         = 0x56009fff,
+++	},
+++	{
+++		.name           = "klio_1",
+++		.pa_start       = 0x5600c000,
+++		.pa_end         = 0x5600dfff,
+++	},
+++	{
+++		.name           = "klio_hl",
+++		.pa_start       = 0x5600fe00,
+++		.pa_end         = 0x5600ffff,
+++		.flags          = ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l3_main_1 -> gpu */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__gpu = {
+++	.master         = &dra7xx_l3_main_1_hwmod,
+++	.slave          = &dra7xx_gpu_hwmod,
+++	.clk            = "l3_iclk_div",
+++	.addr           = dra7xx_gpu_addrs,
+++	.user           = OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_hdq1w_addrs[] = {
+++	{
+++		.pa_start	= 0x480b2000,
+++		.pa_end		= 0x480b201f,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l4_per1 -> hdq1w */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__hdq1w = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_hdq1w_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_hdq1w_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> i2c1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__i2c1 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_i2c1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> i2c2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__i2c2 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_i2c2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> i2c3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__i2c3 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_i2c3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> i2c4 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__i2c4 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_i2c4_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> i2c5 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__i2c5 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_i2c5_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* ipu1 -> l3_main_1 */
+++static struct omap_hwmod_ocp_if dra7xx_ipu1__l3_main_1 = {
+++	.master		= &dra7xx_ipu1_hwmod,
+++	.slave		= &dra7xx_l3_main_1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* ipu2 -> l3_main_1 */
+++static struct omap_hwmod_ocp_if dra7xx_ipu2__l3_main_1 = {
+++	.master		= &dra7xx_ipu2_hwmod,
+++	.slave		= &dra7xx_l3_main_1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_cfg -> mailbox1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__mailbox1 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_mailbox1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox2 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox3 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox4 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox4 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox4_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox5 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox5 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox5_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox6 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox6 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox6_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox7 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox7 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox7_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox8 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox8 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox8_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox9 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox9 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox9_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox10 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox10 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox10_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox11 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox11 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox11_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox12 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox12 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox12_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> mailbox13 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__mailbox13 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_mailbox13_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> mcspi1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__mcspi1 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_mcspi1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> mcspi2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__mcspi2 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_mcspi2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> mcspi3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__mcspi3 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_mcspi3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> mcspi4 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__mcspi4 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_mcspi4_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> mmc1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__mmc1 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_mmc1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> mmc2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__mmc2 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_mmc2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> mmc3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__mmc3 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_mmc3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> mmc4 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__mmc4 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_mmc4_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_cfg -> mpu */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__mpu = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_mpu_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_cfg -> ocp2scp1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__ocp2scp1 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_ocp2scp1_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_cfg -> ocp2scp3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__ocp2scp3 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_ocp2scp3_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> pcie1 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__pciess1 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_pciess1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_cfg -> pcie1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__pciess1 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_pciess1_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> pcie2 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__pciess2 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_pciess2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_cfg -> pcie2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__pciess2 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_pciess2_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_cfg -> pruss1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__pruss1 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_pruss1_hwmod,
+++	.clk		= "dpll_gmac_h13x2_ck",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_cfg -> pruss2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__pruss2 = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_pruss2_hwmod,
+++	.clk		= "dpll_gmac_h13x2_ck",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_qspi_addrs[] = {
+++	{
+++		.pa_start	= 0x4b300000,
+++		.pa_end		= 0x4b30007f,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l3_main_1 -> qspi */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__qspi = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_qspi_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_qspi_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> rtcss */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__rtcss = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_rtcss_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_sata_addrs[] = {
+++	{
+++		.name		= "sysc",
+++		.pa_start	= 0x4a141100,
+++		.pa_end		= 0x4a141107,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l4_cfg -> sata */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__sata = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_sata_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_sata_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_smartreflex_core_addrs[] = {
+++	{
+++		.pa_start	= 0x4a0dd000,
+++		.pa_end		= 0x4a0dd07f,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l4_cfg -> smartreflex_core */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__smartreflex_core = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_smartreflex_core_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.addr		= dra7xx_smartreflex_core_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_smartreflex_mpu_addrs[] = {
+++	{
+++		.pa_start	= 0x4a0d9000,
+++		.pa_end		= 0x4a0d907f,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l4_cfg -> smartreflex_mpu */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__smartreflex_mpu = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_smartreflex_mpu_hwmod,
+++	.clk		= "l4_root_clk_div",
+++	.addr		= dra7xx_smartreflex_mpu_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_addr_space dra7xx_spinlock_addrs[] = {
+++	{
+++		.pa_start	= 0x4a0f6000,
+++		.pa_end		= 0x4a0f6fff,
+++		.flags		= ADDR_TYPE_RT
+++	},
+++	{ }
+++};
+++
+++/* l4_cfg -> spinlock */
+++static struct omap_hwmod_ocp_if dra7xx_l4_cfg__spinlock = {
+++	.master		= &dra7xx_l4_cfg_hwmod,
+++	.slave		= &dra7xx_spinlock_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.addr		= dra7xx_spinlock_addrs,
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_wkup -> timer1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_wkup__timer1 = {
+++	.master		= &dra7xx_l4_wkup_hwmod,
+++	.slave		= &dra7xx_timer1_hwmod,
+++	.clk		= "wkupaon_iclk_mux",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> timer2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__timer2 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_timer2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> timer3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__timer3 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_timer3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> timer4 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__timer4 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_timer4_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> timer5 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__timer5 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_timer5_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> timer6 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__timer6 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_timer6_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> timer7 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__timer7 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_timer7_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> timer8 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__timer8 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_timer8_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> timer9 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__timer9 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_timer9_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> timer10 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__timer10 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_timer10_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> timer11 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__timer11 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_timer11_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_wkup -> timer12 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_wkup__timer12 = {
+++	.master		= &dra7xx_l4_wkup_hwmod,
+++	.slave		= &dra7xx_timer12_hwmod,
+++	.clk		= "wkupaon_iclk_mux",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> timer13 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__timer13 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_timer13_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> timer14 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__timer14 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_timer14_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> timer15 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__timer15 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_timer15_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> timer16 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__timer16 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_timer16_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> uart1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__uart1 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_uart1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> uart2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__uart2 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_uart2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> uart3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__uart3 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_uart3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> uart4 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__uart4 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_uart4_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> uart5 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__uart5 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_uart5_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> uart6 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__uart6 = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_uart6_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> uart7 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__uart7 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_uart7_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> uart8 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__uart8 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_uart8_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> uart9 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__uart9 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_uart9_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_wkup -> uart10 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_wkup__uart10 = {
+++	.master		= &dra7xx_l4_wkup_hwmod,
+++	.slave		= &dra7xx_uart10_hwmod,
+++	.clk		= "wkupaon_iclk_mux",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> des */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__des = {
+++	.master		= &dra7xx_l4_per1_hwmod,
+++	.slave		= &dra7xx_des_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per1 -> rng */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per1__rng = {
+++	.master         = &dra7xx_l4_per1_hwmod,
+++	.slave          = &dra7xx_rng_hwmod,
+++	.user           = OCP_USER_MPU,
+++};
+++
+++/* l4_per3 -> usb_otg_ss1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__usb_otg_ss1 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_usb_otg_ss1_hwmod,
+++	.clk		= "dpll_core_h13x2_ck",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> usb_otg_ss2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__usb_otg_ss2 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_usb_otg_ss2_hwmod,
+++	.clk		= "dpll_core_h13x2_ck",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> usb_otg_ss3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__usb_otg_ss3 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_usb_otg_ss3_hwmod,
+++	.clk		= "dpll_core_h13x2_ck",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> usb_otg_ss4 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__usb_otg_ss4 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_usb_otg_ss4_hwmod,
+++	.clk		= "dpll_core_h13x2_ck",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> vcp1 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__vcp1 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_vcp1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> vcp1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__vcp1 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_vcp1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l3_main_1 -> vcp2 */
+++static struct omap_hwmod_ocp_if dra7xx_l3_main_1__vcp2 = {
+++	.master		= &dra7xx_l3_main_1_hwmod,
+++	.slave		= &dra7xx_vcp2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per2 -> vcp2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per2__vcp2 = {
+++	.master		= &dra7xx_l4_per2_hwmod,
+++	.slave		= &dra7xx_vcp2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> vpe */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__vpe = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_vpe_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> vip1 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__vip1 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_vip1_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> vip2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__vip2 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_vip2_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> vip3 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__vip3 = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_vip3_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_per3 -> cal */
+++static struct omap_hwmod_ocp_if dra7xx_l4_per3__cal = {
+++	.master		= &dra7xx_l4_per3_hwmod,
+++	.slave		= &dra7xx_cal_hwmod,
+++	.clk		= "l3_iclk_div",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++/* l4_wkup -> wd_timer2 */
+++static struct omap_hwmod_ocp_if dra7xx_l4_wkup__wd_timer2 = {
+++	.master		= &dra7xx_l4_wkup_hwmod,
+++	.slave		= &dra7xx_wd_timer2_hwmod,
+++	.clk		= "wkupaon_iclk_mux",
+++	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+++};
+++
+++static struct omap_hwmod_ocp_if *dra7xx_hwmod_ocp_ifs[] __initdata = {
+++	&dra7xx_l3_main_1__dmm,
+++	&dra7xx_dmm__emif_ocp_fw,
+++	&dra7xx_l3_main_2__l3_instr,
+++	&dra7xx_l4_cfg__l3_main_1,
+++	&dra7xx_mpu__l3_main_1,
+++	&dra7xx_l3_main_1__l3_main_2,
+++	&dra7xx_l4_cfg__l3_main_2,
+++	&dra7xx_l3_main_1__l4_cfg,
+++	&dra7xx_l3_main_1__l4_per1,
+++	&dra7xx_l3_main_1__l4_per2,
+++	&dra7xx_l3_main_1__l4_per3,
+++	&dra7xx_l3_main_1__l4_wkup,
+++	&dra7xx_l4_per2__atl,
+++	&dra7xx_l3_main_1__bb2d,
+++	&dra7xx_l4_wkup__counter_32k,
+++	&dra7xx_l4_wkup__ctrl_module_wkup,
+++	&dra7xx_l4_wkup__dcan1,
+++	&dra7xx_l4_per2__dcan2,
+++	&dra7xx_l4_per2__cpgmac0,
+++	&dra7xx_gmac__mdio,
+++	&dra7xx_l4_cfg__dma_system,
+++	&dra7xx_l4_cfg__tpcc,
+++	&dra7xx_l4_cfg__tptc0,
+++	&dra7xx_l4_cfg__tptc1,
+++	&dra7xx_l3_main_1__dss,
+++	&dra7xx_l3_main_1__dispc,
+++	&dra7xx_dsp1__l3_main_1,
+++	&dra7xx_l3_main_1__hdmi,
+++	&dra7xx_l3_main_1__aes1,
+++	&dra7xx_l3_main_1__aes2,
+++	&dra7xx_l3_main_1__sha0,
+++	&dra7xx_l4_per2__mcasp2,
+++	&dra7xx_l4_per2__mcasp3,
+++	&dra7xx_l4_per2__mcasp6,
+++	&dra7xx_l4_per2__mcasp7,
+++	&dra7xx_l4_per2__mcasp8,
+++	&dra7xx_l4_per1__elm,
+++	&dra7xx_l4_wkup__gpio1,
+++	&dra7xx_l4_per1__gpio2,
+++	&dra7xx_l4_per1__gpio3,
+++	&dra7xx_l4_per1__gpio4,
+++	&dra7xx_l4_per1__gpio5,
+++	&dra7xx_l4_per1__gpio6,
+++	&dra7xx_l4_per1__gpio7,
+++	&dra7xx_l4_per1__gpio8,
+++	&dra7xx_l3_main_1__gpmc,
+++	&dra7xx_l3_main_1__gpu,
+++	&dra7xx_l4_per1__hdq1w,
+++	&dra7xx_l4_per1__i2c1,
+++	&dra7xx_l4_per1__i2c2,
+++	&dra7xx_l4_per1__i2c3,
+++	&dra7xx_l4_per1__i2c4,
+++	&dra7xx_l4_per1__i2c5,
+++	&dra7xx_ipu1__l3_main_1,
+++	&dra7xx_ipu2__l3_main_1,
+++	&dra7xx_l4_cfg__mailbox1,
+++	&dra7xx_l4_per3__mailbox2,
+++	&dra7xx_l4_per3__mailbox3,
+++	&dra7xx_l4_per3__mailbox4,
+++	&dra7xx_l4_per3__mailbox5,
+++	&dra7xx_l4_per3__mailbox6,
+++	&dra7xx_l4_per3__mailbox7,
+++	&dra7xx_l4_per3__mailbox8,
+++	&dra7xx_l4_per3__mailbox9,
+++	&dra7xx_l4_per3__mailbox10,
+++	&dra7xx_l4_per3__mailbox11,
+++	&dra7xx_l4_per3__mailbox12,
+++	&dra7xx_l4_per3__mailbox13,
+++	&dra7xx_l4_per1__mcspi1,
+++	&dra7xx_l4_per1__mcspi2,
+++	&dra7xx_l4_per1__mcspi3,
+++	&dra7xx_l4_per1__mcspi4,
+++	&dra7xx_l4_per1__mmc1,
+++	&dra7xx_l4_per1__mmc2,
+++	&dra7xx_l4_per1__mmc3,
+++	&dra7xx_l4_per1__mmc4,
+++	&dra7xx_l3_main_1__mmu0_dsp1,
+++	&dra7xx_l3_main_1__mmu1_dsp1,
+++	&dra7xx_l3_main_1__mmu_ipu1,
+++	&dra7xx_l3_main_1__mmu_ipu2,
+++	&dra7xx_l4_cfg__mpu,
+++	&dra7xx_l4_cfg__ocp2scp1,
+++	&dra7xx_l4_cfg__ocp2scp3,
+++	&dra7xx_l3_main_1__pciess1,
+++	&dra7xx_l4_cfg__pciess1,
+++	&dra7xx_l3_main_1__pciess2,
+++	&dra7xx_l4_cfg__pciess2,
+++	&dra7xx_l4_cfg__pruss1, /* AM57xx only */
+++	&dra7xx_l4_cfg__pruss2, /* AM57xx only */
+++	&dra7xx_l3_main_1__qspi,
+++	&dra7xx_l4_per3__rtcss,
+++	&dra7xx_l4_cfg__sata,
+++	&dra7xx_l4_cfg__smartreflex_core,
+++	&dra7xx_l4_cfg__smartreflex_mpu,
+++	&dra7xx_l4_cfg__spinlock,
+++	&dra7xx_l4_wkup__timer1,
+++	&dra7xx_l4_per1__timer2,
+++	&dra7xx_l4_per1__timer3,
+++	&dra7xx_l4_per1__timer4,
+++	&dra7xx_l4_per3__timer5,
+++	&dra7xx_l4_per3__timer6,
+++	&dra7xx_l4_per3__timer7,
+++	&dra7xx_l4_per3__timer8,
+++	&dra7xx_l4_per1__timer9,
+++	&dra7xx_l4_per1__timer10,
+++	&dra7xx_l4_per1__timer11,
+++	&dra7xx_l4_per3__timer13,
+++	&dra7xx_l4_per3__timer14,
+++	&dra7xx_l4_per3__timer15,
+++	&dra7xx_l4_per3__timer16,
+++	&dra7xx_l4_per1__uart1,
+++	&dra7xx_l4_per1__uart2,
+++	&dra7xx_l4_per1__uart3,
+++	&dra7xx_l4_per1__uart4,
+++	&dra7xx_l4_per1__uart5,
+++	&dra7xx_l4_per1__uart6,
+++	&dra7xx_l4_per2__uart7,
+++	&dra7xx_l4_per2__uart8,
+++	&dra7xx_l4_per2__uart9,
+++	&dra7xx_l4_wkup__uart10,
+++	&dra7xx_l4_per1__des,
+++	&dra7xx_l4_per1__rng,
+++	&dra7xx_l4_per3__usb_otg_ss1,
+++	&dra7xx_l4_per3__usb_otg_ss2,
+++	&dra7xx_l4_per3__usb_otg_ss3,
+++	&dra7xx_l3_main_1__vcp1,
+++	&dra7xx_l4_per2__vcp1,
+++	&dra7xx_l3_main_1__vcp2,
+++	&dra7xx_l4_per2__vcp2,
+++	&dra7xx_l4_per3__vpe,
+++	&dra7xx_l4_per3__vip1,
+++	&dra7xx_l4_wkup__wd_timer2,
+++	&dra7xx_l4_per2__epwmss0,
+++	&dra7xx_epwmss0__ecap0,
+++	&dra7xx_epwmss0__eqep0,
+++	&dra7xx_epwmss0__ehrpwm0,
+++	&dra7xx_l4_per2__epwmss1,
+++	&dra7xx_epwmss1__ecap1,
+++	&dra7xx_epwmss1__eqep1,
+++	&dra7xx_epwmss1__ehrpwm1,
+++	&dra7xx_l4_per2__epwmss2,
+++	&dra7xx_epwmss2__ecap2,
+++	&dra7xx_epwmss2__eqep2,
+++	&dra7xx_epwmss2__ehrpwm2,
+++	NULL,
+++};
+++
+++static struct omap_hwmod_ocp_if *dra74x_hwmod_ocp_ifs[] __initdata = {
+++	&dra7xx_l4_per3__usb_otg_ss4,
+++	&dra7xx_l3_main_1__mmu0_dsp2,
+++	&dra7xx_l3_main_1__mmu1_dsp2,
+++	&dra7xx_dsp2__l3_main_1,
+++	&dra7xx_l4_per3__vip2,
+++	&dra7xx_l4_per3__vip3,
+++	NULL,
+++};
+++
+++static struct omap_hwmod_ocp_if *dra72x_hwmod_ocp_ifs[] __initdata = {
+++	&dra7xx_l4_per3__cal,
+++	NULL,
+++};
+++
+++static struct omap_hwmod_ocp_if *dra7xx_gp_hwmod_ocp_ifs[] __initdata = {
+++	&dra7xx_l4_wkup__timer12,
+++	NULL,
+++};
+++
+++int __init dra7xx_hwmod_init(void)
+++{
+++	int ret;
+++
+++	omap_hwmod_init();
+++
+++	if (OMAP2_DEVICE_TYPE_GP != omap_type()) {
+++		/* AES, DES, SHAM and RNG HWAs are shared between secure and public
+++		   worlds for a HS/EMU device. In this case the module clocks are
+++		   already enabled and should not be touched by the kernel driver.
+++		*/
+++		dra7xx_aes_hwmod_class.sysc = NULL;
+++		dra7xx_aes_hwmod_class.rev = 0;
+++		dra7xx_aes1_hwmod.prcm.omap4.modulemode = 0;
+++		dra7xx_aes2_hwmod.prcm.omap4.modulemode = 0;
+++
+++		dra7xx_des_hwmod_class.sysc = NULL;
+++		dra7xx_des_hwmod_class.rev = 0;
+++		dra7xx_des_hwmod.prcm.omap4.modulemode = 0;
+++
+++		dra7xx_sha0_hwmod_class.sysc = NULL;
+++		dra7xx_sha0_hwmod_class.rev = 0;
+++		dra7xx_sha0_hwmod.prcm.omap4.modulemode = 0;
+++
+++		dra7xx_rng_hwmod_class.sysc = NULL;
+++		dra7xx_rng_hwmod_class.rev = 0;
+++		dra7xx_rng_hwmod.prcm.omap4.modulemode = 0;
+++	}
+++
+++	ret = omap_hwmod_register_links(dra7xx_hwmod_ocp_ifs);
+++
+++	if (!ret && OMAP2_DEVICE_TYPE_GP == omap_type())
+++		ret = omap_hwmod_register_links(dra7xx_gp_hwmod_ocp_ifs);
+++
+++	if (!ret && soc_is_dra74x())
+++		return omap_hwmod_register_links(dra74x_hwmod_ocp_ifs);
+++	else if (!ret && soc_is_dra72x())
+++		return omap_hwmod_register_links(dra72x_hwmod_ocp_ifs);
+++
+++	return ret;
+++}
++diff --git a/arch/arm/mach-omap2/powerdomains7xx_dom0_data.c b/arch/arm/mach-omap2/powerdomains7xx_dom0_data.c
++new file mode 100644
++index 0000000..f2b4557
++--- /dev/null
+++++ b/arch/arm/mach-omap2/powerdomains7xx_dom0_data.c
++@@ -0,0 +1,454 @@
+++/*
+++ * DRA7xx Power domains framework
+++ *
+++ * Copyright (C) 2009-2013 Texas Instruments, Inc.
+++ * Copyright (C) 2009-2011 Nokia Corporation
+++ *
+++ * Generated by code originally written by:
+++ * Abhijit Pagare (abhijitpagare@ti.com)
+++ * Benoit Cousson (b-cousson@ti.com)
+++ * Paul Walmsley (paul@pwsan.com)
+++ *
+++ * This file is automatically generated from the OMAP hardware databases.
+++ * We respectfully ask that any modifications to this file be coordinated
+++ * with the public linux-omap@vger.kernel.org mailing list and the
+++ * authors above to ensure that the autogeneration scripts are kept
+++ * up-to-date with the file contents.
+++ *
+++ * This program is free software; you can redistribute it and/or modify
+++ * it under the terms of the GNU General Public License version 2 as
+++ * published by the Free Software Foundation.
+++ */
+++
+++#include <linux/kernel.h>
+++#include <linux/init.h>
+++
+++#include "powerdomain.h"
+++
+++#include "prcm-common.h"
+++#include "prcm44xx.h"
+++#include "prm7xx.h"
+++#include "prcm_mpu7xx.h"
+++
+++/* iva_7xx_pwrdm: IVA-HD power domain */
+++static struct powerdomain iva_7xx_pwrdm = {
+++	.name		  = "iva_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_IVA_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_RET_ON,
+++	.pwrsts_logic_ret = PWRSTS_OFF,
+++	.banks		  = 4,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* hwa_mem */
+++		[1] = PWRSTS_OFF_RET,	/* sl2_mem */
+++		[2] = PWRSTS_OFF_RET,	/* tcm1_mem */
+++		[3] = PWRSTS_OFF_RET,	/* tcm2_mem */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* hwa_mem */
+++		[1] = PWRSTS_OFF_RET,	/* sl2_mem */
+++		[2] = PWRSTS_OFF_RET,	/* tcm1_mem */
+++		[3] = PWRSTS_OFF_RET,	/* tcm2_mem */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* rtc_7xx_pwrdm:  */
+++static struct powerdomain rtc_7xx_pwrdm = {
+++	.name		  = "rtc_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_RTC_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_ON,
+++};
+++
+++/* custefuse_7xx_pwrdm: Customer efuse controller power domain */
+++static struct powerdomain custefuse_7xx_pwrdm = {
+++	.name		  = "custefuse_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_CUSTEFUSE_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* ipu_7xx_pwrdm: Audio back end power domain */
+++static struct powerdomain ipu_7xx_pwrdm = {
+++	.name		  = "ipu_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_IPU_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_RET_ON,
+++	.pwrsts_logic_ret = PWRSTS_OFF,
+++	.banks		  = 2,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* aessmem */
+++		[1] = PWRSTS_OFF_RET,	/* periphmem */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* aessmem */
+++		[1] = PWRSTS_OFF_RET,	/* periphmem */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* dss_7xx_pwrdm: Display subsystem power domain */
+++static struct powerdomain dss_7xx_pwrdm = {
+++	.name		  = "dss_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_DSS_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_RET_ON,
+++	.pwrsts_logic_ret = PWRSTS_OFF,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* dss_mem */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* dss_mem */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* l4per_7xx_pwrdm: Target peripherals power domain */
+++static struct powerdomain l4per_7xx_pwrdm = {
+++	.name		  = "l4per_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_L4PER_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_RET_ON,
+++	.pwrsts_logic_ret = PWRSTS_OFF_RET,
+++	.banks		  = 2,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* nonretained_bank */
+++		[1] = PWRSTS_OFF_RET,	/* retained_bank */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* nonretained_bank */
+++		[1] = PWRSTS_OFF_RET,	/* retained_bank */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* gpu_7xx_pwrdm: 3D accelerator power domain */
+++static struct powerdomain gpu_7xx_pwrdm = {
+++	.name		  = "gpu_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_GPU_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* gpu_mem */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* gpu_mem */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* wkupaon_7xx_pwrdm: Wake-up power domain */
+++static struct powerdomain wkupaon_7xx_pwrdm = {
+++	.name		  = "wkupaon_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_WKUPAON_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_ON,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_ON,	/* wkup_bank */
+++	},
+++};
+++
+++/* core_7xx_pwrdm: CORE power domain */
+++static struct powerdomain core_7xx_pwrdm = {
+++	.name		  = "core_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_CORE_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_ON,
+++	.pwrsts_logic_ret = PWRSTS_RET,
+++	.banks		  = 5,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* core_nret_bank */
+++		[1] = PWRSTS_OFF_RET,	/* core_ocmram */
+++		[2] = PWRSTS_OFF_RET,	/* core_other_bank */
+++		[3] = PWRSTS_OFF_RET,	/* ipu_l2ram */
+++		[4] = PWRSTS_OFF_RET,	/* ipu_unicache */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* core_nret_bank */
+++		[1] = PWRSTS_OFF_RET,	/* core_ocmram */
+++		[2] = PWRSTS_OFF_RET,	/* core_other_bank */
+++		[3] = PWRSTS_OFF_RET,	/* ipu_l2ram */
+++		[4] = PWRSTS_OFF_RET,	/* ipu_unicache */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* coreaon_7xx_pwrdm: Always ON logic that sits in VDD_CORE voltage domain */
+++static struct powerdomain coreaon_7xx_pwrdm = {
+++	.name		  = "coreaon_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_COREAON_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_ON,
+++};
+++
+++/* cpu0_7xx_pwrdm: MPU0 processor and Neon coprocessor power domain */
+++static struct powerdomain cpu0_7xx_pwrdm = {
+++	.name		  = "cpu0_pwrdm",
+++	.prcm_offs	  = DRA7XX_MPU_PRCM_PRM_C0_INST,
+++	.prcm_partition	  = DRA7XX_MPU_PRCM_PARTITION,
+++	.pwrsts		  = PWRSTS_RET_ON,
+++	.pwrsts_logic_ret = PWRSTS_RET,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* cpu0_l1 */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_ON,	/* cpu0_l1 */
+++	},
+++};
+++
+++/* cpu1_7xx_pwrdm: MPU1 processor and Neon coprocessor power domain */
+++static struct powerdomain cpu1_7xx_pwrdm = {
+++	.name		  = "cpu1_pwrdm",
+++	.prcm_offs	  = DRA7XX_MPU_PRCM_PRM_C1_INST,
+++	.prcm_partition	  = DRA7XX_MPU_PRCM_PARTITION,
+++	.pwrsts		  = PWRSTS_RET_ON,
+++	.pwrsts_logic_ret = PWRSTS_RET,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* cpu1_l1 */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_ON,	/* cpu1_l1 */
+++	},
+++};
+++
+++/* vpe_7xx_pwrdm:  */
+++static struct powerdomain vpe_7xx_pwrdm = {
+++	.name		  = "vpe_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_VPE_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_RET_ON,
+++	.pwrsts_logic_ret = PWRSTS_OFF_RET,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* vpe_bank */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* vpe_bank */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* mpu_7xx_pwrdm: Modena processor and the Neon coprocessor power domain */
+++static struct powerdomain mpu_7xx_pwrdm = {
+++	.name		  = "mpu_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_MPU_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_RET_ON,
+++	.pwrsts_logic_ret = PWRSTS_RET,
+++	.banks		  = 2,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* mpu_l2 */
+++		[1] = PWRSTS_RET,	/* mpu_ram */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* mpu_l2 */
+++		[1] = PWRSTS_OFF_RET,	/* mpu_ram */
+++	},
+++};
+++
+++/* l3init_7xx_pwrdm: L3 initators pheripherals power domain  */
+++static struct powerdomain l3init_7xx_pwrdm = {
+++	.name		  = "l3init_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_L3INIT_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_RET_ON,
+++	.pwrsts_logic_ret = PWRSTS_OFF_RET,
+++	.banks		  = 3,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* gmac_bank */
+++		[1] = PWRSTS_OFF_RET,	/* l3init_bank1 */
+++		[2] = PWRSTS_OFF_RET,	/* l3init_bank2 */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* gmac_bank */
+++		[1] = PWRSTS_OFF_RET,	/* l3init_bank1 */
+++		[2] = PWRSTS_OFF_RET,	/* l3init_bank2 */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* eve3_7xx_pwrdm:  */
+++static struct powerdomain eve3_7xx_pwrdm = {
+++	.name		  = "eve3_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_EVE3_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* eve3_bank */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* eve3_bank */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* emu_7xx_pwrdm: Emulation power domain */
+++static struct powerdomain emu_7xx_pwrdm = {
+++	.name		  = "emu_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_EMU_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* emu_bank */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* emu_bank */
+++	},
+++};
+++
+++/* dsp2_7xx_pwrdm:  */
+++static struct powerdomain dsp2_7xx_pwrdm = {
+++	.name		  = "dsp2_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_DSP2_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.banks		  = 3,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* dsp2_edma */
+++		[1] = PWRSTS_OFF_RET,	/* dsp2_l1 */
+++		[2] = PWRSTS_OFF_RET,	/* dsp2_l2 */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* dsp2_edma */
+++		[1] = PWRSTS_OFF_RET,	/* dsp2_l1 */
+++		[2] = PWRSTS_OFF_RET,	/* dsp2_l2 */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* dsp1_7xx_pwrdm: Tesla processor power domain */
+++static struct powerdomain dsp1_7xx_pwrdm = {
+++	.name		  = "dsp1_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_DSP1_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.banks		  = 3,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* dsp1_edma */
+++		[1] = PWRSTS_OFF_RET,	/* dsp1_l1 */
+++		[2] = PWRSTS_OFF_RET,	/* dsp1_l2 */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* dsp1_edma */
+++		[1] = PWRSTS_OFF_RET,	/* dsp1_l1 */
+++		[2] = PWRSTS_OFF_RET,	/* dsp1_l2 */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* cam_7xx_pwrdm: Camera subsystem power domain */
+++static struct powerdomain cam_7xx_pwrdm = {
+++	.name		  = "cam_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_CAM_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* vip_bank */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* vip_bank */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* eve4_7xx_pwrdm:  */
+++static struct powerdomain eve4_7xx_pwrdm = {
+++	.name		  = "eve4_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_EVE4_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* eve4_bank */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* eve4_bank */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* eve2_7xx_pwrdm:  */
+++static struct powerdomain eve2_7xx_pwrdm = {
+++	.name		  = "eve2_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_EVE2_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* eve2_bank */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* eve2_bank */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/* eve1_7xx_pwrdm:  */
+++static struct powerdomain eve1_7xx_pwrdm = {
+++	.name		  = "eve1_pwrdm",
+++	.prcm_offs	  = DRA7XX_PRM_EVE1_INST,
+++	.prcm_partition	  = DRA7XX_PRM_PARTITION,
+++	.pwrsts		  = PWRSTS_OFF_ON,
+++	.banks		  = 1,
+++	.pwrsts_mem_ret	= {
+++		[0] = PWRSTS_OFF_RET,	/* eve1_bank */
+++	},
+++	.pwrsts_mem_on	= {
+++		[0] = PWRSTS_OFF_RET,	/* eve1_bank */
+++	},
+++	.flags		  = PWRDM_HAS_LOWPOWERSTATECHANGE,
+++};
+++
+++/*
+++ * The following power domains are not under SW control
+++ *
+++ * mpuaon
+++ * mmaon
+++ */
+++
+++/* As powerdomains are added or removed above, this list must also be changed */
+++static struct powerdomain *powerdomains_dra7xx[] __initdata = {
+++	&iva_7xx_pwrdm,
+++	&rtc_7xx_pwrdm,
+++	&custefuse_7xx_pwrdm,
+++	&ipu_7xx_pwrdm,
+++	&dss_7xx_pwrdm,
+++	&l4per_7xx_pwrdm,
+++	&gpu_7xx_pwrdm,
+++	&wkupaon_7xx_pwrdm,
+++	&core_7xx_pwrdm,
+++	&coreaon_7xx_pwrdm,
+++	&cpu0_7xx_pwrdm,
+++	&cpu1_7xx_pwrdm,
+++	&vpe_7xx_pwrdm,
+++	&mpu_7xx_pwrdm,
+++	&l3init_7xx_pwrdm,
+++	&eve3_7xx_pwrdm,
+++	&emu_7xx_pwrdm,
+++	&dsp2_7xx_pwrdm,
+++	&dsp1_7xx_pwrdm,
+++	&cam_7xx_pwrdm,
+++	&eve4_7xx_pwrdm,
+++	&eve2_7xx_pwrdm,
+++	&eve1_7xx_pwrdm,
+++	NULL
+++};
+++
+++void __init dra7xx_powerdomains_init(void)
+++{
+++	pwrdm_register_platform_funcs(&omap4_pwrdm_operations);
+++	pwrdm_register_pwrdms(powerdomains_dra7xx);
+++	pwrdm_complete_init();
+++}
++diff --git a/drivers/clk/ti/Makefile b/drivers/clk/ti/Makefile
++index 88074d3..f4a981d 100644
++--- a/drivers/clk/ti/Makefile
+++++ b/drivers/clk/ti/Makefile
++@@ -7,7 +7,14 @@ obj-$(CONFIG_ARCH_OMAP2)		+= $(clk-common) interface.o clk-2xxx.o
++ obj-$(CONFIG_ARCH_OMAP3)		+= $(clk-common) interface.o clk-3xxx.o
++ obj-$(CONFIG_ARCH_OMAP4)		+= $(clk-common) clk-44xx.o
++ obj-$(CONFIG_SOC_OMAP5)			+= $(clk-common) clk-54xx.o
++-obj-$(CONFIG_SOC_DRA7XX)		+= $(clk-common) clk-7xx.o \
++-					   clk-dra7-atl.o
+++obj-$(CONFIG_SOC_DRA7XX)		+= $(clk-common)
+++ifeq ($(CONFIG_XEN_DOM0),y)
+++obj-$(CONFIG_SOC_DRA7XX)		+= clk-7xx_dom0.o clk-dra7-atl.o
+++else
+++obj-$(CONFIG_SOC_DRA7XX)		+= clk-7xx.o
+++endif
+++ifeq ($(CONFIG_XEN),)
+++obj-$(CONFIG_SOC_DRA7XX)		+= clk-dra7-atl.o
+++endif
++ obj-$(CONFIG_SOC_AM43XX)		+= $(clk-common) clk-43xx.o
++ endif
++diff --git a/drivers/clk/ti/clk-7xx_dom0.c b/drivers/clk/ti/clk-7xx_dom0.c
++new file mode 100644
++index 0000000..1278b39
++--- /dev/null
+++++ b/drivers/clk/ti/clk-7xx_dom0.c
++@@ -0,0 +1,400 @@
+++/*
+++ * DRA7 Clock init
+++ *
+++ * Copyright (C) 2013 Texas Instruments, Inc.
+++ *
+++ * Tero Kristo (t-kristo@ti.com)
+++ *
+++ * This program is free software; you can redistribute it and/or modify
+++ * it under the terms of the GNU General Public License version 2 as
+++ * published by the Free Software Foundation.
+++ */
+++
+++#include <linux/kernel.h>
+++#include <linux/list.h>
+++#include <linux/clk-private.h>
+++#include <linux/clkdev.h>
+++#include <linux/clk/ti.h>
+++
+++#define DRA7_DPLL_ABE_DEFFREQ				180633600
+++#define DRA7_DPLL_GMAC_DEFFREQ				1000000000
+++#define DRA7_DPLL_DSP_GFCLK_NOMFREQ			600000000
+++#define DRA7_DPLL_EVE_GCLK_NOMFREQ			400000000
+++
+++#define DRA7_ATL_DEFFREQ				11289600
+++#define DRA7_DPLL_USB_DEFFREQ				960000000
+++
+++static struct ti_dt_clk dra7xx_clks[] = {
+++	DT_CLK(NULL, "atl_clkin0_ck", "atl_clkin0_ck"),
+++	DT_CLK(NULL, "atl_clkin1_ck", "atl_clkin1_ck"),
+++	DT_CLK(NULL, "atl_clkin2_ck", "atl_clkin2_ck"),
+++	DT_CLK(NULL, "atl_clkin3_ck", "atl_clkin3_ck"),
+++	DT_CLK(NULL, "hdmi_clkin_ck", "hdmi_clkin_ck"),
+++	DT_CLK(NULL, "mlb_clkin_ck", "mlb_clkin_ck"),
+++	DT_CLK(NULL, "mlbp_clkin_ck", "mlbp_clkin_ck"),
+++	DT_CLK(NULL, "pciesref_acs_clk_ck", "pciesref_acs_clk_ck"),
+++	DT_CLK(NULL, "ref_clkin0_ck", "ref_clkin0_ck"),
+++	DT_CLK(NULL, "ref_clkin1_ck", "ref_clkin1_ck"),
+++	DT_CLK(NULL, "ref_clkin2_ck", "ref_clkin2_ck"),
+++	DT_CLK(NULL, "ref_clkin3_ck", "ref_clkin3_ck"),
+++	DT_CLK(NULL, "rmii_clk_ck", "rmii_clk_ck"),
+++	DT_CLK(NULL, "sdvenc_clkin_ck", "sdvenc_clkin_ck"),
+++	DT_CLK(NULL, "secure_32k_clk_src_ck", "secure_32k_clk_src_ck"),
+++	DT_CLK(NULL, "sys_32k_ck", "sys_32k_ck"),
+++	DT_CLK(NULL, "virt_12000000_ck", "virt_12000000_ck"),
+++	DT_CLK(NULL, "virt_13000000_ck", "virt_13000000_ck"),
+++	DT_CLK(NULL, "virt_16800000_ck", "virt_16800000_ck"),
+++	DT_CLK(NULL, "virt_19200000_ck", "virt_19200000_ck"),
+++	DT_CLK(NULL, "virt_20000000_ck", "virt_20000000_ck"),
+++	DT_CLK(NULL, "virt_26000000_ck", "virt_26000000_ck"),
+++	DT_CLK(NULL, "virt_27000000_ck", "virt_27000000_ck"),
+++	DT_CLK(NULL, "virt_38400000_ck", "virt_38400000_ck"),
+++	DT_CLK(NULL, "sys_clkin1", "sys_clkin1"),
+++	DT_CLK(NULL, "sys_clkin2", "sys_clkin2"),
+++	DT_CLK(NULL, "usb_otg_clkin_ck", "usb_otg_clkin_ck"),
+++	DT_CLK(NULL, "video1_clkin_ck", "video1_clkin_ck"),
+++	DT_CLK(NULL, "video1_m2_clkin_ck", "video1_m2_clkin_ck"),
+++	DT_CLK(NULL, "video2_clkin_ck", "video2_clkin_ck"),
+++	DT_CLK(NULL, "video2_m2_clkin_ck", "video2_m2_clkin_ck"),
+++	DT_CLK(NULL, "abe_dpll_sys_clk_mux", "abe_dpll_sys_clk_mux"),
+++	DT_CLK(NULL, "abe_dpll_bypass_clk_mux", "abe_dpll_bypass_clk_mux"),
+++	DT_CLK(NULL, "abe_dpll_clk_mux", "abe_dpll_clk_mux"),
+++	DT_CLK(NULL, "dpll_abe_ck", "dpll_abe_ck"),
+++	DT_CLK(NULL, "dpll_abe_x2_ck", "dpll_abe_x2_ck"),
+++	DT_CLK(NULL, "dpll_abe_m2x2_ck", "dpll_abe_m2x2_ck"),
+++	DT_CLK(NULL, "abe_24m_fclk", "abe_24m_fclk"),
+++	DT_CLK(NULL, "abe_clk", "abe_clk"),
+++	DT_CLK(NULL, "aess_fclk", "aess_fclk"),
+++	DT_CLK(NULL, "abe_giclk_div", "abe_giclk_div"),
+++	DT_CLK(NULL, "abe_lp_clk_div", "abe_lp_clk_div"),
+++	DT_CLK(NULL, "abe_sys_clk_div", "abe_sys_clk_div"),
+++	DT_CLK(NULL, "adc_gfclk_mux", "adc_gfclk_mux"),
+++	DT_CLK(NULL, "dpll_pcie_ref_ck", "dpll_pcie_ref_ck"),
+++	DT_CLK(NULL, "dpll_pcie_ref_m2ldo_ck", "dpll_pcie_ref_m2ldo_ck"),
+++	DT_CLK(NULL, "apll_pcie_ck", "apll_pcie_ck"),
+++	DT_CLK(NULL, "apll_pcie_clkvcoldo", "apll_pcie_clkvcoldo"),
+++	DT_CLK(NULL, "apll_pcie_clkvcoldo_div", "apll_pcie_clkvcoldo_div"),
+++	DT_CLK(NULL, "apll_pcie_m2_ck", "apll_pcie_m2_ck"),
+++	DT_CLK(NULL, "sys_clk1_dclk_div", "sys_clk1_dclk_div"),
+++	DT_CLK(NULL, "sys_clk2_dclk_div", "sys_clk2_dclk_div"),
+++	DT_CLK(NULL, "dpll_abe_m2_ck", "dpll_abe_m2_ck"),
+++	DT_CLK(NULL, "per_abe_x1_dclk_div", "per_abe_x1_dclk_div"),
+++	DT_CLK(NULL, "dpll_abe_m3x2_ck", "dpll_abe_m3x2_ck"),
+++	DT_CLK(NULL, "dpll_core_ck", "dpll_core_ck"),
+++	DT_CLK(NULL, "dpll_core_x2_ck", "dpll_core_x2_ck"),
+++	DT_CLK(NULL, "dpll_core_h12x2_ck", "dpll_core_h12x2_ck"),
+++	DT_CLK(NULL, "mpu_dpll_hs_clk_div", "mpu_dpll_hs_clk_div"),
+++	DT_CLK(NULL, "dpll_mpu_ck", "dpll_mpu_ck"),
+++	DT_CLK(NULL, "dpll_mpu_m2_ck", "dpll_mpu_m2_ck"),
+++	DT_CLK(NULL, "mpu_dclk_div", "mpu_dclk_div"),
+++	DT_CLK(NULL, "dsp_dpll_hs_clk_div", "dsp_dpll_hs_clk_div"),
+++	DT_CLK(NULL, "dpll_dsp_ck", "dpll_dsp_ck"),
+++	DT_CLK(NULL, "dpll_dsp_m2_ck", "dpll_dsp_m2_ck"),
+++	DT_CLK(NULL, "dsp_gclk_div", "dsp_gclk_div"),
+++	DT_CLK(NULL, "iva_dpll_hs_clk_div", "iva_dpll_hs_clk_div"),
+++	DT_CLK(NULL, "dpll_iva_ck", "dpll_iva_ck"),
+++	DT_CLK(NULL, "dpll_iva_m2_ck", "dpll_iva_m2_ck"),
+++	DT_CLK(NULL, "iva_dclk", "iva_dclk"),
+++	DT_CLK(NULL, "dpll_gpu_ck", "dpll_gpu_ck"),
+++	DT_CLK(NULL, "dpll_gpu_m2_ck", "dpll_gpu_m2_ck"),
+++	DT_CLK(NULL, "gpu_dclk", "gpu_dclk"),
+++	DT_CLK(NULL, "dpll_core_m2_ck", "dpll_core_m2_ck"),
+++	DT_CLK(NULL, "core_dpll_out_dclk_div", "core_dpll_out_dclk_div"),
+++	DT_CLK(NULL, "dpll_ddr_ck", "dpll_ddr_ck"),
+++	DT_CLK(NULL, "dpll_ddr_m2_ck", "dpll_ddr_m2_ck"),
+++	DT_CLK(NULL, "emif_phy_dclk_div", "emif_phy_dclk_div"),
+++	DT_CLK(NULL, "dpll_gmac_ck", "dpll_gmac_ck"),
+++	DT_CLK(NULL, "dpll_gmac_m2_ck", "dpll_gmac_m2_ck"),
+++	DT_CLK(NULL, "gmac_250m_dclk_div", "gmac_250m_dclk_div"),
+++	DT_CLK(NULL, "video2_dclk_div", "video2_dclk_div"),
+++	DT_CLK(NULL, "video1_dclk_div", "video1_dclk_div"),
+++	DT_CLK(NULL, "hdmi_dclk_div", "hdmi_dclk_div"),
+++	DT_CLK(NULL, "per_dpll_hs_clk_div", "per_dpll_hs_clk_div"),
+++	DT_CLK(NULL, "dpll_per_ck", "dpll_per_ck"),
+++	DT_CLK(NULL, "dpll_per_m2_ck", "dpll_per_m2_ck"),
+++	DT_CLK(NULL, "func_96m_aon_dclk_div", "func_96m_aon_dclk_div"),
+++	DT_CLK(NULL, "usb_dpll_hs_clk_div", "usb_dpll_hs_clk_div"),
+++	DT_CLK(NULL, "dpll_usb_ck", "dpll_usb_ck"),
+++	DT_CLK(NULL, "dpll_usb_m2_ck", "dpll_usb_m2_ck"),
+++	DT_CLK(NULL, "l3init_480m_dclk_div", "l3init_480m_dclk_div"),
+++	DT_CLK(NULL, "usb_otg_dclk_div", "usb_otg_dclk_div"),
+++	DT_CLK(NULL, "sata_dclk_div", "sata_dclk_div"),
+++	DT_CLK(NULL, "dpll_pcie_ref_m2_ck", "dpll_pcie_ref_m2_ck"),
+++	DT_CLK(NULL, "pcie2_dclk_div", "pcie2_dclk_div"),
+++	DT_CLK(NULL, "pcie_dclk_div", "pcie_dclk_div"),
+++	DT_CLK(NULL, "emu_dclk_div", "emu_dclk_div"),
+++	DT_CLK(NULL, "secure_32k_dclk_div", "secure_32k_dclk_div"),
+++	DT_CLK(NULL, "eve_dpll_hs_clk_div", "eve_dpll_hs_clk_div"),
+++	DT_CLK(NULL, "dpll_eve_ck", "dpll_eve_ck"),
+++	DT_CLK(NULL, "dpll_eve_m2_ck", "dpll_eve_m2_ck"),
+++	DT_CLK(NULL, "eve_dclk_div", "eve_dclk_div"),
+++	DT_CLK(NULL, "clkoutmux0_clk_mux", "clkoutmux0_clk_mux"),
+++	DT_CLK(NULL, "clkoutmux1_clk_mux", "clkoutmux1_clk_mux"),
+++	DT_CLK(NULL, "clkoutmux2_clk_mux", "clkoutmux2_clk_mux"),
+++	DT_CLK(NULL, "custefuse_sys_gfclk_div", "custefuse_sys_gfclk_div"),
+++	DT_CLK(NULL, "dpll_core_h13x2_ck", "dpll_core_h13x2_ck"),
+++	DT_CLK(NULL, "dpll_core_h14x2_ck", "dpll_core_h14x2_ck"),
+++	DT_CLK(NULL, "dpll_core_h22x2_ck", "dpll_core_h22x2_ck"),
+++	DT_CLK(NULL, "dpll_core_h23x2_ck", "dpll_core_h23x2_ck"),
+++	DT_CLK(NULL, "dpll_core_h24x2_ck", "dpll_core_h24x2_ck"),
+++	DT_CLK(NULL, "dpll_ddr_x2_ck", "dpll_ddr_x2_ck"),
+++	DT_CLK(NULL, "dpll_ddr_h11x2_ck", "dpll_ddr_h11x2_ck"),
+++	DT_CLK(NULL, "dpll_dsp_x2_ck", "dpll_dsp_x2_ck"),
+++	DT_CLK(NULL, "dpll_dsp_m3x2_ck", "dpll_dsp_m3x2_ck"),
+++	DT_CLK(NULL, "dpll_gmac_x2_ck", "dpll_gmac_x2_ck"),
+++	DT_CLK(NULL, "dpll_gmac_h11x2_ck", "dpll_gmac_h11x2_ck"),
+++	DT_CLK(NULL, "dpll_gmac_h12x2_ck", "dpll_gmac_h12x2_ck"),
+++	DT_CLK(NULL, "dpll_gmac_h13x2_ck", "dpll_gmac_h13x2_ck"),
+++	DT_CLK(NULL, "dpll_gmac_m3x2_ck", "dpll_gmac_m3x2_ck"),
+++	DT_CLK(NULL, "dpll_per_x2_ck", "dpll_per_x2_ck"),
+++	DT_CLK(NULL, "dpll_per_h11x2_ck", "dpll_per_h11x2_ck"),
+++	DT_CLK(NULL, "dpll_per_h12x2_ck", "dpll_per_h12x2_ck"),
+++	DT_CLK(NULL, "dpll_per_h13x2_ck", "dpll_per_h13x2_ck"),
+++	DT_CLK(NULL, "dpll_per_h14x2_ck", "dpll_per_h14x2_ck"),
+++	DT_CLK(NULL, "dpll_per_m2x2_ck", "dpll_per_m2x2_ck"),
+++	DT_CLK(NULL, "dpll_usb_clkdcoldo", "dpll_usb_clkdcoldo"),
+++	DT_CLK(NULL, "eve_clk", "eve_clk"),
+++	DT_CLK(NULL, "func_128m_clk", "func_128m_clk"),
+++	DT_CLK(NULL, "func_12m_fclk", "func_12m_fclk"),
+++	DT_CLK(NULL, "func_24m_clk", "func_24m_clk"),
+++	DT_CLK(NULL, "func_48m_fclk", "func_48m_fclk"),
+++	DT_CLK(NULL, "func_96m_fclk", "func_96m_fclk"),
+++	DT_CLK(NULL, "gmii_m_clk_div", "gmii_m_clk_div"),
+++	DT_CLK(NULL, "hdmi_clk2_div", "hdmi_clk2_div"),
+++	DT_CLK(NULL, "hdmi_div_clk", "hdmi_div_clk"),
+++	DT_CLK(NULL, "hdmi_dpll_clk_mux", "hdmi_dpll_clk_mux"),
+++	DT_CLK(NULL, "l3_iclk_div", "l3_iclk_div"),
+++	DT_CLK(NULL, "l3init_60m_fclk", "l3init_60m_fclk"),
+++	DT_CLK(NULL, "l4_root_clk_div", "l4_root_clk_div"),
+++	DT_CLK(NULL, "mlb_clk", "mlb_clk"),
+++	DT_CLK(NULL, "mlbp_clk", "mlbp_clk"),
+++	DT_CLK(NULL, "per_abe_x1_gfclk2_div", "per_abe_x1_gfclk2_div"),
+++	DT_CLK(NULL, "timer_sys_clk_div", "timer_sys_clk_div"),
+++	DT_CLK(NULL, "video1_clk2_div", "video1_clk2_div"),
+++	DT_CLK(NULL, "video1_div_clk", "video1_div_clk"),
+++	DT_CLK(NULL, "video1_dpll_clk_mux", "video1_dpll_clk_mux"),
+++	DT_CLK(NULL, "video2_clk2_div", "video2_clk2_div"),
+++	DT_CLK(NULL, "video2_div_clk", "video2_div_clk"),
+++	DT_CLK(NULL, "video2_dpll_clk_mux", "video2_dpll_clk_mux"),
+++	DT_CLK(NULL, "wkupaon_iclk_mux", "wkupaon_iclk_mux"),
+++	DT_CLK(NULL, "dss_32khz_clk", "dss_32khz_clk"),
+++	DT_CLK(NULL, "dss_48mhz_clk", "dss_48mhz_clk"),
+++	DT_CLK(NULL, "dss_dss_clk", "dss_dss_clk"),
+++	DT_CLK(NULL, "dss_hdmi_clk", "dss_hdmi_clk"),
+++	DT_CLK(NULL, "dss_video1_clk", "dss_video1_clk"),
+++	DT_CLK(NULL, "dss_video2_clk", "dss_video2_clk"),
+++	DT_CLK(NULL, "dss_deshdcp_clk", "dss_deshdcp_clk"),
+++	DT_CLK(NULL, "gpio1_dbclk", "gpio1_dbclk"),
+++	DT_CLK(NULL, "gpio2_dbclk", "gpio2_dbclk"),
+++	DT_CLK(NULL, "gpio3_dbclk", "gpio3_dbclk"),
+++	DT_CLK(NULL, "gpio4_dbclk", "gpio4_dbclk"),
+++	DT_CLK(NULL, "gpio5_dbclk", "gpio5_dbclk"),
+++	DT_CLK(NULL, "gpio6_dbclk", "gpio6_dbclk"),
+++	DT_CLK(NULL, "gpio7_dbclk", "gpio7_dbclk"),
+++	DT_CLK(NULL, "gpio8_dbclk", "gpio8_dbclk"),
+++	DT_CLK(NULL, "mmc1_clk32k", "mmc1_clk32k"),
+++	DT_CLK(NULL, "mmc2_clk32k", "mmc2_clk32k"),
+++	DT_CLK(NULL, "mmc3_clk32k", "mmc3_clk32k"),
+++	DT_CLK(NULL, "mmc4_clk32k", "mmc4_clk32k"),
+++	DT_CLK(NULL, "sata_ref_clk", "sata_ref_clk"),
+++	DT_CLK(NULL, "usb_otg_ss1_refclk960m", "usb_otg_ss1_refclk960m"),
+++	DT_CLK(NULL, "usb_otg_ss2_refclk960m", "usb_otg_ss2_refclk960m"),
+++	DT_CLK(NULL, "usb_phy1_always_on_clk32k", "usb_phy1_always_on_clk32k"),
+++	DT_CLK(NULL, "usb_phy2_always_on_clk32k", "usb_phy2_always_on_clk32k"),
+++	DT_CLK(NULL, "usb_phy3_always_on_clk32k", "usb_phy3_always_on_clk32k"),
+++	DT_CLK(NULL, "atl_dpll_clk_mux", "atl_dpll_clk_mux"),
+++	DT_CLK(NULL, "atl_gfclk_mux", "atl_gfclk_mux"),
+++	DT_CLK(NULL, "dcan1_sys_clk_mux", "dcan1_sys_clk_mux"),
+++	DT_CLK(NULL, "gmac_gmii_ref_clk_div", "gmac_gmii_ref_clk_div"),
+++	DT_CLK(NULL, "gmac_rft_clk_mux", "gmac_rft_clk_mux"),
+++	DT_CLK(NULL, "gpu_core_gclk_mux", "gpu_core_gclk_mux"),
+++	DT_CLK(NULL, "gpu_hyd_gclk_mux", "gpu_hyd_gclk_mux"),
+++	DT_CLK(NULL, "ipu1_gfclk_mux", "ipu1_gfclk_mux"),
+++	DT_CLK(NULL, "l3instr_ts_gclk_div", "l3instr_ts_gclk_div"),
+++	DT_CLK(NULL, "mcasp1_ahclkr_mux", "mcasp1_ahclkr_mux"),
+++	DT_CLK(NULL, "mcasp1_ahclkx_mux", "mcasp1_ahclkx_mux"),
+++	DT_CLK(NULL, "mcasp1_aux_gfclk_mux", "mcasp1_aux_gfclk_mux"),
+++	DT_CLK(NULL, "mcasp2_ahclkr_mux", "mcasp2_ahclkr_mux"),
+++	DT_CLK(NULL, "mcasp2_ahclkx_mux", "mcasp2_ahclkx_mux"),
+++	DT_CLK(NULL, "mcasp2_aux_gfclk_mux", "mcasp2_aux_gfclk_mux"),
+++	DT_CLK(NULL, "mcasp3_ahclkx_mux", "mcasp3_ahclkx_mux"),
+++	DT_CLK(NULL, "mcasp3_aux_gfclk_mux", "mcasp3_aux_gfclk_mux"),
+++	DT_CLK(NULL, "mcasp4_ahclkx_mux", "mcasp4_ahclkx_mux"),
+++	DT_CLK(NULL, "mcasp4_aux_gfclk_mux", "mcasp4_aux_gfclk_mux"),
+++	DT_CLK(NULL, "mcasp5_ahclkx_mux", "mcasp5_ahclkx_mux"),
+++	DT_CLK(NULL, "mcasp5_aux_gfclk_mux", "mcasp5_aux_gfclk_mux"),
+++	DT_CLK(NULL, "mcasp6_ahclkx_mux", "mcasp6_ahclkx_mux"),
+++	DT_CLK(NULL, "mcasp6_aux_gfclk_mux", "mcasp6_aux_gfclk_mux"),
+++	DT_CLK(NULL, "mcasp7_ahclkx_mux", "mcasp7_ahclkx_mux"),
+++	DT_CLK(NULL, "mcasp7_aux_gfclk_mux", "mcasp7_aux_gfclk_mux"),
+++	DT_CLK(NULL, "mcasp8_ahclkx_mux", "mcasp8_ahclkx_mux"),
+++	DT_CLK(NULL, "mcasp8_aux_gfclk_mux", "mcasp8_aux_gfclk_mux"),
+++	DT_CLK(NULL, "mmc1_fclk_mux", "mmc1_fclk_mux"),
+++	DT_CLK(NULL, "mmc1_fclk_div", "mmc1_fclk_div"),
+++	DT_CLK(NULL, "mmc2_fclk_mux", "mmc2_fclk_mux"),
+++	DT_CLK(NULL, "mmc2_fclk_div", "mmc2_fclk_div"),
+++	DT_CLK(NULL, "mmc3_gfclk_mux", "mmc3_gfclk_mux"),
+++	DT_CLK(NULL, "mmc3_gfclk_div", "mmc3_gfclk_div"),
+++	DT_CLK(NULL, "mmc4_gfclk_mux", "mmc4_gfclk_mux"),
+++	DT_CLK(NULL, "mmc4_gfclk_div", "mmc4_gfclk_div"),
+++	DT_CLK(NULL, "qspi_gfclk_mux", "qspi_gfclk_mux"),
+++	DT_CLK(NULL, "qspi_gfclk_div", "qspi_gfclk_div"),
+++	DT_CLK(NULL, "timer10_gfclk_mux", "timer10_gfclk_mux"),
+++	DT_CLK(NULL, "timer11_gfclk_mux", "timer11_gfclk_mux"),
+++	DT_CLK(NULL, "timer13_gfclk_mux", "timer13_gfclk_mux"),
+++	DT_CLK(NULL, "timer14_gfclk_mux", "timer14_gfclk_mux"),
+++	DT_CLK(NULL, "timer15_gfclk_mux", "timer15_gfclk_mux"),
+++	DT_CLK(NULL, "timer16_gfclk_mux", "timer16_gfclk_mux"),
+++	DT_CLK(NULL, "timer1_gfclk_mux", "timer1_gfclk_mux"),
+++	DT_CLK(NULL, "timer2_gfclk_mux", "timer2_gfclk_mux"),
+++	DT_CLK(NULL, "timer3_gfclk_mux", "timer3_gfclk_mux"),
+++	DT_CLK(NULL, "timer4_gfclk_mux", "timer4_gfclk_mux"),
+++	DT_CLK(NULL, "timer5_gfclk_mux", "timer5_gfclk_mux"),
+++	DT_CLK(NULL, "timer6_gfclk_mux", "timer6_gfclk_mux"),
+++	DT_CLK(NULL, "timer7_gfclk_mux", "timer7_gfclk_mux"),
+++	DT_CLK(NULL, "timer8_gfclk_mux", "timer8_gfclk_mux"),
+++	DT_CLK(NULL, "timer9_gfclk_mux", "timer9_gfclk_mux"),
+++	DT_CLK(NULL, "uart10_gfclk_mux", "uart10_gfclk_mux"),
+++	DT_CLK(NULL, "uart1_gfclk_mux", "uart1_gfclk_mux"),
+++	DT_CLK(NULL, "uart2_gfclk_mux", "uart2_gfclk_mux"),
+++	DT_CLK(NULL, "uart3_gfclk_mux", "uart3_gfclk_mux"),
+++	DT_CLK(NULL, "uart4_gfclk_mux", "uart4_gfclk_mux"),
+++	DT_CLK(NULL, "uart5_gfclk_mux", "uart5_gfclk_mux"),
+++	DT_CLK(NULL, "uart6_gfclk_mux", "uart6_gfclk_mux"),
+++	DT_CLK(NULL, "uart7_gfclk_mux", "uart7_gfclk_mux"),
+++	DT_CLK(NULL, "uart8_gfclk_mux", "uart8_gfclk_mux"),
+++	DT_CLK(NULL, "uart9_gfclk_mux", "uart9_gfclk_mux"),
+++	DT_CLK(NULL, "vip1_gclk_mux", "vip1_gclk_mux"),
+++	DT_CLK(NULL, "vip2_gclk_mux", "vip2_gclk_mux"),
+++	DT_CLK(NULL, "vip3_gclk_mux", "vip3_gclk_mux"),
+++	DT_CLK("omap_i2c.1", "ick", "dummy_ck"),
+++	DT_CLK("omap_i2c.2", "ick", "dummy_ck"),
+++	DT_CLK("omap_i2c.3", "ick", "dummy_ck"),
+++	DT_CLK("omap_i2c.4", "ick", "dummy_ck"),
+++	DT_CLK(NULL, "mailboxes_ick", "dummy_ck"),
+++	DT_CLK("omap_hsmmc.0", "ick", "dummy_ck"),
+++	DT_CLK("omap_hsmmc.1", "ick", "dummy_ck"),
+++	DT_CLK("omap_hsmmc.2", "ick", "dummy_ck"),
+++	DT_CLK("omap_hsmmc.3", "ick", "dummy_ck"),
+++	DT_CLK("omap_hsmmc.4", "ick", "dummy_ck"),
+++	DT_CLK("omap-mcbsp.1", "ick", "dummy_ck"),
+++	DT_CLK("omap-mcbsp.2", "ick", "dummy_ck"),
+++	DT_CLK("omap-mcbsp.3", "ick", "dummy_ck"),
+++	DT_CLK("omap-mcbsp.4", "ick", "dummy_ck"),
+++	DT_CLK("omap2_mcspi.1", "ick", "dummy_ck"),
+++	DT_CLK("omap2_mcspi.2", "ick", "dummy_ck"),
+++	DT_CLK("omap2_mcspi.3", "ick", "dummy_ck"),
+++	DT_CLK("omap2_mcspi.4", "ick", "dummy_ck"),
+++	DT_CLK(NULL, "uart1_ick", "dummy_ck"),
+++	DT_CLK(NULL, "uart2_ick", "dummy_ck"),
+++	DT_CLK(NULL, "uart3_ick", "dummy_ck"),
+++	DT_CLK(NULL, "uart4_ick", "dummy_ck"),
+++	DT_CLK("usbhs_omap", "usbhost_ick", "dummy_ck"),
+++	DT_CLK("usbhs_omap", "usbtll_fck", "dummy_ck"),
+++	DT_CLK("omap_wdt", "ick", "dummy_ck"),
+++	DT_CLK(NULL, "timer_32k_ck", "sys_32k_ck"),
+++	DT_CLK("4ae18000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48032000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48034000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48036000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("4803e000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48086000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48088000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48820000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48822000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48824000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48826000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("48828000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("4882a000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("4882c000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("4882e000.timer", "timer_sys_ck", "timer_sys_clk_div"),
+++	DT_CLK("4843e200.ehrpwm", "tbclk", "ehrpwm0_tbclk"),
+++	DT_CLK("48440200.ehrpwm", "tbclk", "ehrpwm1_tbclk"),
+++	DT_CLK("48442200.ehrpwm", "tbclk", "ehrpwm2_tbclk"),
+++	DT_CLK(NULL, "sys_clkin", "sys_clkin1"),
+++	{ .node_name = NULL },
+++};
+++
+++int __init dra7xx_dt_clk_init(void)
+++{
+++	int rc;
+++	struct clk *abe_dpll_mux, *sys_clkin2, *dpll_ck, *dss_deshdcp_ck;
+++	struct clk *ipu1_gfclk, *ipu1_gfclk_parent;
+++	struct clk *dsp_m2_dpll, *dsp_m3x2_dpll;
+++	struct clk *atl_fck, *atl_parent;
+++
+++	ti_dt_clocks_register(dra7xx_clks);
+++
+++	omap2_clk_disable_autoidle_all();
+++
+++	abe_dpll_mux = clk_get_sys(NULL, "abe_dpll_sys_clk_mux");
+++	sys_clkin2 = clk_get_sys(NULL, "sys_clkin2");
+++	dpll_ck = clk_get_sys(NULL, "dpll_abe_ck");
+++
+++	rc = clk_set_parent(abe_dpll_mux, sys_clkin2);
+++	if (!rc)
+++		rc = clk_set_rate(dpll_ck, DRA7_DPLL_ABE_DEFFREQ);
+++	if (rc)
+++		pr_err("%s: failed to configure ABE DPLL!\n", __func__);
+++
+++	dpll_ck = clk_get_sys(NULL, "dpll_abe_m2x2_ck");
+++	rc = clk_set_rate(dpll_ck, DRA7_DPLL_ABE_DEFFREQ * 2);
+++	if (rc)
+++		pr_err("%s: failed to configure ABE DPLL m2x2!\n", __func__);
+++
+++	dpll_ck = clk_get_sys(NULL, "dpll_gmac_ck");
+++	rc = clk_set_rate(dpll_ck, DRA7_DPLL_GMAC_DEFFREQ);
+++	if (rc)
+++		pr_err("%s: failed to configure GMAC DPLL!\n", __func__);
+++
+++	dss_deshdcp_ck = clk_get_sys(NULL, "dss_deshdcp_clk");
+++	rc = clk_prepare_enable(dss_deshdcp_ck);
+++	if (rc)
+++		pr_err("%s: failed to enable DESHDCP clock\n", __func__);
+++
+++	ipu1_gfclk = clk_get_sys(NULL, "ipu1_gfclk_mux");
+++	ipu1_gfclk_parent = clk_get_sys(NULL, "dpll_core_h22x2_ck");
+++	rc = clk_set_parent(ipu1_gfclk, ipu1_gfclk_parent);
+++	if (rc)
+++		pr_err("%s: failed to reparent ipu1_gfclk_mux\n", __func__);
+++
+++	dsp_m2_dpll = clk_get_sys(NULL, "dpll_dsp_m2_ck");
+++	rc = clk_set_rate(dsp_m2_dpll, DRA7_DPLL_DSP_GFCLK_NOMFREQ);
+++	if (rc)
+++		pr_err("%s: failed to configure DSP DPLL m2 output!\n",
+++		       __func__);
+++
+++	dsp_m3x2_dpll = clk_get_sys(NULL, "dpll_dsp_m3x2_ck");
+++	rc = clk_set_rate(dsp_m3x2_dpll, DRA7_DPLL_EVE_GCLK_NOMFREQ);
+++	if (rc)
+++		pr_err("%s: failed to configure DSP DPLL m3x2 divider!\n",
+++		       __func__);
+++
+++	atl_fck = clk_get_sys(NULL, "atl_gfclk_mux");
+++	atl_parent = clk_get_sys(NULL, "dpll_abe_m2_ck");
+++	rc = clk_set_parent(atl_fck, atl_parent);
+++	if (rc)
+++		pr_err("%s: failed to reparent atl_gfclk_mux\n", __func__);
+++
+++	atl_fck = clk_get_sys(NULL, "atl_clkin2_ck");
+++	rc = clk_set_rate(atl_fck, DRA7_ATL_DEFFREQ);
+++	if (rc)
+++		pr_err("%s: failed to set atl_clkin2_ck\n", __func__);
+++
+++	atl_fck = clk_get_sys(NULL, "atl_clkin1_ck");
+++	rc = clk_set_rate(atl_fck, DRA7_ATL_DEFFREQ);
+++	if (rc)
+++		pr_err("%s: failed to set atl_clkin1_ck\n", __func__);
+++
+++	dpll_ck = clk_get_sys(NULL, "dpll_usb_ck");
+++	rc = clk_set_rate(dpll_ck, DRA7_DPLL_USB_DEFFREQ);
+++	if (rc)
+++		pr_err("%s: failed to configure USB DPLL!\n", __func__);
+++
+++	dpll_ck = clk_get_sys(NULL, "dpll_usb_m2_ck");
+++	rc = clk_set_rate(dpll_ck, DRA7_DPLL_USB_DEFFREQ/2);
+++	if (rc)
+++		pr_err("%s: failed to set USB_DPLL M2 OUT\n", __func__);
+++
+++	return rc;
+++}
++-- 
++1.9.1
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0008-dra7-dom0-remove-unused-hw-data.patch b/recipes-kernel/linux/linux-kernel-patches/0008-dra7-dom0-remove-unused-hw-data.patch
+new file mode 100644
+index 0000000..e0a8df3
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0008-dra7-dom0-remove-unused-hw-data.patch
+@@ -0,0 +1,77 @@
++From bb6a3efbe14cdcf0daecd2afb852735fe11beafc Mon Sep 17 00:00:00 2001
++From: "oleksii.kurochko" <oleksii.kurochko@globallogic.com>
++Date: Fri, 3 Jun 2016 11:55:15 +0300
++Subject: [PATCH] dra7: dom0: remove unused hw data
++
++Work done:
++* Remove unused uart
++---
++ arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c |   31 ++++++++++++------------
++ 1 file changed, 16 insertions(+), 15 deletions(-)
++
++diff --git a/arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c b/arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c
++index 06eb4b7..56ccbe3 100644
++--- a/arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c
+++++ b/arch/arm/mach-omap2/omap_hwmod_7xx_dom0_data.c
++@@ -2893,20 +2893,20 @@ static struct omap_hwmod_class dra7xx_uart_hwmod_class = {
++ };
++ 
++ /* uart1 */
++-static struct omap_hwmod dra7xx_uart1_hwmod = {
++-	.name		= "uart1",
++-	.class		= &dra7xx_uart_hwmod_class,
++-	.clkdm_name	= "l4per_clkdm",
++-	.main_clk	= "uart1_gfclk_mux",
++-	.flags		= HWMOD_SWSUP_SIDLE_ACT | DEBUG_OMAP2UART1_FLAGS,
++-	.prcm = {
++-		.omap4 = {
++-			.clkctrl_offs = DRA7XX_CM_L4PER_UART1_CLKCTRL_OFFSET,
++-			.context_offs = DRA7XX_RM_L4PER_UART1_CONTEXT_OFFSET,
++-			.modulemode   = MODULEMODE_SWCTRL,
++-		},
++-	},
++-};
+++//static struct omap_hwmod dra7xx_uart1_hwmod = {
+++//	.name		= "uart1",
+++//	.class		= &dra7xx_uart_hwmod_class,
+++//	.clkdm_name	= "l4per_clkdm",
+++//	.main_clk	= "uart1_gfclk_mux",
+++//	.flags		= HWMOD_SWSUP_SIDLE_ACT | DEBUG_OMAP2UART1_FLAGS,
+++//	.prcm = {
+++//		.omap4 = {
+++//			.clkctrl_offs = DRA7XX_CM_L4PER_UART1_CLKCTRL_OFFSET,
+++//			.context_offs = DRA7XX_RM_L4PER_UART1_CONTEXT_OFFSET,
+++//			.modulemode   = MODULEMODE_SWCTRL,
+++//		},
+++//	},
+++//};
++ 
++ /* uart2 */
++ static struct omap_hwmod dra7xx_uart2_hwmod = {
++@@ -4462,6 +4462,7 @@ static struct omap_hwmod_ocp_if dra7xx_l4_per3__timer16 = {
++ 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
++ };
++ 
+++#if 0
++ /* l4_per1 -> uart1 */
++ static struct omap_hwmod_ocp_if dra7xx_l4_per1__uart1 = {
++ 	.master		= &dra7xx_l4_per1_hwmod,
++@@ -4469,6 +4470,7 @@ static struct omap_hwmod_ocp_if dra7xx_l4_per1__uart1 = {
++ 	.clk		= "l3_iclk_div",
++ 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
++ };
+++#endif
++ 
++ /* l4_per1 -> uart2 */
++ static struct omap_hwmod_ocp_if dra7xx_l4_per1__uart2 = {
++@@ -4780,7 +4782,6 @@ static struct omap_hwmod_ocp_if *dra7xx_hwmod_ocp_ifs[] __initdata = {
++ 	&dra7xx_l4_per3__timer14,
++ 	&dra7xx_l4_per3__timer15,
++ 	&dra7xx_l4_per3__timer16,
++-	&dra7xx_l4_per1__uart1,
++ 	&dra7xx_l4_per1__uart2,
++ 	&dra7xx_l4_per1__uart3,
++ 	&dra7xx_l4_per1__uart4,
++-- 
++1.7.9.5
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0009-dra7xx-dom0-dts-configure-rambase_pfn-and-align-ram-.patch b/recipes-kernel/linux/linux-kernel-patches/0009-dra7xx-dom0-dts-configure-rambase_pfn-and-align-ram-.patch
+new file mode 100644
+index 0000000..28729bc
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0009-dra7xx-dom0-dts-configure-rambase_pfn-and-align-ram-.patch
+@@ -0,0 +1,48 @@
++From beaa99925ed61ec809f645ac0ccadde8f5b4258e Mon Sep 17 00:00:00 2001
++From: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++Date: Tue, 12 Apr 2016 15:01:47 +0300
++Subject: [PATCH] dra7xx: dom0: dts: configure rambase_pfn and align ram
++ settings with GLSDK
++
++Memory was divided to 3 address ranges because that was needed
++to start Dom0/DomU. Now all kernels have 'rambase_pfn' settings
++that allows to put each kernel to the defined address. So we
++should use memory description as single address range (as it
++was done in the GLSDK 7.XX releases). In addition this patch
++sets rambase_pfn=0x80000 for kernel Dom0 because there are
++few reserved memory regions (for example IPU2, etc.) which
++should be within kernel Dom0 address space.
++
++Change-Id: I673bbf4df6e93506b6950221d32a734fa16155ef
++Signed-off-by: Oleksandr Dmytryshyn <oleksandr.dmytryshyn@globallogic.com>
++---
++ arch/arm/boot/dts/dra7-evm-dom0.dts | 6 ++----
++ 1 file changed, 2 insertions(+), 4 deletions(-)
++
++diff --git a/arch/arm/boot/dts/dra7-evm-dom0.dts b/arch/arm/boot/dts/dra7-evm-dom0.dts
++index 210d836..526084c 100644
++--- a/arch/arm/boot/dts/dra7-evm-dom0.dts
+++++ b/arch/arm/boot/dts/dra7-evm-dom0.dts
++@@ -17,7 +17,7 @@
++ 	compatible = "ti,dra7-evm", "ti,dra742", "ti,dra74", "ti,dra7";
++ 
++ 	chosen {
++-		bootargs = "dom0_mem=512M console=dtuart dtuart=serial0 dom0_max_vcpus=2 bootscrub=0 flask_enforcing=1";
+++		bootargs = "dom0_mem=512M dom0_rambase_pfn=0x80000 console=dtuart dtuart=serial0 dom0_max_vcpus=2 bootscrub=0 flask_enforcing=1";
++ 		xen,dom0-bootargs = "console=hvc0 earlyprintk omapdrm.num_crtc=2 root=/dev/sda12 rw rootwait rootfstype=ext4 uio_pdrv_genirq.of_id=generic-uio";
++ 		modules {
++ 			#address-cells = <1>;
++@@ -51,9 +51,7 @@
++ 
++ 	memory {
++ 		device_type = "memory";
++-		reg = <0x80000000 0x20000000>, /* 512 MiB */
++-		      <0xA0000000 0x20000000>, /* 512 MiB */
++-		      <0xC0000000 0x20000000>; /* 512 MiB */
+++		reg = <0x80000000 0x60000000>; /* 1536 MB */
++ 	};
++ 
++ 	reserved_mem: reserved-memory {
++-- 
++1.7.9.5
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0010-dra7-evm-dom0.dts-enable-gpu-in-dom0.patch b/recipes-kernel/linux/linux-kernel-patches/0010-dra7-evm-dom0.dts-enable-gpu-in-dom0.patch
+new file mode 100644
+index 0000000..a33f509
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0010-dra7-evm-dom0.dts-enable-gpu-in-dom0.patch
+@@ -0,0 +1,78 @@
++From dcf593280c897475b93ef7f32e0b5a62a4ab7151 Mon Sep 17 00:00:00 2001
++From: Oleksii Kurochko <oleksii.kurochko@globallogic.com>
++Date: Mon, 6 Jun 2016 10:16:47 +0300
++Subject: [PATCH] dra7-evm-dom0.dts: enable gpu in dom0
++
++* enable gpu clocks
++* enable gpu voltdm
++* enable gpu
++---
++ arch/arm/boot/dts/dra7-evm-dom0.dts |   41 -----------------------------------
++ 1 file changed, 41 deletions(-)
++
++diff --git a/arch/arm/boot/dts/dra7-evm-dom0.dts b/arch/arm/boot/dts/dra7-evm-dom0.dts
++index 526084c..ce44b71 100644
++--- a/arch/arm/boot/dts/dra7-evm-dom0.dts
+++++ b/arch/arm/boot/dts/dra7-evm-dom0.dts
++@@ -1241,7 +1241,6 @@ i2c_p3_exp: &i2c2 {
++ };
++ 
++ &voltdm_gpu {
++-	status = "disabled";
++ 	vdd-supply = <&smps6_reg>;
++ };
++ 
++@@ -1653,7 +1652,6 @@ i2c_p3_exp: &i2c2 {
++ };
++ 
++ &gpu {
++-	status = "disabled";
++ 	interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
++ };
++ 
++@@ -1859,42 +1857,3 @@ video_in: &vin1a {
++ 			<&pcf_jamr3_21 8 GPIO_ACTIVE_LOW>;	/*SEL_TVP_FPD*/
++ };
++ 
++-&dpll_gpu_byp_mux {
++-	compatible = "";
++-};
++-
++-&dpll_gpu_ck {
++-	compatible = "";
++-};
++-
++-&dpll_core_m2_ck {
++-	compatible = "";
++-};
++-
++-&gpu_dclk {
++-	compatible = "";
++-};
++-
++-&clkoutmux0_clk_mux {
++-	clocks = <&sys_clk1_dclk_div>, <&sys_clk2_dclk_div>, <&per_abe_x1_dclk_div>, <&mpu_dclk_div>, <&dsp_gclk_div>, <&iva_dclk>, <&core_dpll_out_dclk_div>, <&emif_phy_dclk_div>, <&gmac_250m_dclk_div>, <&video2_dclk_div>, <&video1_dclk_div>, <&hdmi_dclk_div>, <&func_96m_aon_dclk_div>, <&l3init_480m_dclk_div>, <&usb_otg_dclk_div>, <&sata_dclk_div>, <&pcie2_dclk_div>, <&pcie_dclk_div>, <&emu_dclk_div>, <&secure_32k_dclk_div>, <&eve_dclk_div>;
++-};
++-
++-&clkoutmux1_clk_mux {
++-	clocks = <&sys_clk1_dclk_div>, <&sys_clk2_dclk_div>, <&per_abe_x1_dclk_div>, <&mpu_dclk_div>, <&dsp_gclk_div>, <&iva_dclk>, <&core_dpll_out_dclk_div>, <&emif_phy_dclk_div>, <&gmac_250m_dclk_div>, <&video2_dclk_div>, <&video1_dclk_div>, <&hdmi_dclk_div>, <&func_96m_aon_dclk_div>, <&l3init_480m_dclk_div>, <&usb_otg_dclk_div>, <&sata_dclk_div>, <&pcie2_dclk_div>, <&pcie_dclk_div>, <&emu_dclk_div>, <&secure_32k_dclk_div>, <&eve_dclk_div>;
++-};
++-
++-&clkoutmux2_clk_mux {
++-	clocks = <&sys_clk1_dclk_div>, <&sys_clk2_dclk_div>, <&per_abe_x1_dclk_div>, <&mpu_dclk_div>, <&dsp_gclk_div>, <&iva_dclk>, <&core_dpll_out_dclk_div>, <&emif_phy_dclk_div>, <&gmac_250m_dclk_div>, <&video2_dclk_div>, <&video1_dclk_div>, <&hdmi_dclk_div>, <&func_96m_aon_dclk_div>, <&l3init_480m_dclk_div>, <&usb_otg_dclk_div>, <&sata_dclk_div>, <&pcie2_dclk_div>, <&pcie_dclk_div>, <&emu_dclk_div>, <&secure_32k_dclk_div>, <&eve_dclk_div>;
++-};
++-
++-&gpu_core_gclk_mux {
++-	compatible = "";
++-};
++-
++-&gpu_hyd_gclk_mux {
++-	compatible = "";
++-};
++-
++-&gpu_clkdm {
++-	compatible = "";
++-};
++-- 
++1.7.9.5
++
+diff --git a/recipes-kernel/linux/linux-kernel-patches/0011-dra7-evm-dom0.dts-change-rootfs-location.patch b/recipes-kernel/linux/linux-kernel-patches/0011-dra7-evm-dom0.dts-change-rootfs-location.patch
+new file mode 100644
+index 0000000..2521a85
+--- /dev/null
++++ b/recipes-kernel/linux/linux-kernel-patches/0011-dra7-evm-dom0.dts-change-rootfs-location.patch
+@@ -0,0 +1,25 @@
++From bad714a3525f55774e3ae6164cb3693752ae830b Mon Sep 17 00:00:00 2001
++From: Oleksii Kurochko <oleksii.kurochko@globallogic.com>
++Date: Mon, 6 Jun 2016 11:38:35 +0300
++Subject: [PATCH] dra7-evm-dom0.dts: change rootfs location
++
++---
++ arch/arm/boot/dts/dra7-evm-dom0.dts |    2 +-
++ 1 file changed, 1 insertion(+), 1 deletion(-)
++
++diff --git a/arch/arm/boot/dts/dra7-evm-dom0.dts b/arch/arm/boot/dts/dra7-evm-dom0.dts
++index ce44b71..533727b 100644
++--- a/arch/arm/boot/dts/dra7-evm-dom0.dts
+++++ b/arch/arm/boot/dts/dra7-evm-dom0.dts
++@@ -18,7 +18,7 @@
++ 
++ 	chosen {
++ 		bootargs = "dom0_mem=512M dom0_rambase_pfn=0x80000 console=dtuart dtuart=serial0 dom0_max_vcpus=2 bootscrub=0 flask_enforcing=1";
++-		xen,dom0-bootargs = "console=hvc0 earlyprintk omapdrm.num_crtc=2 root=/dev/sda12 rw rootwait rootfstype=ext4 uio_pdrv_genirq.of_id=generic-uio";
+++		xen,dom0-bootargs = "console=hvc0 earlyprintk omapdrm.num_crtc=2 root=/dev/mmcblk0p2 rw rootwait rootfstype=ext4 uio_pdrv_genirq.of_id=generic-uio";
++ 		modules {
++ 			#address-cells = <1>;
++ 			#size-cells = <1>;
++-- 
++1.7.9.5
++
+diff --git a/recipes-kernel/linux/linux-ti-glsdk_3.14.bb b/recipes-kernel/linux/linux-ti-glsdk_3.14.bb
+index 24089cc..f1b451d 100644
+--- a/recipes-kernel/linux/linux-ti-glsdk_3.14.bb
++++ b/recipes-kernel/linux/linux-ti-glsdk_3.14.bb
+@@ -10,6 +10,7 @@ require recipes-kernel/linux/setup-defconfig.inc
+ 
+ # Look in the generic major.minor directory for files
+ FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}-3.14:"
++FILESEXTRAPATHS_prepend := "${THISDIR}/linux-kernel-patches:"
+ 
+ # Pull in the devicetree files into the rootfs
+ RDEPENDS_kernel-base += "kernel-devicetree"
+@@ -70,3 +71,16 @@ KERNEL_GIT_PROTOCOL = "git"
+ SRC_URI = "${KERNEL_GIT_URI};protocol=${KERNEL_GIT_PROTOCOL};branch=${BRANCH} \
+            file://defconfig \
+           "
++SRC_URI += " \
++	file://0001-omap2plus_dom0_defconfig-introduce-defconfig-for-dom.patch \
++	file://0002-omap2plus_dom0_defconfig-switch-to-the-dom0-defconfi.patch \
++	file://0003-ARM-dts-DRA7xx-introduce-device-tree-for-domain-0.patch \
++	file://0004-dra7xx-dom0-dts-switch-to-the-dom0-device-tree.patch \
++	file://0005-ARM-OMAP2-Wakeupgen-doesn-t-enable-ES2-PM-mode-under.patch \
++	file://0006-xen-disabling-CNTFRQ-register-configuration.patch \
++	file://0007-dra7-dom0-introduce-hardware-data.patch \
++	file://0008-dra7-dom0-remove-unused-hw-data.patch \
++	file://0009-dra7xx-dom0-dts-configure-rambase_pfn-and-align-ram-.patch \
++	file://0010-dra7-evm-dom0.dts-enable-gpu-in-dom0.patch \
++	file://0011-dra7-evm-dom0.dts-change-rootfs-location.patch \
++	"
+-- 
+1.7.9.5
+
diff --git a/patch/meta-ti/0002-meta-ti-change-uboot-config.patch b/patch/meta-ti/0002-meta-ti-change-uboot-config.patch
new file mode 100644
index 0000000..23e64aa
--- /dev/null
+++ b/patch/meta-ti/0002-meta-ti-change-uboot-config.patch
@@ -0,0 +1,25 @@
+From dc0ec4516507c38cbe9ecf36bce367313feb4dc3 Mon Sep 17 00:00:00 2001
+From: Oleksii Kurochko <oleksii.kurochko@globallogic.com>
+Date: Mon, 6 Jun 2016 15:51:20 +0300
+Subject: [PATCH] meta-ti: change uboot config
+
+---
+ conf/machine/dra7xx-evm.conf |    2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/conf/machine/dra7xx-evm.conf b/conf/machine/dra7xx-evm.conf
+index 3b88668..fdac542 100644
+--- a/conf/machine/dra7xx-evm.conf
++++ b/conf/machine/dra7xx-evm.conf
+@@ -10,7 +10,7 @@ IMAGE_FSTYPES += "ubi tar.gz"
+ 
+ SERIAL_CONSOLE = "115200 ttyO0"
+ 
+-UBOOT_MACHINE = "dra7xx_evm_config"
++UBOOT_MACHINE = "dra7xx_evm_nautilus_config"
+ 
+ # UBI information.  Note that this is board and kernel specific.  Changes
+ # in your kernel port may require changes in these variables.  For more
+-- 
+1.7.9.5
+
diff --git a/patch/meta-ti/0003-meta-ti-change-console-to-hvc0.patch b/patch/meta-ti/0003-meta-ti-change-console-to-hvc0.patch
new file mode 100644
index 0000000..ec39614
--- /dev/null
+++ b/patch/meta-ti/0003-meta-ti-change-console-to-hvc0.patch
@@ -0,0 +1,25 @@
+From 6b1191db852de2fcc140175f8a082b15c1cac682 Mon Sep 17 00:00:00 2001
+From: Oleksii Kurochko <oleksii.kurochko@globallogic.com>
+Date: Mon, 6 Jun 2016 16:42:02 +0300
+Subject: [PATCH] meta-ti: change console to hvc0
+
+---
+ conf/machine/dra7xx-evm.conf |    2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/conf/machine/dra7xx-evm.conf b/conf/machine/dra7xx-evm.conf
+index 5413428..e1689f3 100644
+--- a/conf/machine/dra7xx-evm.conf
++++ b/conf/machine/dra7xx-evm.conf
+@@ -8,7 +8,7 @@ MACHINE_FEATURES += "touchscreen"
+ 
+ IMAGE_FSTYPES += "ubi tar.gz"
+ 
+-SERIAL_CONSOLE = "115200 ttyO0"
++SERIAL_CONSOLE = "115200 hvc0"
+ 
+ UBOOT_MACHINE = "dra7xx_evm_nautilus_config"
+ 
+-- 
+1.7.9.5
+
diff --git a/patch/oe-core/0003-oe-core-fix-getting-of-id-for-inittab.patch b/patch/oe-core/0003-oe-core-fix-getting-of-id-for-inittab.patch
new file mode 100644
index 0000000..0974062
--- /dev/null
+++ b/patch/oe-core/0003-oe-core-fix-getting-of-id-for-inittab.patch
@@ -0,0 +1,25 @@
+From d240c5e651d0a94e7c7c31f32c3395f9d7a7798e Mon Sep 17 00:00:00 2001
+From: Oleksii Kurochko <oleksii.kurochko@globallogic.com>
+Date: Mon, 6 Jun 2016 18:03:49 +0300
+Subject: [PATCH] oe-core: fix getting of id for inittab
+
+---
+ .../sysvinit/sysvinit-inittab_2.88dsf.bb           |    2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/meta/recipes-core/sysvinit/sysvinit-inittab_2.88dsf.bb b/meta/recipes-core/sysvinit/sysvinit-inittab_2.88dsf.bb
+index 30641da..ddbae96 100644
+--- a/meta/recipes-core/sysvinit/sysvinit-inittab_2.88dsf.bb
++++ b/meta/recipes-core/sysvinit/sysvinit-inittab_2.88dsf.bb
+@@ -22,7 +22,7 @@ do_install() {
+     for i in $tmp
+     do
+ 	j=`echo ${i} | sed s/\;/\ /g`
+-	label=`echo ${i} | sed -e 's/^.*;tty//' -e 's/;.*//'`
++	label=`echo ${i} | sed -e 's/^.*;hvc//' -e 's/;.*//'`
+ 	echo "$label:12345:respawn:${base_sbindir}/getty ${j}" >> ${D}${sysconfdir}/inittab
+     done
+ 
+-- 
+1.7.9.5
+
-- 
1.7.9.5

